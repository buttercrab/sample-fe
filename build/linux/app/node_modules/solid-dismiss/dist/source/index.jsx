import { isServer } from "solid-js/web";
import { untrack, createEffect, onCleanup, on, createUniqueId, createMemo, createComputed, } from "solid-js";
import { dismissStack, addDismissStack, removeDismissStack, } from "./global/dismissStack";
import { addGlobalEvents, globalState, removeGlobalEvents, } from "./global/globalEvents";
import { addMenuPopupEl, removeMenuPopupEl } from "./local/menuPopup";
import { addMenuButtonEventsAndAttributes, getMenuButton, onBlurMenuButton, onClickMenuButton, onClickOutsideMenuButton, onFocusMenuButton, onKeydownMenuButton, onMouseDownMenuButton, setTargetAriaExpandFalse, setTargetAriaExpandTrue, } from "./local/menuButton";
import { Transition } from "./components/Transition";
import { removeLocalEvents } from "./local/manageLocalEvents";
import { onFocusInContainer, onFocusOutContainer, runFocusOnActive, } from "./local/container";
import { onClickOverlay, onMouseDownOverlay, onMouseUpOverlay, } from "./local/overlay";
import { activateLastFocusSentinel, onFocusSentinel, } from "./local/focusSentinel";
import { queryElement } from "./utils/queryElement";
import { getNextTabbableElement } from "./utils/tabbing";
import CustomPortal from "./components/CustomPortal";
import { removeEventsOnActiveMountedPopup } from "./local/thirdPartyPopup";
import { runToggleScrollbar } from "./utils/runToggleScrollbar";
/**
 *
 * Handles "click outside" behavior for button popup pairings. Closing is triggered by click/focus outside of popup element or pressing "Escape" key.
 */
const Dismiss = (props) => {
    const modal = props.modal || false;
    const { id, menuButton, menuPopup, focusElementOnClose, focusElementOnOpen = modal ? "menuPopup" : undefined, focusMenuButtonOnMouseDown = true, cursorKeys = false, closeWhenMenuButtonIsTabbed = false, closeWhenMenuButtonIsClicked = true, closeWhenScrolling = false, closeWhenDocumentBlurs = false, closeWhenOverlayClicked = true, closeWhenEscapeKeyIsPressed = true, closeWhenClickingOutside = true, overlay = modal, overlayElement = modal, trapFocus = modal, removeScrollbar = modal, enableLastFocusSentinel = false, mount = modal ? "body" : undefined, 
    // stopComponentEventPropagation = false,
    show = false, onToggleScrollbar, onOpen, deadMenuButton, ignoreMenuPopupWhenTabbing, mountedPopupsSafeList, } = props;
    const state = {
        mount,
        modal,
        addedFocusOutAppEvents: false,
        closeWhenOverlayClicked,
        closeWhenDocumentBlurs,
        closeWhenEscapeKeyIsPressed,
        closeWhenMenuButtonIsClicked,
        closeWhenMenuButtonIsTabbed,
        closeWhenScrolling,
        closeWhenClickingOutside,
        cursorKeys,
        focusElementOnClose,
        focusMenuButtonOnMouseDown,
        deadMenuButton,
        focusElementOnOpen,
        ignoreMenuPopupWhenTabbing,
        // @ts-ignore
        id,
        uniqueId: createUniqueId(),
        menuBtnId: "",
        focusedMenuBtn: { el: null },
        menuBtnKeyupTabFired: false,
        menuButton,
        timeouts: {
            containerFocusTimeoutId: null,
            menuButtonBlurTimeoutId: null,
        },
        upperStackRemovedByFocusOut: false,
        menuPopup,
        closeByDismissEvent: false,
        menuPopupAdded: false,
        enableLastFocusSentinel,
        overlay,
        overlayElement,
        onToggleScrollbar,
        removeScrollbar,
        trapFocus,
        hasFocusSentinels: !!focusElementOnClose ||
            overlay ||
            !!overlayElement ||
            trapFocus ||
            enableLastFocusSentinel,
        mountedPopupsSafeList,
        open: props.open,
        setOpen: props.setOpen,
        onClickOutsideMenuButtonRef: () => onClickOutsideMenuButton(state),
        onClickOverlayRef: () => onClickOverlay(state),
        onFocusInContainerRef: (e) => onFocusInContainer(state, e),
        onFocusOutContainerRef: (e) => onFocusOutContainer(state, e),
        onBlurMenuButtonRef: (e) => onBlurMenuButton(state, e),
        onClickMenuButtonRef: (e) => onClickMenuButton(state, e),
        onMouseDownMenuButtonRef: (e) => onMouseDownMenuButton(state, e),
        onFocusMenuButtonRef: (e) => onFocusMenuButton(state, e),
        onKeydownMenuButtonRef: (e) => onKeydownMenuButton(state, e),
        refContainerCb: (el) => {
            if (overlayElement) {
                el.style.zIndex = "1000";
                if (modal) {
                    el.style.pointerEvents = "none";
                    el.style.position = "relative";
                    const setDialogElStyle = (el) => {
                        // TODO if it already has id, then update button with aria-controls value
                        if (!el.id) {
                            el.id = state.uniqueId;
                        }
                        el.style.pointerEvents = "all";
                        el.setAttribute("role", "dialog");
                    };
                    // setDialogElStyle(el);
                    requestAnimationFrame(() => {
                        const dialog = el.querySelector('[role="dialog"]');
                        if (!dialog) {
                            const children = el.children;
                            if (!children)
                                return;
                            const dialog = children[1];
                            // const child = children[1];
                            // const dialog = child.firstElementChild as HTMLElement;
                            setDialogElStyle(dialog);
                            return;
                        }
                        setDialogElStyle(dialog);
                    });
                }
            }
            if (props.ref) {
                // @ts-ignore
                props.ref(el);
            }
            state.containerEl = el;
        },
        refOverlayCb: (el) => {
            el.style.position = "fixed";
            el.style.top = "0";
            el.style.left = "0";
            el.style.width = "100%";
            el.style.height = "calc(100% + 100px)";
            el.style.zIndex = "1000";
            if (typeof overlayElement === "object" && overlayElement.ref) {
                overlayElement.ref(el);
            }
            state.overlayEl = el;
        },
    };
    const initDefer = !props.open();
    const resetFocusOnClose = () => {
        const activeElement = document.activeElement;
        if (activeElement !== document.body) {
            if (state.menuBtnEls.every((menuBtnEl) => activeElement !== menuBtnEl) &&
                !state.containerEl?.contains(activeElement)) {
                return;
            }
        }
        const { menuBtnEls, focusedMenuBtn, timeouts } = state;
        const menuBtnEl = getMenuButton(menuBtnEls);
        const el = queryElement(state, {
            inputElement: focusElementOnClose,
            type: "focusElementOnClose",
            subType: "click",
        }) || menuBtnEl;
        if (el) {
            el.focus();
            if (el === menuBtnEl) {
                // TODO:?
                // markFocusedMenuButton({ focusedMenuBtn, timeouts, el });
            }
        }
    };
    const getMountNode = () => {
        return typeof mount === "string" ? document.querySelector(mount) : mount;
    };
    const programmaticRemoval = () => {
        if (globalState.closedByEvents)
            return;
        const activeElement = document.activeElement;
        if (
        // activeElement !== state.menuBtnEls
        state.menuBtnEls.every((menuBtnEl) => activeElement !== menuBtnEl) &&
            !state.containerEl?.contains(activeElement)) {
            setTimeout(() => {
                globalState.closedBySetOpen = false;
            });
            return;
        }
        if (!globalState.closedBySetOpen) {
            globalState.closedBySetOpen = true;
            setTimeout(() => {
                globalState.closedBySetOpen = false;
                resetFocusOnClose();
            });
        }
    };
    createComputed(on(() => !!props.open(), (open, prevOpen) => {
        if (open === prevOpen)
            return;
        if (!open) {
            if (state.focusSentinelAfterEl) {
                state.focusSentinelAfterEl.tabIndex = -1;
            }
            programmaticRemoval();
        }
    }, { defer: initDefer }));
    createEffect(on(() => typeof props.menuButton === "function"
        ? props.menuButton()
        : props.menuButton, (menuButton) => {
        addMenuButtonEventsAndAttributes({
            state,
            menuButton,
            open: props.open,
        });
        onCleanup(() => {
            if (!state || isServer)
                return;
            // removeMenuButtonEvents(state, true);
        });
    }));
    createEffect(on(() => !!props.open(), (open, prevOpen) => {
        if (open === prevOpen)
            return;
        if (open) {
            globalState.closedByEvents = false;
            addMenuPopupEl(state);
            runFocusOnActive(state);
            setTargetAriaExpandTrue(state);
            addGlobalEvents(closeWhenScrolling);
            addDismissStack({
                // @ts-ignore
                id,
                uniqueId: state.uniqueId,
                open: props.open,
                setOpen: props.setOpen,
                containerEl: state.containerEl,
                menuBtnEls: state.menuBtnEls,
                focusedMenuBtn: state.focusedMenuBtn,
                overlayEl: state.overlayEl,
                menuPopupEl: state.menuPopupEl,
                overlay,
                closeWhenDocumentBlurs,
                closeWhenEscapeKeyIsPressed,
                closeWhenMenuButtonIsTabbed,
                closeWhenClickingOutside,
                overlayElement,
                cursorKeys,
                focusElementOnClose,
                focusSentinelBeforeEl: state.focusSentinelBeforeEl,
                focusSentinelAfterEl: state.focusSentinelAfterEl,
                ignoreMenuPopupWhenTabbing,
                upperStackRemovedByFocusOut: false,
                detectIfMenuButtonObscured: false,
                queueRemoval: false,
                mountedPopupsSafeList: state.mountedPopupsSafeList,
                timeouts: state.timeouts,
            });
            onOpen && onOpen(open, { uniqueId: state.uniqueId, dismissStack });
            runToggleScrollbar(state, open);
            activateLastFocusSentinel(state);
        }
        else {
            setTargetAriaExpandFalse(state);
            // TODO?:
            globalState.closedByEvents = false;
            removeLocalEvents(state);
            removeMenuPopupEl(state);
            removeDismissStack(state.uniqueId);
            removeGlobalEvents();
            removeEventsOnActiveMountedPopup();
            onOpen && onOpen(open, { uniqueId: state.uniqueId, dismissStack });
            if (!props.animation) {
                runToggleScrollbar(state, open);
            }
        }
    }, { defer: initDefer }));
    onCleanup(() => {
        if (isServer)
            return;
        removeLocalEvents(state, { isCleanup: true });
        removeMenuPopupEl(state);
        removeDismissStack(state.uniqueId);
        removeGlobalEvents();
    });
    function renderOverlay() {
        if (typeof props.overlayElement === "object" &&
            props.overlayElement.element) {
            return props.overlayElement.element;
        }
        return (<div class={typeof props.overlayElement === "object"
                ? props.overlayElement.class
                : undefined} classList={typeof props.overlayElement === "object"
                ? props.overlayElement.classList || {}
                : {}} role="presentation" onClick={state.onClickOverlayRef} onMouseDown={onMouseDownOverlay} onMouseUp={onMouseUpOverlay} ref={state.refOverlayCb}></div>);
    }
    function render(children) {
        return (<div id={state.id} class={props.class} classList={props.classList || {}} onFocusIn={state.onFocusInContainerRef} onFocusOut={state.onFocusOutContainerRef} ref={state.refContainerCb}>
        <div tabindex={props.open() ? "0" : "-1"} onFocus={(e) => {
                onFocusSentinel(state, "before", e.relatedTarget);
            }} style="position: fixed; top: 0; left: 0; outline: none; pointer-events: none; width: 0; height: 0;" aria-hidden="true" ref={state.focusSentinelBeforeEl}></div>
        {children}
        <div tabindex={props.open() && state.hasFocusSentinels ? "0" : "-1"} onFocus={() => {
                onFocusSentinel(state, "after");
            }} style="position: fixed; top: 0; left: 0; outline: none; pointer-events: none; width: 0; height: 0;" aria-hidden="true" ref={state.focusSentinelAfterEl}></div>
      </div>);
    }
    if (show)
        return render(props.children);
    // basically <Show>
    // why custom Show??
    let strictEqual = false;
    const condition = createMemo(() => props.open(), false, {
        equals: (a, b) => (strictEqual ? a === b : !a === !b),
    });
    const finalRender = createMemo(() => {
        const c = condition();
        if (c) {
            const child = props.children;
            const fn = typeof child === "function" && child.length > 0;
            strictEqual = fn;
            return fn ? (untrack(() => child(c))) : mount ? (<CustomPortal mount={getMountNode()} overlayChildren={overlayElement ? renderOverlay() : null}>
          {render(child)}
        </CustomPortal>) : (render(child));
        }
    });
    if (props.animation) {
        return (<Transition {...props.animation} name={props.animation.name} enterClass={props.animation.enterClass} enterActiveClass={props.animation.enterActiveClass} enterToClass={props.animation.enterToClass} exitClass={props.animation.exitClass} exitActiveClass={props.animation.exitActiveClass} exitToClass={props.animation.exitToClass} appear={props.animation.appear} overlay={typeof props.overlayElement === "object"
                ? props.overlayElement.animation
                : undefined} state={state}>
        {finalRender()}
      </Transition>);
    }
    return finalRender;
};
export { getNextTabbableElement };
export default Dismiss;
