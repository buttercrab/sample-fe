"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine,
  parse: () => parse,
  props: () => props,
  splitProps: () => splitProps
});
module.exports = __toCommonJS(src_exports);

// src/timer.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("timer").parts(
  "root",
  "item",
  "itemValue",
  "itemLabel",
  "actionTrigger",
  "separator"
);
var parts = anatomy.build();

// src/timer.connect.ts
var validActions = /* @__PURE__ */ new Set(["start", "pause", "resume", "reset", "restart"]);
function connect(state, send, normalize) {
  const running = state.matches("running");
  const paused = state.matches("paused");
  const time = state.context.time;
  const formattedTime = state.context.formattedTime;
  const progressPercent = state.context.progressPercent;
  return {
    running,
    paused,
    time,
    formattedTime,
    progressPercent,
    start() {
      send("START");
    },
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    reset() {
      send("RESET");
    },
    restart() {
      send("RESTART");
    },
    getRootProps() {
      return normalize.element({
        role: "timer",
        ...parts.root.attrs
      });
    },
    getItemProps(props2) {
      const value = time[props2.type];
      return normalize.element({
        ...parts.item.attrs,
        "data-type": props2.type,
        style: {
          "--value": value
        }
      });
    },
    getItemLabelProps(props2) {
      return normalize.element({
        ...parts.itemLabel.attrs,
        "data-type": props2.type
      });
    },
    getItemValueProps(props2) {
      return normalize.element({
        ...parts.itemValue.attrs,
        "data-type": props2.type
      });
    },
    getSeparatorProps() {
      return normalize.element({
        ...parts.separator.attrs
      });
    },
    getActionTriggerProps(props2) {
      if (!validActions.has(props2.action)) {
        throw new Error(`Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(", ")}`);
      }
      return normalize.button({
        ...parts.actionTrigger.attrs,
        onClick() {
          send(props2.action.toUpperCase());
        }
      });
    }
  };
}

// src/timer.machine.ts
var import_core = require("@zag-js/core");
var import_utils = require("@zag-js/utils");
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "timer",
      initial: ctx.autoStart ? "running" : "idle",
      context: {
        interval: 250,
        ...ctx,
        currentMs: ctx.startMs ?? 0
      },
      on: {
        RESTART: {
          target: "running",
          actions: "resetTime"
        }
      },
      computed: {
        time: (ctx2) => msToTime(ctx2.currentMs),
        formattedTime: (ctx2) => formatTime(ctx2.time),
        progressPercent: (ctx2) => {
          const targetMs = ctx2.targetMs;
          if (targetMs == null) return 0;
          return toPercent(ctx2.currentMs, ctx2.startMs ?? 0, targetMs);
        }
      },
      states: {
        idle: {
          on: {
            START: "running",
            RESET: { actions: "resetTime" }
          }
        },
        running: {
          every: {
            TICK_INTERVAL: ["sendTickEvent"]
          },
          on: {
            PAUSE: "paused",
            TICK: [
              {
                target: "idle",
                guard: "hasReachedTarget",
                actions: ["invokeOnComplete"]
              },
              {
                actions: ["updateTime", "invokeOnTick"]
              }
            ],
            RESET: { actions: "resetTime" }
          }
        },
        paused: {
          on: {
            RESUME: "running",
            RESET: {
              target: "idle",
              actions: "resetTime"
            }
          }
        }
      }
    },
    {
      delays: {
        TICK_INTERVAL: (ctx2) => ctx2.interval
      },
      actions: {
        updateTime(ctx2) {
          const sign = ctx2.countdown ? -1 : 1;
          ctx2.currentMs = ctx2.currentMs + sign * ctx2.interval;
        },
        sendTickEvent(_ctx, _evt, { send }) {
          send({ type: "TICK" });
        },
        resetTime(ctx2) {
          let targetMs = ctx2.targetMs;
          if (targetMs == null && ctx2.countdown) targetMs = 0;
          ctx2.currentMs = ctx2.startMs ?? 0;
        },
        invokeOnTick(ctx2) {
          ctx2.onTick?.({
            value: ctx2.currentMs,
            time: ctx2.time,
            formattedTime: ctx2.formattedTime
          });
        },
        invokeOnComplete(ctx2) {
          ctx2.onComplete?.();
        }
      },
      guards: {
        hasReachedTarget: (ctx2) => {
          let targetMs = ctx2.targetMs;
          if (targetMs == null && ctx2.countdown) targetMs = 0;
          if (targetMs == null) return false;
          return ctx2.currentMs === targetMs;
        }
      }
    }
  );
}
function msToTime(ms) {
  const milliseconds = ms % 1e3;
  const seconds = Math.floor(ms / 1e3) % 60;
  const minutes = Math.floor(ms / (1e3 * 60)) % 60;
  const hours = Math.floor(ms / (1e3 * 60 * 60)) % 24;
  const days = Math.floor(ms / (1e3 * 60 * 60 * 24));
  return {
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  };
}
function toPercent(value, minValue, maxValue) {
  return (value - minValue) / (maxValue - minValue);
}
function padStart(num, size = 2) {
  return num.toString().padStart(size, "0");
}
function formatTime(time) {
  const { days, hours, minutes, seconds } = time;
  return {
    days: padStart(days),
    hours: padStart(hours),
    minutes: padStart(minutes),
    seconds: padStart(seconds),
    milliseconds: time.milliseconds.toString()
  };
}

// src/timer.parse.ts
var import_utils2 = require("@zag-js/utils");
var segments = /* @__PURE__ */ new Set(["days", "hours", "minutes", "seconds"]);
function isTimeSegment(date) {
  return (0, import_utils2.isObject)(date) && Object.keys(date).some((key) => segments.has(key));
}
function parse(date) {
  if (typeof date === "string") {
    return new Date(date).getTime();
  }
  if (isTimeSegment(date)) {
    const { days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0 } = date;
    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;
    return value + milliseconds;
  }
  throw new Error("Invalid date");
}

// src/timer.props.ts
var import_types = require("@zag-js/types");
var import_utils3 = require("@zag-js/utils");
var props = (0, import_types.createProps)()([
  "autoStart",
  "countdown",
  "getRootNode",
  "id",
  "interval",
  "onComplete",
  "onTick",
  "startMs",
  "targetMs"
]);
var splitProps = (0, import_utils3.createSplitProps)(props);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine,
  parse,
  props,
  splitProps
});
//# sourceMappingURL=index.js.map