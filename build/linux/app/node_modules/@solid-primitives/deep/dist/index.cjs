'use strict';

var solidJs = require('solid-js');
var store = require('solid-js/store');
var memo = require('@solid-primitives/memo');
var web = require('solid-js/web');

// src/track-deep.ts
function trackDeep(store) {
  traverse(store, /* @__PURE__ */ new Set());
  return store;
}
function traverse(value, seen) {
  let isArray;
  let proto;
  if (value != null && typeof value === "object" && !seen.has(value) && ((isArray = Array.isArray(value)) || value[solidJs.$PROXY] || !(proto = Object.getPrototypeOf(value)) || proto === Object.prototype)) {
    seen.add(value);
    for (const child of isArray ? value : Object.values(value))
      traverse(child, seen);
  }
}
exports.deepTrack = trackDeep;
var EQUALS_FALSE = { equals: false };
var TrackStoreCache = /* @__PURE__ */ new WeakMap();
var TrackVersion = 0;
function getTrackStoreNode(node) {
  let track = TrackStoreCache.get(node);
  if (!track) {
    solidJs.createRoot(() => {
      const unwrapped = store.unwrap(node);
      let is_reading = false;
      let is_stale = true;
      let version = 0;
      const [signal, trigger] = solidJs.createSignal(void 0, EQUALS_FALSE);
      const memo = solidJs.createMemo(
        () => {
          if (is_reading) {
            node[solidJs.$TRACK];
            for (const [key, child] of Object.entries(unwrapped)) {
              let childNode;
              if (child != null && typeof child === "object" && ((childNode = child[solidJs.$PROXY]) || solidJs.$TRACK in (childNode = solidJs.untrack(() => node[key])))) {
                getTrackStoreNode(childNode)?.();
              }
            }
          } else {
            signal();
            is_stale = true;
          }
        },
        void 0,
        EQUALS_FALSE
      );
      track = () => {
        is_reading = true;
        if (is_stale) {
          trigger();
          is_stale = false;
        }
        const already_tracked = version === TrackVersion;
        version = TrackVersion;
        already_tracked || memo();
        is_reading = false;
      };
      TrackStoreCache.set(node, track);
    });
  }
  return track;
}
function trackStore(store) {
  TrackVersion++;
  solidJs.$TRACK in store && getTrackStoreNode(store)?.();
  return store;
}
function* entries(obj) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      yield [i, obj[i]];
    }
  } else {
    yield* Object.entries(obj)[Symbol.iterator]();
  }
}
var StoreNodeChildrenCache = /* @__PURE__ */ new WeakMap();
function getStoreNodechildren(node) {
  let signal = StoreNodeChildrenCache.get(node);
  if (!signal) {
    const unwrapped = store.unwrap(node), isArray = Array.isArray(unwrapped);
    signal = solidJs.createRoot(
      () => memo.createLazyMemo(() => {
        node[solidJs.$TRACK];
        const children = isArray ? [] : {};
        for (const [key, child] of entries(unwrapped)) {
          let childNode;
          if (child != null && typeof child === "object" && ((childNode = child[solidJs.$PROXY]) || (childNode = solidJs.untrack(() => node[key])) && solidJs.$TRACK in childNode)) {
            children[key] = childNode;
          }
        }
        return children;
      })
    );
    StoreNodeChildrenCache.set(node, signal);
  }
  return signal();
}
var CurrentUpdates;
var SeenNodes;
function newCacheNode(children) {
  const record = { ...children };
  for (const [key, node] of entries(children)) {
    if (SeenNodes.has(node))
      continue;
    SeenNodes.add(node);
    record[key] = newCacheNode(getStoreNodechildren(node));
  }
  return { children, record };
}
function compareStoreWithCache(node, parent, key, path) {
  if (SeenNodes.has(node))
    return;
  SeenNodes.add(node);
  const cacheNode = parent[key], children = getStoreNodechildren(node);
  if (cacheNode && children === cacheNode.children) {
    for (const [key2, child] of entries(children)) {
      compareStoreWithCache(child, cacheNode.record, key2, [...path, key2]);
    }
  } else {
    parent[key] = newCacheNode(children);
    CurrentUpdates.push({ path, value: node });
  }
}
function captureStoreUpdates(store) {
  if (web.isServer || !(solidJs.$TRACK in store)) {
    if (web.isDev) {
      console.warn("createStoreDelta expects a store, got", store);
    }
    let init = true;
    return () => init ? (init = false, [{ path: [], value: store }]) : [];
  }
  const cache = {};
  return () => {
    CurrentUpdates = [];
    SeenNodes = /* @__PURE__ */ new WeakSet();
    compareStoreWithCache(store, cache, "root", []);
    return CurrentUpdates;
  };
}

exports.captureStoreUpdates = captureStoreUpdates;
exports.trackDeep = trackDeep;
exports.trackStore = trackStore;
