import { getOwner, onCleanup, untrack, createRoot, createComputed, createMemo, DEV, createSignal, on, runWithOwner } from 'solid-js';
import { isServer } from 'solid-js/web';
import { debounce, throttle } from '@solid-primitives/scheduled';
import { EQUALS_FALSE_OPTIONS, noop } from '@solid-primitives/utils';

// src/index.ts
var callbackWith = (fn, v) => fn.length > 0 ? () => fn(untrack(v)) : fn;
function createPureReaction(onInvalidate, options) {
  if (isServer) {
    return () => void 0;
  }
  const owner = getOwner();
  const disposers = /* @__PURE__ */ new Set();
  let trackers = 0;
  let disposed = false;
  onCleanup(() => {
    for (const fn of disposers)
      fn();
    disposers.clear();
    disposed = true;
  });
  return (tracking) => {
    if (disposed) {
      untrack(tracking);
      return;
    }
    trackers++;
    createRoot((dispose) => {
      disposers.add(dispose);
      let init = true;
      createComputed(() => {
        if (init) {
          init = false;
          return tracking();
        }
        if (--trackers === 0)
          untrack(onInvalidate);
        dispose();
        disposers.delete(dispose);
      }, options);
    }, owner);
  };
}
function createLatest(sources, options) {
  let index = 0;
  const memos = sources.map(
    (source, i) => createMemo(
      () => (index = i, source()),
      void 0,
      DEV ? { name: i + 1 + ". source", equals: false } : EQUALS_FALSE_OPTIONS
    )
  );
  return createMemo(() => memos.map((m) => m())[index], void 0, options);
}
function createLatestMany(sources, options) {
  const memos = sources.map((source, i) => {
    const obj = { dirty: true, get: null };
    obj.get = createMemo(
      () => (obj.dirty = true, source()),
      void 0,
      DEV ? { name: i + 1 + ". source", equals: false } : EQUALS_FALSE_OPTIONS
    );
    return obj;
  });
  return createLazyMemo(
    () => memos.reduce((acc, memo) => {
      const v = memo.get();
      if (memo.dirty) {
        memo.dirty = false;
        acc.push(v);
      }
      return acc;
    }, []),
    void 0,
    options
  );
}
function createWritableMemo(fn, value, options) {
  let combined = () => value;
  const [signal, setSignal] = createSignal(value, EQUALS_FALSE_OPTIONS), memo = createMemo(
    callbackWith(fn, () => combined()),
    value
  );
  return [
    combined = createLatest([signal, memo], options),
    (setter) => setSignal(
      () => typeof setter === "function" ? setter(untrack(combined)) : setter
    )
  ];
}
function createDebouncedMemo(fn, timeoutMs, value, options) {
  const memo = createMemo(() => fn(value), void 0, options);
  if (isServer) {
    return memo;
  }
  const [signal, setSignal] = createSignal(untrack(memo));
  const updateSignal = debounce(() => value = setSignal(memo), timeoutMs);
  createComputed(on(memo, updateSignal, { defer: true }));
  return signal;
}
function createDebouncedMemoOn(deps, fn, timeoutMs, value, options) {
  if (isServer) {
    return createMemo(on(deps, fn), value);
  }
  let init = true;
  const [signal, setSignal] = createSignal(
    (() => {
      let v;
      createComputed(
        on(deps, (input, prevInput) => {
          if (init) {
            v = fn(input, prevInput, value);
            init = false;
          } else
            updateSignal(input, prevInput);
        })
      );
      return v;
    })(),
    options
  );
  const updateSignal = debounce((input, prevInput) => {
    setSignal(() => fn(input, prevInput, signal()));
  }, timeoutMs);
  return signal;
}
function createThrottledMemo(fn, timeoutMs, value, options) {
  if (isServer) {
    return createMemo(fn);
  }
  let onInvalidate = noop;
  const track = createPureReaction(() => onInvalidate());
  const [state, setState] = createSignal(
    (() => {
      let v;
      track(() => v = fn(value));
      return v;
    })(),
    options
  );
  onInvalidate = throttle(() => track(() => setState(fn)), timeoutMs);
  return state;
}
function createAsyncMemo(calc, options = {}) {
  if (isServer) {
    return () => options.value;
  }
  const [state, setState] = createSignal(options.value, options);
  const order = [];
  createComputed(async () => {
    const value = calc(untrack(state));
    if (value instanceof Promise) {
      order.push(value);
      value.then((r) => order.includes(value) && setState(() => r));
      value.finally(() => {
        const index = order.indexOf(value);
        order.splice(0, index + 1);
      });
    } else
      setState(() => value);
  }, void 0, options);
  return state;
}
function createLazyMemo(calc, value, options) {
  if (isServer) {
    let calculated = false;
    return () => {
      if (!calculated) {
        calculated = true;
        value = calc(value);
      }
      return value;
    };
  }
  let isReading = false, isStale = true;
  const [track, trigger] = createSignal(void 0, EQUALS_FALSE_OPTIONS), memo = createMemo(
    (p) => isReading ? calc(p) : (isStale = !track(), p),
    value,
    DEV ? { name: options?.name, equals: false } : EQUALS_FALSE_OPTIONS
  );
  return () => {
    isReading = true;
    if (isStale)
      isStale = trigger();
    const v = memo();
    isReading = false;
    return v;
  };
}
function createMemoCache(...args) {
  const cache = /* @__PURE__ */ new Map();
  const owner = getOwner();
  const key = typeof args[1] === "function" ? args[0] : void 0, calc = typeof args[1] === "function" ? args[1] : args[0], options = typeof args[1] === "object" ? args[1] : typeof args[2] === "object" ? args[2] : {};
  const run = (key2) => {
    if (cache.has(key2))
      return cache.get(key2)();
    const memo = runWithOwner(
      owner,
      () => createLazyMemo((prev) => calc(key2, prev), void 0, options)
    );
    if (options.size === void 0 || cache.size < options.size)
      cache.set(key2, memo);
    return memo();
  };
  return key ? () => run(key()) : run;
}
function createReducer(dispatcher, initialValue, options) {
  const [state, setState] = createSignal(initialValue, options);
  return [state, (...args) => void setState((state2) => dispatcher(state2, ...args))];
}

export { createAsyncMemo, createDebouncedMemo, createDebouncedMemoOn, createLatest, createLatestMany, createLazyMemo, createMemoCache, createPureReaction, createReducer, createThrottledMemo, createWritableMemo };
