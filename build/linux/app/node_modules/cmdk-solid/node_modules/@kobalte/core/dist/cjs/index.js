/**
 * MIT License
 *
 * Copyright (c) 2022 Fabien Marie-Louise
 *
 * License can be found in LICENSE.md,
 * also available at https://github.com/kobaltedev/kobalte/blob/main/LICENSE.md
 *
 * This codebase contains modified portions of code from multiple sources.
 * Credits to their original authors.
 *
 * A list of all sources and licenses can be found in NOTICE.txt,
 * also available at https://github.com/kobaltedev/kobalte/blob/main/NOTICE.txt
 */

'use strict';

var utils = require('@kobalte/utils');
var store = require('solid-js/store');
var web = require('solid-js/web');
var solidJs = require('solid-js');
var createPreventScroll = require('solid-prevent-scroll');
var date = require('@internationalized/date');
var dom = require('@floating-ui/dom');
var number = require('@internationalized/number');

const ColorModeContext = solidJs.createContext();
function useColorMode() {
  const context = solidJs.useContext(ColorModeContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useColorMode` must be used within a `ColorModeProvider`");
  }
  return context;
}
function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return solidJs.createMemo(() => colorMode() === "dark" ? dark : light);
}

const COLOR_MODE_STORAGE_KEY = "kb-color-mode";
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get: fallback => {
      if (web.isServer) {
        return fallback;
      }
      let value;
      try {
        value = localStorage.getItem(key);
      } catch (_) {}
      return value ?? fallback;
    },
    set: value => {
      try {
        localStorage.setItem(key, value);
      } catch (e) {}
    }
  };
}
const localStorageManager = createLocalStorageManager(COLOR_MODE_STORAGE_KEY);
function parseCookie(cookie, key) {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match?.[2];
}
function createCookieStorageManager(key, cookie) {
  return {
    ssr: !!cookie,
    type: "cookie",
    get: fallback => {
      if (cookie) {
        return parseCookie(cookie, key) ?? fallback;
      }
      if (web.isServer) {
        return fallback;
      }
      return parseCookie(document.cookie, key) ?? fallback;
    },
    set: value => {
      document.cookie = `${key}=${value}; max-age=31536000; path=/`;
    }
  };
}
const cookieStorageManager = createCookieStorageManager(COLOR_MODE_STORAGE_KEY);
function cookieStorageManagerSSR(cookie) {
  return createCookieStorageManager(COLOR_MODE_STORAGE_KEY, cookie);
}

const FALLBACK_COLOR_MODE_VALUE = "system";
function query() {
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function preventTransition() {
  const css = document.createElement("style");
  css.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"));
  document.head.appendChild(css);
  return () => {
    (() => window.getComputedStyle(document.body))();
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css);
      });
    });
  };
}
function setColorModeDataset(value, shouldPreventTransition = true) {
  const cleanup = shouldPreventTransition ? preventTransition() : undefined;
  document.documentElement.dataset.kbTheme = value;
  document.documentElement.style.colorScheme = value;
  cleanup?.();
}
function getSystemColorMode(fallback) {
  const isDark = query().matches ?? fallback === "dark";
  return isDark ? "dark" : "light";
}
function getInitialColorMode(manager) {
  const fallback = "light";
  const initialColorMode = manager.get(fallback) ?? fallback;
  if (initialColorMode === "system") {
    return web.isServer ? fallback : getSystemColorMode();
  }
  return initialColorMode;
}
function addColorModeListener(fn) {
  const mql = query();
  const listener = e => {
    fn(e.matches ? "dark" : "light");
  };
  mql.addEventListener("change", listener);
  return () => {
    mql.removeEventListener("change", listener);
  };
}

function ColorModeProvider(props) {
  const fallbackColorMode = () => props.initialColorMode ?? FALLBACK_COLOR_MODE_VALUE;
  const colorModeManager = () => props.storageManager ?? localStorageManager;
  let colorModeListenerCleanupFn;
  const [colorMode, rawSetColorMode] = solidJs.createSignal(getInitialColorMode(colorModeManager()));
  const applyColorMode = value => {
    rawSetColorMode(value);
    setColorModeDataset(value, props.disableTransitionOnChange);
  };
  const setColorMode = value => {
    if (colorModeListenerCleanupFn) {
      colorModeListenerCleanupFn();
      colorModeListenerCleanupFn = undefined;
    }
    const isSystem = value === "system";
    if (isSystem) {
      colorModeListenerCleanupFn = addColorModeListener(applyColorMode);
    }
    applyColorMode(isSystem ? getSystemColorMode() : value);
    colorModeManager().set(value);
  };
  const toggleColorMode = () => {
    setColorMode(colorMode() === "dark" ? "light" : "dark");
  };
  solidJs.createEffect(() => {
    setColorMode(colorModeManager().get() ?? fallbackColorMode());
  });
  solidJs.onCleanup(() => {
    colorModeListenerCleanupFn?.();
  });
  const context = {
    colorMode,
    setColorMode,
    toggleColorMode
  };
  return web.createComponent(ColorModeContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

const _tmpl$$i = /*#__PURE__*/web.template(`<script id="kb-color-mode-script">`);
const VALID_VALUES = new Set(["light", "dark", "system"]);
function normalize(initialColorMode) {
  if (!VALID_VALUES.has(initialColorMode)) {
    return FALLBACK_COLOR_MODE_VALUE;
  }
  return initialColorMode;
}
function ColorModeScript(props) {
  const mergedProps = solidJs.mergeProps({
    initialColorMode: FALLBACK_COLOR_MODE_VALUE,
    storageType: "localStorage",
    storageKey: COLOR_MODE_STORAGE_KEY
  }, props);
  const scriptSrc = solidJs.createMemo(() => {
    const init = normalize(mergedProps.initialColorMode);
    const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,s=e==="dark";return d.style.colorScheme=e,d.dataset.kbTheme=e,o},u=a,h="${init}",r="${mergedProps.storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();`;
    const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,i=r==="dark";return o.style.colorScheme=r,o.dataset.kbTheme=r,c},n=a,m="${init}",e="${mergedProps.storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();`;
    const fn = mergedProps.storageType === "cookie" ? cookieScript : localStorageScript;
    return `!${fn}`.trim();
  });
  return (() => {
    const _el$ = _tmpl$$i();
    web.effect(_p$ => {
      const _v$ = mergedProps.nonce,
        _v$2 = scriptSrc();
      _v$ !== _p$._v$ && web.setAttribute(_el$, "nonce", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && (_el$.innerHTML = _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });
    return _el$;
  })();
}

function buildNodes(params) {
  let index = params.startIndex ?? 0;
  const level = params.startLevel ?? 0;
  const nodes = [];
  const getKey = data => {
    if (data == null) {
      return "";
    }
    const _getKey = params.getKey ?? "key";
    const dataKey = utils.isString(_getKey) ? data[_getKey] : _getKey(data);
    return dataKey != null ? String(dataKey) : "";
  };
  const getTextValue = data => {
    if (data == null) {
      return "";
    }
    const _getTextValue = params.getTextValue ?? "textValue";
    const dataTextValue = utils.isString(_getTextValue) ? data[_getTextValue] : _getTextValue(data);
    return dataTextValue != null ? String(dataTextValue) : "";
  };
  const getDisabled = data => {
    if (data == null) {
      return false;
    }
    const _getDisabled = params.getDisabled ?? "disabled";
    return (utils.isString(_getDisabled) ? data[_getDisabled] : _getDisabled(data)) ?? false;
  };
  const getSectionChildren = data => {
    if (data == null) {
      return undefined;
    }
    if (utils.isString(params.getSectionChildren)) {
      return data[params.getSectionChildren];
    }
    return params.getSectionChildren?.(data);
  };
  for (const data of params.dataSource) {
    if (utils.isString(data) || utils.isNumber(data)) {
      nodes.push({
        type: "item",
        rawValue: data,
        key: String(data),
        textValue: String(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
      continue;
    }
    if (getSectionChildren(data) != null) {
      nodes.push({
        type: "section",
        rawValue: data,
        key: "",
        textValue: "",
        disabled: false,
        level: level,
        index: index
      });
      index++;
      const sectionChildren = getSectionChildren(data) ?? [];
      if (sectionChildren.length > 0) {
        const childNodes = buildNodes({
          dataSource: sectionChildren,
          getKey: params.getKey,
          getTextValue: params.getTextValue,
          getDisabled: params.getDisabled,
          getSectionChildren: params.getSectionChildren,
          startIndex: index,
          startLevel: level + 1
        });
        nodes.push(...childNodes);
        index += childNodes.length;
      }
    } else {
      nodes.push({
        type: "item",
        rawValue: data,
        key: getKey(data),
        textValue: getTextValue(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
    }
  }
  return nodes;
}

function createCollection(props, deps = []) {
  const initialNodes = buildNodes({
    dataSource: utils.access(props.dataSource),
    getKey: utils.access(props.getKey),
    getTextValue: utils.access(props.getTextValue),
    getDisabled: utils.access(props.getDisabled),
    getSectionChildren: utils.access(props.getSectionChildren)
  });
  const [collection, setCollection] = solidJs.createSignal(props.factory(initialNodes));
  solidJs.createEffect(solidJs.on([() => utils.access(props.dataSource), () => utils.access(props.getKey), () => utils.access(props.getTextValue), () => utils.access(props.getDisabled), () => utils.access(props.getSectionChildren), () => props.factory, ...deps], ([dataSource, getKey, getTextValue, getDisabled, getSectionChildren, factory]) => {
    const nodes = buildNodes({
      dataSource,
      getKey,
      getTextValue,
      getDisabled,
      getSectionChildren
    });
    setCollection(() => factory(nodes));
  }, {
    defer: true
  }));
  return collection;
}

const cache$1 = new WeakMap();
function getItemCount(collection) {
  let count = cache$1.get(collection);
  if (count != null) {
    return count;
  }
  count = 0;
  for (const item of collection) {
    if (item.type === "item") {
      count++;
    }
  }
  cache$1.set(collection, count);
  return count;
}

function createControllableSignal(props) {
  const [_value, _setValue] = solidJs.createSignal(props.defaultValue?.());
  const isControlled = solidJs.createMemo(() => props.value?.() !== undefined);
  const value = solidJs.createMemo(() => isControlled() ? props.value?.() : _value());
  const setValue = next => {
    solidJs.untrack(() => {
      const nextValue = utils.accessWith(next, value());
      if (!Object.is(nextValue, value())) {
        if (!isControlled()) {
          _setValue(nextValue);
        }
        props.onChange?.(nextValue);
      }
      return nextValue;
    });
  };
  return [value, setValue];
}
function createControllableBooleanSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? false;
  return [value, setValue];
}
function createControllableArraySignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? [];
  return [value, setValue];
}
function createControllableSetSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Set();
  return [value, setValue];
}

function createDisclosureState(props = {}) {
  const [isOpen, setIsOpen] = createControllableBooleanSignal({
    value: () => utils.access(props.open),
    defaultValue: () => !!utils.access(props.defaultOpen),
    onChange: value => props.onOpenChange?.(value)
  });
  const open = () => {
    setIsOpen(true);
  };
  const close = () => {
    setIsOpen(false);
  };
  const toggle = () => {
    isOpen() ? close() : open();
  };
  return {
    isOpen,
    setIsOpen,
    open,
    close,
    toggle
  };
}

function createEscapeKeyDown(props) {
  const handleKeyDown = event => {
    if (event.key === utils.EventKey.Escape) {
      props.onEscapeKeyDown?.(event);
    }
  };
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    if (utils.access(props.isDisabled)) {
      return;
    }
    const document = props.ownerDocument?.() ?? utils.getDocument();
    document.addEventListener("keydown", handleKeyDown);
    solidJs.onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
  });
}

const DATA_TOP_LAYER_ATTR = "data-kb-top-layer";
let originalBodyPointerEvents;
let hasDisabledBodyPointerEvents = false;
const layers = [];
function indexOf(node) {
  return layers.findIndex(layer => layer.node === node);
}
function find(node) {
  return layers[indexOf(node)];
}
function isTopMostLayer(node) {
  return layers[layers.length - 1].node === node;
}
function getPointerBlockingLayers() {
  return layers.filter(layer => layer.isPointerBlocking);
}
function getTopMostPointerBlockingLayer() {
  return [...getPointerBlockingLayers()].slice(-1)[0];
}
function hasPointerBlockingLayer() {
  return getPointerBlockingLayers().length > 0;
}
function isBelowPointerBlockingLayer(node) {
  const highestBlockingIndex = indexOf(getTopMostPointerBlockingLayer()?.node);
  return indexOf(node) < highestBlockingIndex;
}
function addLayer(layer) {
  layers.push(layer);
}
function removeLayer(node) {
  const index = indexOf(node);
  if (index < 0) {
    return;
  }
  layers.splice(index, 1);
}
function assignPointerEventToLayers() {
  for (const {
    node
  } of layers) {
    node.style.pointerEvents = isBelowPointerBlockingLayer(node) ? "none" : "auto";
  }
}
function disableBodyPointerEvents(node) {
  if (hasPointerBlockingLayer() && !hasDisabledBodyPointerEvents) {
    const ownerDocument = utils.getDocument(node);
    originalBodyPointerEvents = document.body.style.pointerEvents;
    ownerDocument.body.style.pointerEvents = "none";
    hasDisabledBodyPointerEvents = true;
  }
}
function restoreBodyPointerEvents(node) {
  if (hasPointerBlockingLayer()) {
    return;
  }
  const ownerDocument = utils.getDocument(node);
  ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
  if (ownerDocument.body.style.length === 0) {
    ownerDocument.body.removeAttribute("style");
  }
  hasDisabledBodyPointerEvents = false;
}
const layerStack = {
  layers,
  isTopMostLayer,
  hasPointerBlockingLayer,
  isBelowPointerBlockingLayer,
  addLayer,
  removeLayer,
  indexOf,
  find,
  assignPointerEventToLayers,
  disableBodyPointerEvents,
  restoreBodyPointerEvents
};

const AUTOFOCUS_ON_MOUNT_EVENT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT_EVENT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const focusScopeStack = {
  stack: [],
  active() {
    return this.stack[0];
  },
  add(scope) {
    if (scope !== this.active()) {
      this.active()?.pause();
    }
    this.stack = utils.removeItemFromArray(this.stack, scope);
    this.stack.unshift(scope);
  },
  remove(scope) {
    this.stack = utils.removeItemFromArray(this.stack, scope);
    this.active()?.resume();
  }
};
function createFocusScope(props, ref) {
  const [isPaused, setIsPaused] = solidJs.createSignal(false);
  const focusScope = {
    pause() {
      setIsPaused(true);
    },
    resume() {
      setIsPaused(false);
    }
  };
  let lastFocusedElement = null;
  const onMountAutoFocus = e => props.onMountAutoFocus?.(e);
  const onUnmountAutoFocus = e => props.onUnmountAutoFocus?.(e);
  const ownerDocument = () => utils.getDocument(ref());
  const createSentinel = () => {
    const element = ownerDocument().createElement("span");
    element.setAttribute("data-focus-trap", "");
    element.tabIndex = 0;
    Object.assign(element.style, utils.visuallyHiddenStyles);
    return element;
  };
  const tabbables = () => {
    const container = ref();
    if (!container) {
      return [];
    }
    return utils.getAllTabbableIn(container, true).filter(el => !el.hasAttribute("data-focus-trap"));
  };
  const firstTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[0] : null;
  };
  const lastTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[items.length - 1] : null;
  };
  const shouldPreventUnmountAutoFocus = () => {
    const container = ref();
    if (!container) {
      return false;
    }
    const activeElement = utils.getActiveElement(container);
    if (!activeElement) {
      return false;
    }
    if (utils.contains(container, activeElement)) {
      return false;
    }
    return utils.isFocusable(activeElement);
  };
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    const container = ref();
    if (!container) {
      return;
    }
    focusScopeStack.add(focusScope);
    const previouslyFocusedElement = utils.getActiveElement(container);
    const hasFocusedCandidate = utils.contains(container, previouslyFocusedElement);
    if (!hasFocusedCandidate) {
      const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT_EVENT, EVENT_OPTIONS);
      container.addEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      container.dispatchEvent(mountEvent);
      if (!mountEvent.defaultPrevented) {
        setTimeout(() => {
          utils.focusWithoutScrolling(firstTabbable());
          if (utils.getActiveElement(container) === previouslyFocusedElement) {
            utils.focusWithoutScrolling(container);
          }
        }, 0);
      }
    }
    solidJs.onCleanup(() => {
      container.removeEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      setTimeout(() => {
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT_EVENT, EVENT_OPTIONS);
        if (shouldPreventUnmountAutoFocus()) {
          unmountEvent.preventDefault();
        }
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        if (!unmountEvent.defaultPrevented) {
          utils.focusWithoutScrolling(previouslyFocusedElement ?? ownerDocument().body);
        }
        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        focusScopeStack.remove(focusScope);
      }, 0);
    });
  });
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    const container = ref();
    if (!container || !utils.access(props.trapFocus) || isPaused()) {
      return;
    }
    const onFocusIn = event => {
      const target = event.target;
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (utils.contains(container, target)) {
        lastFocusedElement = target;
      } else {
        utils.focusWithoutScrolling(lastFocusedElement);
      }
    };
    const onFocusOut = event => {
      const relatedTarget = event.relatedTarget;
      const target = relatedTarget ?? utils.getActiveElement(container);
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (!utils.contains(container, target)) {
        utils.focusWithoutScrolling(lastFocusedElement);
      }
    };
    ownerDocument().addEventListener("focusin", onFocusIn);
    ownerDocument().addEventListener("focusout", onFocusOut);
    solidJs.onCleanup(() => {
      ownerDocument().removeEventListener("focusin", onFocusIn);
      ownerDocument().removeEventListener("focusout", onFocusOut);
    });
  });
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    const container = ref();
    if (!container || !utils.access(props.trapFocus) || isPaused()) {
      return;
    }
    const startSentinel = createSentinel();
    container.insertAdjacentElement("afterbegin", startSentinel);
    const endSentinel = createSentinel();
    container.insertAdjacentElement("beforeend", endSentinel);
    function onFocus(event) {
      const first = firstTabbable();
      const last = lastTabbable();
      if (event.relatedTarget === first) {
        utils.focusWithoutScrolling(last);
      } else {
        utils.focusWithoutScrolling(first);
      }
    }
    startSentinel.addEventListener("focusin", onFocus);
    endSentinel.addEventListener("focusin", onFocus);
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.previousSibling === endSentinel) {
          endSentinel.remove();
          container.insertAdjacentElement("beforeend", endSentinel);
        }
        if (mutation.nextSibling === startSentinel) {
          startSentinel.remove();
          container.insertAdjacentElement("afterbegin", startSentinel);
        }
      }
    });
    observer.observe(container, {
      childList: true,
      subtree: false
    });
    solidJs.onCleanup(() => {
      startSentinel.removeEventListener("focusin", onFocus);
      endSentinel.removeEventListener("focusin", onFocus);
      startSentinel.remove();
      endSentinel.remove();
      observer.disconnect();
    });
  });
}

function createFormResetListener(element, handler) {
  solidJs.createEffect(solidJs.on(element, element => {
    if (element == null) {
      return;
    }
    const form = getClosestForm(element);
    if (form == null) {
      return;
    }
    form.addEventListener("reset", handler, {
      passive: true
    });
    solidJs.onCleanup(() => {
      form.removeEventListener("reset", handler);
    });
  }));
}
function getClosestForm(element) {
  return isFormElement(element) ? element.form : element.closest("form");
}
function isFormElement(element) {
  return element.matches("textarea, input, select, button");
}

const LIVEREGION_TIMEOUT_DELAY = 7000;
let liveAnnouncer = null;
const DATA_LIVE_ANNOUNCER_ATTR = "data-live-announcer";
function announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
  if (!liveAnnouncer) {
    liveAnnouncer = new LiveAnnouncer();
  }
  liveAnnouncer.announce(message, assertiveness, timeout);
}
function clearAnnouncer(assertiveness) {
  if (liveAnnouncer) {
    liveAnnouncer.clear(assertiveness);
  }
}
function destroyAnnouncer() {
  if (liveAnnouncer) {
    liveAnnouncer.destroy();
    liveAnnouncer = null;
  }
}
class LiveAnnouncer {
  constructor() {
    this.node = document.createElement("div");
    this.node.dataset.liveAnnouncer = "true";
    Object.assign(this.node.style, utils.visuallyHiddenStyles);
    this.assertiveLog = this.createLog("assertive");
    this.node.appendChild(this.assertiveLog);
    this.politeLog = this.createLog("polite");
    this.node.appendChild(this.politeLog);
    document.body.prepend(this.node);
  }
  createLog(ariaLive) {
    const node = document.createElement("div");
    node.setAttribute("role", "log");
    node.setAttribute("aria-live", ariaLive);
    node.setAttribute("aria-relevant", "additions");
    return node;
  }
  destroy() {
    if (!this.node) {
      return;
    }
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
    if (!this.node) {
      return;
    }
    const node = document.createElement("div");
    node.textContent = message;
    if (assertiveness === "assertive") {
      this.assertiveLog.appendChild(node);
    } else {
      this.politeLog.appendChild(node);
    }
    if (message !== "") {
      setTimeout(() => {
        node.remove();
      }, timeout);
    }
  }
  clear(assertiveness) {
    if (!this.node) {
      return;
    }
    if (!assertiveness || assertiveness === "assertive") {
      this.assertiveLog.innerHTML = "";
    }
    if (!assertiveness || assertiveness === "polite") {
      this.politeLog.innerHTML = "";
    }
  }
}

function createHideOutside(props) {
  solidJs.createEffect(() => {
    if (utils.access(props.isDisabled)) {
      return;
    }
    solidJs.onCleanup(ariaHideOutside(utils.access(props.targets), utils.access(props.root)));
  });
}
const refCountMap = new WeakMap();
const observerStack = [];
function ariaHideOutside(targets, root = document.body) {
  const visibleNodes = new Set(targets);
  const hiddenNodes = new Set();
  const walk = root => {
    for (const element of root.querySelectorAll(`[${DATA_LIVE_ANNOUNCER_ATTR}], [${DATA_TOP_LAYER_ATTR}]`)) {
      visibleNodes.add(element);
    }
    const acceptNode = node => {
      if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }
      for (const target of visibleNodes) {
        if (node.contains(target)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });
    const acceptRoot = acceptNode(root);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {
      hide(root);
    }
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node = walker.nextNode();
      while (node != null) {
        hide(node);
        node = walker.nextNode();
      }
    }
  };
  const hide = node => {
    const refCount = refCountMap.get(node) ?? 0;
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  walk(root);
  const observer = new MutationObserver(changes => {
    for (const change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }
      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {
        for (const node of change.removedNodes) {
          if (node instanceof Element) {
            visibleNodes.delete(node);
            hiddenNodes.delete(node);
          }
        }
        for (const node of change.addedNodes) {
          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === "true" || node.dataset.reactAriaTopLayer === "true")) {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            walk(node);
          }
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  const observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (const node of hiddenNodes) {
      const count = refCountMap.get(node);
      if (count == null) {
        return;
      }
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}

const POINTER_DOWN_OUTSIDE_EVENT = "interactOutside.pointerDownOutside";
const FOCUS_OUTSIDE_EVENT = "interactOutside.focusOutside";
function createInteractOutside(props, ref) {
  let pointerDownTimeoutId;
  let clickHandler = utils.noop;
  const ownerDocument = () => utils.getDocument(ref());
  const onPointerDownOutside = e => props.onPointerDownOutside?.(e);
  const onFocusOutside = e => props.onFocusOutside?.(e);
  const onInteractOutside = e => props.onInteractOutside?.(e);
  const isEventOutside = e => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) {
      return false;
    }
    if (target.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
      return false;
    }
    if (!utils.contains(ownerDocument(), target)) {
      return false;
    }
    if (utils.contains(ref(), target)) {
      return false;
    }
    return !props.shouldExcludeElement?.(target);
  };
  const onPointerDown = e => {
    function handler() {
      const container = ref();
      const target = e.target;
      if (!container || !target || !isEventOutside(e)) {
        return;
      }
      const handler = utils.composeEventHandlers([onPointerDownOutside, onInteractOutside]);
      target.addEventListener(POINTER_DOWN_OUTSIDE_EVENT, handler, {
        once: true
      });
      const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: e,
          isContextMenu: e.button === 2 || utils.isCtrlKey(e) && e.button === 0
        }
      });
      target.dispatchEvent(pointerDownOutsideEvent);
    }
    if (e.pointerType === "touch") {
      ownerDocument().removeEventListener("click", handler);
      clickHandler = handler;
      ownerDocument().addEventListener("click", handler, {
        once: true
      });
    } else {
      handler();
    }
  };
  const onFocusIn = e => {
    const container = ref();
    const target = e.target;
    if (!container || !target || !isEventOutside(e)) {
      return;
    }
    const handler = utils.composeEventHandlers([onFocusOutside, onInteractOutside]);
    target.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
      once: true
    });
    const focusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: e,
        isContextMenu: false
      }
    });
    target.dispatchEvent(focusOutsideEvent);
  };
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    if (utils.access(props.isDisabled)) {
      return;
    }
    pointerDownTimeoutId = window.setTimeout(() => {
      ownerDocument().addEventListener("pointerdown", onPointerDown, true);
    }, 0);
    ownerDocument().addEventListener("focusin", onFocusIn, true);
    solidJs.onCleanup(() => {
      window.clearTimeout(pointerDownTimeoutId);
      ownerDocument().removeEventListener("click", clickHandler);
      ownerDocument().removeEventListener("pointerdown", onPointerDown, true);
      ownerDocument().removeEventListener("focusin", onFocusIn, true);
    });
  });
}

function createPresence(present) {
  const [node, setNode] = solidJs.createSignal();
  let styles = {};
  let prevPresent = present();
  let prevAnimationName = "none";
  const [state, send] = createStateMachine(present() ? "mounted" : "unmounted", {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  solidJs.createEffect(solidJs.on(state, state => {
    const currentAnimationName = getAnimationName(styles);
    prevAnimationName = state === "mounted" ? currentAnimationName : "none";
  }));
  solidJs.createEffect(solidJs.on(present, present => {
    if (prevPresent === present) {
      return;
    }
    const currentAnimationName = getAnimationName(styles);
    if (present) {
      send("MOUNT");
    } else if (styles?.display === "none") {
      send("UNMOUNT");
    } else {
      const isAnimating = prevAnimationName !== currentAnimationName;
      if (prevPresent && isAnimating) {
        send("ANIMATION_OUT");
      } else {
        send("UNMOUNT");
      }
    }
    prevPresent = present;
  }));
  solidJs.createEffect(solidJs.on(node, node => {
    if (node) {
      const handleAnimationEnd = event => {
        const currentAnimationName = getAnimationName(styles);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
        }
      };
      const handleAnimationStart = event => {
        if (event.target === node) {
          prevAnimationName = getAnimationName(styles);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      solidJs.onCleanup(() => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      });
    } else {
      send("ANIMATION_END");
    }
  }));
  return {
    isPresent: () => ["mounted", "unmountSuspended"].includes(state()),
    setRef: el => {
      if (el) {
        styles = getComputedStyle(el);
      }
      setNode(el);
    }
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function createStateMachine(initialState, machine) {
  const reduce = (state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  };
  const [state, setState] = solidJs.createSignal(initialState);
  const send = event => {
    setState(prev => reduce(prev, event));
  };
  return [state, send];
}

function createRegisterId(setter) {
  return id => {
    setter(id);
    return () => setter(undefined);
  };
}

function createTagName(ref, fallback) {
  const [tagName, setTagName] = solidJs.createSignal(stringOrUndefined(fallback?.()));
  solidJs.createEffect(() => {
    setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));
  });
  return tagName;
}
function stringOrUndefined(value) {
  return utils.isString(value) ? value : undefined;
}

function createToggleState(props = {}) {
  const [isSelected, _setIsSelected] = createControllableBooleanSignal({
    value: () => utils.access(props.isSelected),
    defaultValue: () => !!utils.access(props.defaultIsSelected),
    onChange: value => props.onSelectedChange?.(value)
  });
  const setIsSelected = value => {
    if (!utils.access(props.isReadOnly) && !utils.access(props.isDisabled)) {
      _setIsSelected(value);
    }
  };
  const toggle = () => {
    if (!utils.access(props.isReadOnly) && !utils.access(props.isDisabled)) {
      _setIsSelected(!isSelected());
    }
  };
  return {
    isSelected,
    setIsSelected,
    toggle
  };
}

const TRANSITION_PHASES_MAP = {
  beforeEnter: "out",
  enter: "in",
  afterEnter: "in",
  beforeExit: "in",
  exit: "out",
  afterExit: "out"
};
function getTransitionStyles(params) {
  const shared = {
    "transition-duration": `${params.duration}ms`,
    "transition-timing-function": params.easing
  };
  return {
    "transition-property": getTransitionProperty(params.transition),
    ...shared,
    ...params.transition.common,
    ...params.transition[TRANSITION_PHASES_MAP[params.phase]]
  };
}
function getTransitionProperty(transitionStyles) {
  return [...new Set([...Object.keys(transitionStyles.in), ...Object.keys(transitionStyles.out)])].join(", ");
}

const DEFAULT_DURATION = 250;
const DEFAULT_DELAY = 10;
const DEFAULT_EASING = "ease";
function createTransition(shouldMount, options) {
  const mergedOptions = solidJs.mergeProps({
    duration: DEFAULT_DURATION,
    delay: DEFAULT_DELAY,
    easing: DEFAULT_EASING,
    get exitDuration() {
      return utils.access(options).duration || DEFAULT_DURATION;
    },
    get exitDelay() {
      return utils.access(options).delay || DEFAULT_DELAY;
    },
    get exitEasing() {
      return utils.access(options).easing || DEFAULT_EASING;
    }
  }, options);
  const reduceMotion = utils.createMediaQuery("(prefers-reduced-motion: reduce)");
  const [duration, setDuration] = solidJs.createSignal(reduceMotion() ? 0 : utils.access(mergedOptions).duration);
  const [phase, setPhase] = solidJs.createSignal(utils.access(shouldMount) ? "afterEnter" : "afterExit");
  const [easing, setEasing] = solidJs.createSignal(utils.access(mergedOptions).easing);
  let timeoutId = -1;
  const handleStateChange = shouldMount => {
    const preHandler = shouldMount ? utils.access(mergedOptions).onBeforeEnter : utils.access(mergedOptions).onBeforeExit;
    const postHandler = shouldMount ? utils.access(mergedOptions).onAfterEnter : utils.access(mergedOptions).onAfterExit;
    setPhase(shouldMount ? "beforeEnter" : "beforeExit");
    window.clearTimeout(timeoutId);
    const newDuration = setDuration(reduceMotion() ? 0 : shouldMount ? utils.access(mergedOptions).duration : utils.access(mergedOptions).exitDuration);
    setEasing(shouldMount ? utils.access(mergedOptions).easing : utils.access(mergedOptions).exitEasing);
    if (newDuration === 0) {
      preHandler?.();
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
      return;
    }
    const delay = reduceMotion() ? 0 : shouldMount ? utils.access(mergedOptions).delay : utils.access(mergedOptions).exitDelay;
    const preStateTimeoutId = window.setTimeout(() => {
      preHandler?.();
      setPhase(shouldMount ? "enter" : "exit");
    }, delay);
    timeoutId = window.setTimeout(() => {
      window.clearTimeout(preStateTimeoutId);
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
    }, delay + newDuration);
  };
  const style = solidJs.createMemo(() => getTransitionStyles({
    transition: utils.access(mergedOptions).transition,
    duration: duration(),
    phase: phase(),
    easing: easing()
  }));
  const keepMounted = solidJs.createMemo(() => phase() !== "afterExit");
  solidJs.createEffect(solidJs.on(() => utils.access(shouldMount), shouldMount => handleStateChange(shouldMount), {
    defer: true
  }));
  solidJs.onCleanup(() => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(timeoutId);
  });
  return {
    keepMounted,
    style
  };
}

const FORM_CONTROL_PROP_NAMES = ["id", "name", "validationState", "required", "disabled", "readOnly"];
function createFormControl(props) {
  const defaultId = `form-control-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [labelId, setLabelId] = solidJs.createSignal();
  const [fieldId, setFieldId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [errorMessageId, setErrorMessageId] = solidJs.createSignal();
  const getAriaLabelledBy = (fieldId, fieldAriaLabel, fieldAriaLabelledBy) => {
    const hasAriaLabelledBy = fieldAriaLabelledBy != null || labelId() != null;
    return [fieldAriaLabelledBy, labelId(), hasAriaLabelledBy && fieldAriaLabel != null ? fieldId : undefined].filter(Boolean).join(" ") || undefined;
  };
  const getAriaDescribedBy = fieldAriaDescribedBy => {
    return [descriptionId(), errorMessageId(), fieldAriaDescribedBy].filter(Boolean).join(" ") || undefined;
  };
  const dataset = solidJs.createMemo(() => ({
    "data-valid": utils.access(mergedProps.validationState) === "valid" ? "" : undefined,
    "data-invalid": utils.access(mergedProps.validationState) === "invalid" ? "" : undefined,
    "data-required": utils.access(mergedProps.required) ? "" : undefined,
    "data-disabled": utils.access(mergedProps.disabled) ? "" : undefined,
    "data-readonly": utils.access(mergedProps.readOnly) ? "" : undefined
  }));
  const formControlContext = {
    name: () => utils.access(mergedProps.name) ?? utils.access(mergedProps.id),
    dataset,
    validationState: () => utils.access(mergedProps.validationState),
    isRequired: () => utils.access(mergedProps.required),
    isDisabled: () => utils.access(mergedProps.disabled),
    isReadOnly: () => utils.access(mergedProps.readOnly),
    labelId,
    fieldId,
    descriptionId,
    errorMessageId,
    getAriaLabelledBy,
    getAriaDescribedBy,
    generateId: utils.createGenerateId(() => utils.access(mergedProps.id)),
    registerLabel: createRegisterId(setLabelId),
    registerField: createRegisterId(setFieldId),
    registerDescription: createRegisterId(setDescriptionId),
    registerErrorMessage: createRegisterId(setErrorMessageId)
  };
  return {
    formControlContext
  };
}

const FormControlContext = solidJs.createContext();
function useFormControlContext() {
  const context = solidJs.useContext(FormControlContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useFormControlContext` must be used within a `FormControlContext.Provider` component");
  }
  return context;
}

const FORM_CONTROL_FIELD_PROP_NAMES = ["id", "aria-label", "aria-labelledby", "aria-describedby"];
function createFormControlField(props) {
  const context = useFormControlContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("field")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerField(utils.access(mergedProps.id))));
  return {
    fieldProps: {
      id: () => utils.access(mergedProps.id),
      ariaLabel: () => utils.access(mergedProps["aria-label"]),
      ariaLabelledBy: () => context.getAriaLabelledBy(utils.access(mergedProps.id), utils.access(mergedProps["aria-label"]), utils.access(mergedProps["aria-labelledby"])),
      ariaDescribedBy: () => context.getAriaDescribedBy(utils.access(mergedProps["aria-describedby"]))
    }
  };
}

function Polymorphic(props) {
  const [local, others] = solidJs.splitProps(props, ["asChild", "as", "children"]);
  if (!local.asChild) {
    return web.createComponent(web.Dynamic, web.mergeProps({
      get component() {
        return local.as;
      }
    }, others, {
      get children() {
        return local.children;
      }
    }));
  }
  const resolvedChildren = solidJs.children(() => local.children);
  if (isAs(resolvedChildren())) {
    const combinedProps = combineProps(others, resolvedChildren()?.props ?? {});
    return web.createComponent(web.Dynamic, combinedProps);
  }
  if (utils.isArray(resolvedChildren())) {
    const newElement = resolvedChildren().find(isAs);
    if (newElement) {
      const newChildren = () => web.createComponent(solidJs.For, {
        get each() {
          return resolvedChildren();
        },
        children: child => web.createComponent(solidJs.Show, {
          when: child === newElement,
          fallback: child,
          get children() {
            return newElement.props.children;
          }
        })
      });
      const combinedProps = combineProps(others, newElement?.props ?? {});
      return web.createComponent(web.Dynamic, web.mergeProps(combinedProps, {
        children: newChildren
      }));
    }
  }
  throw new Error("[kobalte]: Component is expected to render `asChild` but no children `As` component was found.");
}
const AS_COMPONENT_SYMBOL = Symbol("$$KobalteAsComponent");
function As(props) {
  return {
    [AS_COMPONENT_SYMBOL]: true,
    props
  };
}
function isAs(component) {
  return component?.[AS_COMPONENT_SYMBOL] === true;
}
function combineProps(baseProps, overrideProps) {
  return utils.combineProps([baseProps, overrideProps], {
    reverseEventHandlers: true
  });
}

function FormControlDescription(props) {
  const context = useFormControlContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescription(mergedProps.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), mergedProps));
}

function FormControlErrorMessage(props) {
  const context = useFormControlContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("error-message")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["forceMount"]);
  const isInvalid = () => context.validationState() === "invalid";
  solidJs.createEffect(() => {
    if (!isInvalid()) {
      return;
    }
    solidJs.onCleanup(context.registerErrorMessage(others.id));
  });
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.forceMount || isInvalid();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}

function FormControlLabel(props) {
  let ref;
  const context = useFormControlContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref"]);
  const tagName = createTagName(() => ref, () => "label");
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabel(others.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "label",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["for"]() {
      return web.memo(() => tagName() === "label")() ? context.fieldId() : undefined;
    }
  }, () => context.dataset(), others));
}

const RTL_SCRIPTS = new Set(["Avst", "Arab", "Armi", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]);
const RTL_LANGS = new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}
function getReadingDirection(locale) {
  return isRTL(locale) ? "rtl" : "ltr";
}

function getDefaultLocale() {
  let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([locale]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: getReadingDirection(locale)
  };
}
let currentLocale = getDefaultLocale();
const listeners = new Set();
function updateLocale() {
  currentLocale = getDefaultLocale();
  for (const listener of listeners) {
    listener(currentLocale);
  }
}
function createDefaultLocale() {
  const defaultSSRLocale = {
    locale: "en-US",
    direction: "ltr"
  };
  const [defaultClientLocale, setDefaultClientLocale] = solidJs.createSignal(currentLocale);
  const defaultLocale = solidJs.createMemo(() => web.isServer ? defaultSSRLocale : defaultClientLocale());
  solidJs.onMount(() => {
    if (listeners.size === 0) {
      window.addEventListener("languagechange", updateLocale);
    }
    listeners.add(setDefaultClientLocale);
    solidJs.onCleanup(() => {
      listeners.delete(setDefaultClientLocale);
      if (listeners.size === 0) {
        window.removeEventListener("languagechange", updateLocale);
      }
    });
  });
  return {
    locale: () => defaultLocale().locale,
    direction: () => defaultLocale().direction
  };
}

const I18nContext = solidJs.createContext();
function I18nProvider(props) {
  const defaultLocale = createDefaultLocale();
  const context = {
    locale: () => props.locale ?? defaultLocale.locale(),
    direction: () => props.locale ? getReadingDirection(props.locale) : defaultLocale.direction()
  };
  return web.createComponent(I18nContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}
function useLocale() {
  const defaultLocale = createDefaultLocale();
  const context = solidJs.useContext(I18nContext);
  return context || defaultLocale;
}

const cache = new Map();
function createCollator(options) {
  const {
    locale
  } = useLocale();
  const cacheKey = solidJs.createMemo(() => {
    return locale() + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  });
  return solidJs.createMemo(() => {
    const key = cacheKey();
    let collator;
    if (cache.has(key)) {
      collator = cache.get(key);
    }
    if (!collator) {
      collator = new Intl.Collator(locale(), options);
      cache.set(key, collator);
    }
    return collator;
  });
}

function createDateFormatter(options) {
  const {
    locale
  } = useLocale();
  return solidJs.createMemo(() => new date.DateFormatter(locale(), utils.access(options)));
}

function createFilter(options) {
  const collator = createCollator({
    usage: "search",
    ...options
  });
  const startsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    const normalizedStr = str.normalize("NFC");
    const normalizedSubstr = substr.normalize("NFC");
    return collator().compare(normalizedStr.slice(0, normalizedSubstr.length), normalizedSubstr) === 0;
  };
  const endsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    const normalizedStr = str.normalize("NFC");
    const normalizedSubstr = substr.normalize("NFC");
    return collator().compare(normalizedStr.slice(-normalizedSubstr.length), normalizedSubstr) === 0;
  };
  const contains = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    const normalizedStr = str.normalize("NFC");
    const normalizedSubstr = substr.normalize("NFC");
    let scan = 0;
    const sliceLen = substr.length;
    for (; scan + sliceLen <= normalizedStr.length; scan++) {
      const slice = normalizedStr.slice(scan, scan + sliceLen);
      if (collator().compare(normalizedSubstr, slice) === 0) {
        return true;
      }
    }
    return false;
  };
  return {
    startsWith,
    endsWith,
    contains
  };
}

function createNumberFormatter(options) {
  const {
    locale
  } = useLocale();
  return solidJs.createMemo(() => new number.NumberFormatter(locale(), utils.access(options)));
}

class Selection extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
}

function createControllableSelectionSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Selection();
  return [value, setValue];
}

function isNonContiguousSelectionModifier(e) {
  return utils.isAppleDevice() ? e.altKey : e.ctrlKey;
}
function isCtrlKeyPressed(e) {
  if (utils.isMac()) {
    return e.metaKey;
  }
  return e.ctrlKey;
}
function convertSelection(selection) {
  return new Selection(selection);
}
function isSameSelection(setA, setB) {
  if (setA.size !== setB.size) {
    return false;
  }
  for (const item of setA) {
    if (!setB.has(item)) {
      return false;
    }
  }
  return true;
}

function createMultipleSelectionState(props) {
  const mergedProps = utils.mergeDefaultProps({
    selectionMode: "none",
    selectionBehavior: "toggle"
  }, props);
  const [isFocused, setFocused] = solidJs.createSignal(false);
  const [focusedKey, setFocusedKey] = solidJs.createSignal();
  const selectedKeysProp = solidJs.createMemo(() => {
    const selection = utils.access(mergedProps.selectedKeys);
    if (selection != null) {
      return convertSelection(selection);
    }
    return selection;
  });
  const defaultSelectedKeys = solidJs.createMemo(() => {
    const defaultSelection = utils.access(mergedProps.defaultSelectedKeys);
    if (defaultSelection != null) {
      return convertSelection(defaultSelection);
    }
    return new Selection();
  });
  const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({
    value: selectedKeysProp,
    defaultValue: defaultSelectedKeys,
    onChange: value => mergedProps.onSelectionChange?.(value)
  });
  const [selectionBehavior, setSelectionBehavior] = solidJs.createSignal(utils.access(mergedProps.selectionBehavior));
  const selectionMode = () => utils.access(mergedProps.selectionMode);
  const disallowEmptySelection = () => utils.access(mergedProps.disallowEmptySelection) ?? false;
  const setSelectedKeys = keys => {
    if (utils.access(mergedProps.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) {
      _setSelectedKeys(keys);
    }
  };
  solidJs.createEffect(() => {
    const selection = selectedKeys();
    if (utils.access(mergedProps.selectionBehavior) === "replace" && selectionBehavior() === "toggle" && typeof selection === "object" && selection.size === 0) {
      setSelectionBehavior("replace");
    }
  });
  solidJs.createEffect(() => {
    setSelectionBehavior(utils.access(mergedProps.selectionBehavior) ?? "toggle");
  });
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    isFocused,
    setFocused,
    focusedKey,
    setFocusedKey,
    selectedKeys,
    setSelectedKeys
  };
}

function createTypeSelect(props) {
  const [search, setSearch] = solidJs.createSignal("");
  const [timeoutId, setTimeoutId] = solidJs.createSignal(-1);
  const onKeyDown = e => {
    if (utils.access(props.isDisabled)) {
      return;
    }
    const delegate = utils.access(props.keyboardDelegate);
    const manager = utils.access(props.selectionManager);
    if (!delegate.getKeyForSearch) {
      return;
    }
    const character = getStringForKey(e.key);
    if (!character || e.ctrlKey || e.metaKey) {
      return;
    }
    if (character === " " && search().trim().length > 0) {
      e.preventDefault();
      e.stopPropagation();
    }
    let newSearch = setSearch(prev => prev + character);
    let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    if (key == null && isAllSameLetter(newSearch)) {
      newSearch = newSearch[0];
      key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    }
    if (key != null) {
      manager.setFocusedKey(key);
      props.onTypeSelect?.(key);
    }
    clearTimeout(timeoutId());
    setTimeoutId(window.setTimeout(() => setSearch(""), 500));
  };
  return {
    typeSelectHandlers: {
      onKeyDown
    }
  };
}
function getStringForKey(key) {
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }
  return "";
}
function isAllSameLetter(search) {
  return search.split("").every(letter => letter === search[0]);
}

function createSelectableCollection(props, ref, scrollRef) {
  const defaultProps = {
    selectOnFocus: () => utils.access(props.selectionManager).selectionBehavior() === "replace"
  };
  const mergedProps = solidJs.mergeProps(defaultProps, props);
  const finalScrollRef = () => scrollRef?.() ?? ref();
  const {
    direction
  } = useLocale();
  let scrollPos = {
    top: 0,
    left: 0
  };
  utils.createEventListener(() => !utils.access(mergedProps.isVirtualized) ? finalScrollRef() : undefined, "scroll", () => {
    const scrollEl = finalScrollRef();
    if (!scrollEl) {
      return;
    }
    scrollPos = {
      top: scrollEl.scrollTop,
      left: scrollEl.scrollLeft
    };
  });
  const {
    typeSelectHandlers
  } = createTypeSelect({
    isDisabled: () => utils.access(mergedProps.disallowTypeAhead),
    keyboardDelegate: () => utils.access(mergedProps.keyboardDelegate),
    selectionManager: () => utils.access(mergedProps.selectionManager)
  });
  const onKeyDown = e => {
    utils.callHandler(e, typeSelectHandlers.onKeyDown);
    if (e.altKey && e.key === "Tab") {
      e.preventDefault();
    }
    const refEl = ref();
    if (!refEl?.contains(e.target)) {
      return;
    }
    const manager = utils.access(mergedProps.selectionManager);
    const selectOnFocus = utils.access(mergedProps.selectOnFocus);
    const navigateToKey = key => {
      if (key != null) {
        manager.setFocusedKey(key);
        if (e.shiftKey && manager.selectionMode() === "multiple") {
          manager.extendSelection(key);
        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {
          manager.replaceSelection(key);
        }
      }
    };
    const delegate = utils.access(mergedProps.keyboardDelegate);
    const shouldFocusWrap = utils.access(mergedProps.shouldFocusWrap);
    const focusedKey = manager.focusedKey();
    switch (e.key) {
      case "ArrowDown":
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyBelow(focusedKey);
            } else {
              nextKey = delegate.getFirstKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowUp":
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyAbove(focusedKey);
            } else {
              nextKey = delegate.getLastKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowLeft":
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyLeftOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowRight":
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyRightOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getLastKey?.() : delegate.getFirstKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "Home":
        if (delegate.getFirstKey) {
          e.preventDefault();
          const firstKey = delegate.getFirstKey(focusedKey, isCtrlKeyPressed(e));
          if (firstKey != null) {
            manager.setFocusedKey(firstKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(firstKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(firstKey);
            }
          }
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e.preventDefault();
          const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));
          if (lastKey != null) {
            manager.setFocusedKey(lastKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(lastKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(lastKey);
            }
          }
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageBelow(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageAbove(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if (isCtrlKeyPressed(e) && manager.selectionMode() === "multiple" && utils.access(mergedProps.disallowSelectAll) !== true) {
          e.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        if (!e.defaultPrevented) {
          e.preventDefault();
          if (!utils.access(mergedProps.disallowEmptySelection)) {
            manager.clearSelection();
          }
        }
        break;
      case "Tab":
        {
          if (!utils.access(mergedProps.allowsTabNavigation)) {
            if (e.shiftKey) {
              refEl.focus();
            } else {
              const walker = utils.getFocusableTreeWalker(refEl, {
                tabbable: true
              });
              let next;
              let last;
              do {
                last = walker.lastChild();
                if (last) {
                  next = last;
                }
              } while (last);
              if (next && !next.contains(document.activeElement)) {
                utils.focusWithoutScrolling(next);
              }
            }
            break;
          }
        }
    }
  };
  const onFocusIn = e => {
    const manager = utils.access(mergedProps.selectionManager);
    const delegate = utils.access(mergedProps.keyboardDelegate);
    const selectOnFocus = utils.access(mergedProps.selectOnFocus);
    if (manager.isFocused()) {
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }
      return;
    }
    if (!e.currentTarget.contains(e.target)) {
      return;
    }
    manager.setFocused(true);
    if (manager.focusedKey() == null) {
      const navigateToFirstKey = key => {
        if (key == null) {
          return;
        }
        manager.setFocusedKey(key);
        if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      };
      const relatedTarget = e.relatedTarget;
      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        navigateToFirstKey(manager.lastSelectedKey() ?? delegate.getLastKey?.());
      } else {
        navigateToFirstKey(manager.firstSelectedKey() ?? delegate.getFirstKey?.());
      }
    } else if (!utils.access(mergedProps.isVirtualized)) {
      const scrollEl = finalScrollRef();
      if (scrollEl) {
        scrollEl.scrollTop = scrollPos.top;
        scrollEl.scrollLeft = scrollPos.left;
        const element = scrollEl.querySelector(`[data-key="${manager.focusedKey()}"]`);
        if (element) {
          utils.focusWithoutScrolling(element);
          utils.scrollIntoView(scrollEl, element);
        }
      }
    }
  };
  const onFocusOut = e => {
    const manager = utils.access(mergedProps.selectionManager);
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };
  const onMouseDown = e => {
    if (finalScrollRef() === e.target) {
      e.preventDefault();
    }
  };
  const tryAutoFocus = () => {
    const autoFocus = utils.access(mergedProps.autoFocus);
    if (!autoFocus) {
      return;
    }
    const manager = utils.access(mergedProps.selectionManager);
    const delegate = utils.access(mergedProps.keyboardDelegate);
    let focusedKey;
    if (autoFocus === "first") {
      focusedKey = delegate.getFirstKey?.();
    }
    if (autoFocus === "last") {
      focusedKey = delegate.getLastKey?.();
    }
    const selectedKeys = manager.selectedKeys();
    if (selectedKeys.size) {
      focusedKey = selectedKeys.values().next().value;
    }
    manager.setFocused(true);
    manager.setFocusedKey(focusedKey);
    const refEl = ref();
    if (refEl && focusedKey == null && !utils.access(mergedProps.shouldUseVirtualFocus)) {
      utils.focusWithoutScrolling(refEl);
    }
  };
  solidJs.onMount(() => {
    if (mergedProps.deferAutoFocus) {
      setTimeout(tryAutoFocus, 0);
    } else {
      tryAutoFocus();
    }
  });
  solidJs.createEffect(solidJs.on([finalScrollRef, () => utils.access(mergedProps.isVirtualized), () => utils.access(mergedProps.selectionManager).focusedKey()], newValue => {
    const [scrollEl, isVirtualized, focusedKey] = newValue;
    if (isVirtualized) {
      focusedKey && mergedProps.scrollToKey?.(focusedKey);
    } else {
      if (focusedKey && scrollEl) {
        const element = scrollEl.querySelector(`[data-key="${focusedKey}"]`);
        if (element) {
          utils.scrollIntoView(scrollEl, element);
        }
      }
    }
  }));
  const tabIndex = solidJs.createMemo(() => {
    if (utils.access(mergedProps.shouldUseVirtualFocus)) {
      return undefined;
    }
    return utils.access(mergedProps.selectionManager).focusedKey() == null ? 0 : -1;
  });
  return {
    tabIndex,
    onKeyDown,
    onMouseDown,
    onFocusIn,
    onFocusOut
  };
}

function createSelectableItem(props, ref) {
  const manager = () => utils.access(props.selectionManager);
  const key = () => utils.access(props.key);
  const shouldUseVirtualFocus = () => utils.access(props.shouldUseVirtualFocus);
  const onSelect = e => {
    if (manager().selectionMode() === "none") {
      return;
    }
    if (manager().selectionMode() === "single") {
      if (manager().isSelected(key()) && !manager().disallowEmptySelection()) {
        manager().toggleSelection(key());
      } else {
        manager().replaceSelection(key());
      }
    } else if (e?.shiftKey) {
      manager().extendSelection(key());
    } else if (manager().selectionBehavior() === "toggle" || isCtrlKeyPressed(e) || "pointerType" in e && e.pointerType === "touch") {
      manager().toggleSelection(key());
    } else {
      manager().replaceSelection(key());
    }
  };
  const isSelected = () => manager().isSelected(key());
  const isDisabled = () => utils.access(props.disabled) || manager().isDisabled(key());
  const allowsSelection = () => !isDisabled() && manager().canSelectItem(key());
  let pointerDownType = null;
  const onPointerDown = e => {
    if (!allowsSelection()) {
      return;
    }
    pointerDownType = e.pointerType;
    if (e.pointerType === "mouse" && e.button === 0 && !utils.access(props.shouldSelectOnPressUp)) {
      onSelect(e);
    }
  };
  const onPointerUp = e => {
    if (!allowsSelection()) {
      return;
    }
    if (e.pointerType === "mouse" && e.button === 0 && utils.access(props.shouldSelectOnPressUp) && utils.access(props.allowsDifferentPressOrigin)) {
      onSelect(e);
    }
  };
  const onClick = e => {
    if (!allowsSelection()) {
      return;
    }
    if (utils.access(props.shouldSelectOnPressUp) && !utils.access(props.allowsDifferentPressOrigin) || pointerDownType !== "mouse") {
      onSelect(e);
    }
  };
  const onKeyDown = e => {
    if (!allowsSelection() || !["Enter", " "].includes(e.key)) {
      return;
    }
    if (isNonContiguousSelectionModifier(e)) {
      manager().toggleSelection(key());
    } else {
      onSelect(e);
    }
  };
  const onMouseDown = e => {
    if (isDisabled()) {
      e.preventDefault();
    }
  };
  const onFocus = e => {
    const refEl = ref();
    if (shouldUseVirtualFocus() || isDisabled() || !refEl) {
      return;
    }
    if (e.target === refEl) {
      manager().setFocusedKey(key());
    }
  };
  const tabIndex = solidJs.createMemo(() => {
    if (shouldUseVirtualFocus() || isDisabled()) {
      return undefined;
    }
    return key() === manager().focusedKey() ? 0 : -1;
  });
  const dataKey = solidJs.createMemo(() => {
    return utils.access(props.virtualized) ? undefined : key();
  });
  solidJs.createEffect(solidJs.on([ref, key, shouldUseVirtualFocus, () => manager().focusedKey(), () => manager().isFocused()], ([refEl, key, shouldUseVirtualFocus, focusedKey, isFocused]) => {
    if (refEl && key === focusedKey && isFocused && !shouldUseVirtualFocus && document.activeElement !== refEl) {
      if (props.focus) {
        props.focus();
      } else {
        utils.focusWithoutScrolling(refEl);
      }
    }
  }));
  return {
    isSelected,
    isDisabled,
    allowsSelection,
    tabIndex,
    dataKey,
    onPointerDown,
    onPointerUp,
    onClick,
    onKeyDown,
    onMouseDown,
    onFocus
  };
}

class SelectionManager {
  constructor(collection, state) {
    this.collection = collection;
    this.state = state;
  }
  selectionMode() {
    return this.state.selectionMode();
  }
  disallowEmptySelection() {
    return this.state.disallowEmptySelection();
  }
  selectionBehavior() {
    return this.state.selectionBehavior();
  }
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  isFocused() {
    return this.state.isFocused();
  }
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  focusedKey() {
    return this.state.focusedKey();
  }
  setFocusedKey(key) {
    if (key == null || this.collection().getItem(key)) {
      this.state.setFocusedKey(key);
    }
  }
  selectedKeys() {
    return this.state.selectedKeys();
  }
  isSelected(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return false;
    }
    return this.state.selectedKeys().has(retrievedKey);
  }
  isEmpty() {
    return this.state.selectedKeys().size === 0;
  }
  isSelectAll() {
    if (this.isEmpty()) {
      return false;
    }
    const selectedKeys = this.state.selectedKeys();
    return this.getAllSelectableKeys().every(k => selectedKeys.has(k));
  }
  firstSelectedKey() {
    let first;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;
      if (!first || isItemBeforeFirst) {
        first = item;
      }
    }
    return first?.key;
  }
  lastSelectedKey() {
    let last;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;
      if (!last || isItemAfterLast) {
        last = item;
      }
    }
    return last?.key;
  }
  extendSelection(toKey) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      this.replaceSelection(toKey);
      return;
    }
    const retrievedToKey = this.getKey(toKey);
    if (retrievedToKey == null) {
      return;
    }
    const selectedKeys = this.state.selectedKeys();
    const anchorKey = selectedKeys.anchorKey || retrievedToKey;
    const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);
    for (const key of this.getKeyRange(anchorKey, selectedKeys.currentKey || retrievedToKey)) {
      selection.delete(key);
    }
    for (const key of this.getKeyRange(retrievedToKey, anchorKey)) {
      if (this.canSelectItem(key)) {
        selection.add(key);
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    const fromItem = this.collection().getItem(from);
    const toItem = this.collection().getItem(to);
    if (fromItem && toItem) {
      if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) {
        return this.getKeyRangeInternal(from, to);
      }
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    const keys = [];
    let key = from;
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item") {
        keys.push(key);
      }
      if (key === to) {
        return keys;
      }
      key = this.collection().getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    const item = this.collection().getItem(key);
    if (!item) {
      return key;
    }
    if (!item || item.type !== "item") {
      return null;
    }
    return item.key;
  }
  toggleSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const keys = new Selection(this.state.selectedKeys());
    if (keys.has(retrievedKey)) {
      keys.delete(retrievedKey);
    } else if (this.canSelectItem(retrievedKey)) {
      keys.add(retrievedKey);
      keys.anchorKey = retrievedKey;
      keys.currentKey = retrievedKey;
    }
    if (this.disallowEmptySelection() && keys.size === 0) {
      return;
    }
    this.state.setSelectedKeys(keys);
  }
  replaceSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const selection = this.canSelectItem(retrievedKey) ? new Selection([retrievedKey], retrievedKey, retrievedKey) : new Selection();
    this.state.setSelectedKeys(selection);
  }
  setSelectedKeys(keys) {
    if (this.selectionMode() === "none") {
      return;
    }
    const selection = new Selection();
    for (const key of keys) {
      const retrievedKey = this.getKey(key);
      if (retrievedKey != null) {
        selection.add(retrievedKey);
        if (this.selectionMode() === "single") {
          break;
        }
      }
    }
    this.state.setSelectedKeys(selection);
  }
  selectAll() {
    if (this.selectionMode() === "multiple") {
      this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));
    }
  }
  clearSelection() {
    const selectedKeys = this.state.selectedKeys();
    if (!this.disallowEmptySelection() && selectedKeys.size > 0) {
      this.state.setSelectedKeys(new Selection());
    }
  }
  toggleSelectAll() {
    if (this.isSelectAll()) {
      this.clearSelection();
    } else {
      this.selectAll();
    }
  }
  select(key, e) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection()) {
        this.toggleSelection(key);
      } else {
        this.replaceSelection(key);
      }
    } else if (this.selectionBehavior() === "toggle" || e && e.pointerType === "touch") {
      this.toggleSelection(key);
    } else {
      this.replaceSelection(key);
    }
  }
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys()) {
      return true;
    }
    const selectedKeys = this.selectedKeys();
    if (selection.size !== selectedKeys.size) {
      return false;
    }
    for (const key of selection) {
      if (!selectedKeys.has(key)) {
        return false;
      }
    }
    for (const key of selectedKeys) {
      if (!selection.has(key)) {
        return false;
      }
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const item = this.collection().getItem(key);
    return item != null && !item.disabled;
  }
  isDisabled(key) {
    const item = this.collection().getItem(key);
    return !item || item.disabled;
  }
  getAllSelectableKeys() {
    const keys = [];
    const addKeys = key => {
      while (key != null) {
        if (this.canSelectItem(key)) {
          const item = this.collection().getItem(key);
          if (!item) {
            continue;
          }
          if (item.type === "item") {
            keys.push(key);
          }
        }
        key = this.collection().getKeyAfter(key);
      }
    };
    addKeys(this.collection().getFirstKey());
    return keys;
  }
}

class ListCollection {
  keyMap = new Map();
  constructor(nodes) {
    this.iterable = nodes;
    for (const node of nodes) {
      this.keyMap.set(node.key, node);
    }
    if (this.keyMap.size === 0) {
      return;
    }
    let last;
    let index = 0;
    for (const [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = undefined;
      }
      if (node.type === "item") {
        node.index = index++;
      }
      last = node;
      last.nextKey = undefined;
    }
    this.lastKey = last.key;
  }
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  getSize() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    return this.keyMap.get(key)?.prevKey;
  }
  getKeyAfter(key) {
    return this.keyMap.get(key)?.nextKey;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }
}

function createListState(props) {
  const selectionState = createMultipleSelectionState(props);
  const factory = nodes => {
    return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);
  };
  const collection = createCollection({
    dataSource: () => utils.access(props.dataSource),
    getKey: () => utils.access(props.getKey),
    getTextValue: () => utils.access(props.getTextValue),
    getDisabled: () => utils.access(props.getDisabled),
    getSectionChildren: () => utils.access(props.getSectionChildren),
    factory
  }, [() => props.filter]);
  const selectionManager = new SelectionManager(collection, selectionState);
  solidJs.createComputed(() => {
    const focusedKey = selectionState.focusedKey();
    if (focusedKey != null && !collection().getItem(focusedKey)) {
      selectionState.setFocusedKey(undefined);
    }
  });
  return {
    collection,
    selectionManager: () => selectionManager
  };
}

class ListKeyboardDelegate {
  constructor(collection, ref, collator) {
    this.collection = collection;
    this.ref = ref;
    this.collator = collator;
  }
  getKeyBelow(key) {
    let keyAfter = this.collection().getKeyAfter(key);
    while (keyAfter != null) {
      const item = this.collection().getItem(keyAfter);
      if (item && item.type === "item" && !item.disabled) {
        return keyAfter;
      }
      keyAfter = this.collection().getKeyAfter(keyAfter);
    }
  }
  getKeyAbove(key) {
    let keyBefore = this.collection().getKeyBefore(key);
    while (keyBefore != null) {
      const item = this.collection().getItem(keyBefore);
      if (item && item.type === "item" && !item.disabled) {
        return keyBefore;
      }
      keyBefore = this.collection().getKeyBefore(keyBefore);
    }
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyAfter(key);
    }
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyBefore(key);
    }
  }
  getItem(key) {
    return this.ref?.()?.querySelector(`[data-key="${key}"]`) ?? null;
  }
  getKeyPageAbove(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);
    let keyAbove = key;
    while (keyAbove && item && item.offsetTop > pageY) {
      keyAbove = this.getKeyAbove(keyAbove);
      item = keyAbove != null ? this.getItem(keyAbove) : null;
    }
    return keyAbove;
  }
  getKeyPageBelow(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);
    let keyBelow = key;
    while (keyBelow && item && item.offsetTop < pageY) {
      keyBelow = this.getKeyBelow(keyBelow);
      item = keyBelow != null ? this.getItem(keyBelow) : null;
    }
    return keyBelow;
  }
  getKeyForSearch(search, fromKey) {
    const collator = this.collator?.();
    if (!collator) {
      return;
    }
    let key = fromKey != null ? this.getKeyBelow(fromKey) : this.getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item) {
        const substring = item.textValue.slice(0, search.length);
        if (item.textValue && collator.compare(substring, search) === 0) {
          return key;
        }
      }
      key = this.getKeyBelow(key);
    }
  }
}

function createSelectableList(props, ref, scrollRef) {
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });
  const delegate = solidJs.createMemo(() => {
    const keyboardDelegate = utils.access(props.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(props.collection, ref, collator);
  });
  return createSelectableCollection({
    selectionManager: () => utils.access(props.selectionManager),
    keyboardDelegate: delegate,
    autoFocus: () => utils.access(props.autoFocus),
    deferAutoFocus: () => utils.access(props.deferAutoFocus),
    shouldFocusWrap: () => utils.access(props.shouldFocusWrap),
    disallowEmptySelection: () => utils.access(props.disallowEmptySelection),
    selectOnFocus: () => utils.access(props.selectOnFocus),
    disallowTypeAhead: () => utils.access(props.disallowTypeAhead),
    shouldUseVirtualFocus: () => utils.access(props.shouldUseVirtualFocus),
    allowsTabNavigation: () => utils.access(props.allowsTabNavigation),
    isVirtualized: () => utils.access(props.isVirtualized),
    scrollToKey: key => utils.access(props.scrollToKey)?.(key)
  }, ref, scrollRef);
}

function createSingleSelectListState(props) {
  const [selectedKey, setSelectedKey] = createControllableSignal({
    value: () => utils.access(props.selectedKey),
    defaultValue: () => utils.access(props.defaultSelectedKey),
    onChange: value => props.onSelectionChange?.(value)
  });
  const selectedKeys = solidJs.createMemo(() => {
    const selection = selectedKey();
    return selection != null ? [selection] : [];
  });
  const [, defaultCreateListStateProps] = solidJs.splitProps(props, ["onSelectionChange"]);
  const createListStateProps = solidJs.mergeProps(defaultCreateListStateProps, {
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: keys => {
      const key = keys.values().next().value;
      if (key === selectedKey()) {
        props.onSelectionChange?.(key);
      }
      setSelectedKey(key);
    }
  });
  const {
    collection,
    selectionManager
  } = createListState(createListStateProps);
  const selectedItem = solidJs.createMemo(() => {
    const selection = selectedKey();
    return selection != null ? collection().getItem(selection) : undefined;
  });
  return {
    collection,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

const [state, setState] = store.createStore({
  toasts: []
});
function add(toast) {
  setState("toasts", prev => [...prev, toast]);
}
function get(id) {
  return state.toasts.find(toast => toast.id === id);
}
function update$1(id, toast) {
  const index = state.toasts.findIndex(toast => toast.id === id);
  if (index !== -1) {
    setState("toasts", prev => [...prev.slice(0, index), toast, ...prev.slice(index + 1)]);
  }
}
function dismiss$1(id) {
  setState("toasts", toast => toast.id === id, "dismiss", true);
}
function remove(id) {
  setState("toasts", prev => prev.filter(toast => toast.id !== id));
}
function clear$1() {
  setState("toasts", []);
}
const toastStore = {
  toasts: () => state.toasts,
  add,
  get,
  update: update$1,
  dismiss: dismiss$1,
  remove,
  clear: clear$1
};

let toastsCounter = 0;
function show(toastComponent, options) {
  const id = toastsCounter++;
  toastStore.add({
    id,
    toastComponent,
    dismiss: false,
    update: false,
    region: options?.region
  });
  return id;
}
function update(id, toastComponent) {
  toastStore.update(id, {
    id,
    toastComponent,
    dismiss: false,
    update: true
  });
}
function promise(promise, toastComponent, options) {
  const id = show(props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "pending"
    });
  }, options);
  (utils.isFunction(promise) ? promise() : promise).then(data => update(id, props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "fulfilled",
      data
    });
  })).catch(error => update(id, props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "rejected",
      error
    });
  }));
  return id;
}
function dismiss(id) {
  toastStore.dismiss(id);
  return id;
}
function clear() {
  toastStore.clear();
}
const toaster = {
  show,
  update,
  promise,
  dismiss,
  clear
};

const CollapsibleContext = solidJs.createContext();
function useCollapsibleContext() {
  const context = solidJs.useContext(CollapsibleContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCollapsibleContext` must be used within a `Collapsible.Root` component");
  }
  return context;
}

function CollapsibleContent(props) {
  let ref;
  const context = useCollapsibleContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id", "style"]);
  const presence = createPresence(() => context.shouldMount());
  const [height, setHeight] = solidJs.createSignal(0);
  const [width, setWidth] = solidJs.createSignal(0);
  const isOpen = () => context.isOpen() || presence.isPresent();
  let isMountAnimationPrevented = isOpen();
  let originalStyles;
  solidJs.onMount(() => {
    const raf = requestAnimationFrame(() => {
      isMountAnimationPrevented = false;
    });
    solidJs.onCleanup(() => {
      cancelAnimationFrame(raf);
    });
  });
  solidJs.createEffect(solidJs.on([() => presence.isPresent()], () => {
    if (!ref) {
      return;
    }
    originalStyles = originalStyles || {
      transitionDuration: ref.style.transitionDuration,
      animationName: ref.style.animationName
    };
    ref.style.transitionDuration = "0s";
    ref.style.animationName = "none";
    const rect = ref.getBoundingClientRect();
    setHeight(rect.height);
    setWidth(rect.width);
    if (!isMountAnimationPrevented) {
      ref.style.transitionDuration = originalStyles.transitionDuration;
      ref.style.animationName = originalStyles.animationName;
    }
  }));
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(local.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => {
            presence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return local.id;
        },
        get style() {
          return {
            "--kb-collapsible-content-height": height() ? `${height()}px` : undefined,
            "--kb-collapsible-content-width": width() ? `${width()}px` : undefined,
            ...local.style
          };
        }
      }, () => context.dataset(), others));
    }
  });
}

function CollapsibleRoot(props) {
  const defaultId = `collapsible-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["open", "defaultOpen", "onOpenChange", "disabled", "forceMount"]);
  const [contentId, setContentId] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined,
    "data-disabled": local.disabled ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    disabled: () => local.disabled ?? false,
    shouldMount: () => local.forceMount || disclosureState.isOpen(),
    contentId,
    toggle: disclosureState.toggle,
    generateId: utils.createGenerateId(() => others.id),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(CollapsibleContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div"
      }, dataset, others));
    }
  });
}

const BUTTON_INPUT_TYPES = ["button", "color", "file", "image", "reset", "submit"];
function isButton(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName === "button") {
    return true;
  }
  if (tagName === "input" && element.type) {
    return BUTTON_INPUT_TYPES.indexOf(element.type) !== -1;
  }
  return false;
}

function ButtonRoot(props) {
  let ref;
  const mergedProps = utils.mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "type", "disabled"]);
  const tagName = createTagName(() => ref, () => "button");
  const isNativeButton = solidJs.createMemo(() => {
    const elementTagName = tagName();
    if (elementTagName == null) {
      return false;
    }
    return isButton({
      tagName: elementTagName,
      type: local.type
    });
  });
  const isNativeInput = solidJs.createMemo(() => {
    return tagName() === "input";
  });
  const isNativeLink = solidJs.createMemo(() => {
    return tagName() === "a" && ref?.getAttribute("href") != null;
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "button",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get type() {
      return isNativeButton() || isNativeInput() ? local.type : undefined;
    },
    get role() {
      return !isNativeButton() && !isNativeLink() ? "button" : undefined;
    },
    get tabIndex() {
      return !isNativeButton() && !isNativeLink() && !local.disabled ? 0 : undefined;
    },
    get disabled() {
      return isNativeButton() || isNativeInput() ? local.disabled : undefined;
    },
    get ["aria-disabled"]() {
      return !isNativeButton() && !isNativeInput() && local.disabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    }
  }, others));
}

var index$w = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: ButtonRoot
});

function CollapsibleTrigger(props) {
  const context = useCollapsibleContext();
  const [local, others] = solidJs.splitProps(props, ["onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get disabled() {
      return context.disabled();
    },
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$v = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Content: CollapsibleContent,
	Root: CollapsibleRoot,
	Trigger: CollapsibleTrigger
});

const AccordionItemContext = solidJs.createContext();
function useAccordionItemContext() {
  const context = solidJs.useContext(AccordionItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionItemContext` must be used within a `Accordion.Item` component");
  }
  return context;
}

function AccordionContent(props) {
  const itemContext = useAccordionItemContext();
  const defaultId = itemContext.generateId("content");
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["style"]);
  solidJs.createEffect(() => solidJs.onCleanup(itemContext.registerContentId(others.id)));
  return web.createComponent(CollapsibleContent, web.mergeProps({
    role: "region",
    get ["aria-labelledby"]() {
      return itemContext.triggerId();
    },
    get style() {
      return {
        "--kb-accordion-content-height": "var(--kb-collapsible-content-height)",
        "--kb-accordion-content-width": "var(--kb-collapsible-content-width)",
        ...local.style
      };
    }
  }, others));
}

function AccordionHeader(props) {
  const context = useCollapsibleContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h3"
  }, () => context.dataset(), props));
}

const AccordionContext = solidJs.createContext();
function useAccordionContext() {
  const context = solidJs.useContext(AccordionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionContext` must be used within a `Accordion.Root` component");
  }
  return context;
}

function AccordionItem(props) {
  const accordionContext = useAccordionContext();
  const defaultId = `${accordionContext.generateId("item")}-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value", "disabled"]);
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const selectionManager = () => accordionContext.listState().selectionManager();
  const isExpanded = () => {
    return selectionManager().isSelected(local.value);
  };
  const context = {
    value: () => local.value,
    triggerId,
    contentId,
    generateId: utils.createGenerateId(() => others.id),
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(AccordionItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(CollapsibleRoot, web.mergeProps({
        get open() {
          return isExpanded();
        },
        get disabled() {
          return local.disabled;
        }
      }, others));
    }
  });
}

const DomCollectionContext = solidJs.createContext();
function useOptionalDomCollectionContext() {
  return solidJs.useContext(DomCollectionContext);
}
function useDomCollectionContext() {
  const context = useOptionalDomCollectionContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useDomCollectionContext` must be used within a `DomCollectionProvider` component");
  }
  return context;
}

function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
  const itemEl = item.ref();
  if (!itemEl) {
    return -1;
  }
  let length = items.length;
  if (!length) {
    return -1;
  }
  while (length--) {
    const currentItemEl = items[length]?.ref();
    if (!currentItemEl) {
      continue;
    }
    if (isElementPreceding(currentItemEl, itemEl)) {
      return length + 1;
    }
  }
  return 0;
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.ref();
    const elementB = b.ref();
    if (elementA === elementB) {
      return 0;
    }
    if (!elementA || !elementB) {
      return 0;
    }
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
  const sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
function getCommonParent(items) {
  const firstItem = items[0];
  const lastItemEl = items[items.length - 1]?.ref();
  let parentEl = firstItem?.ref()?.parentElement;
  while (parentEl) {
    if (lastItemEl && parentEl.contains(lastItemEl)) {
      return parentEl;
    }
    parentEl = parentEl.parentElement;
  }
  return utils.getDocument(parentEl).body;
}
function createTimeoutObserver(items, setItems) {
  solidJs.createEffect(() => {
    const timeout = setTimeout(() => {
      setItemsBasedOnDOMPosition(items(), setItems);
    });
    solidJs.onCleanup(() => clearTimeout(timeout));
  });
}
function createSortBasedOnDOMPosition(items, setItems) {
  if (typeof IntersectionObserver !== "function") {
    createTimeoutObserver(items, setItems);
    return;
  }
  let previousItems = [];
  solidJs.createEffect(() => {
    const callback = () => {
      const hasPreviousItems = !!previousItems.length;
      previousItems = items();
      if (!hasPreviousItems) {
        return;
      }
      setItemsBasedOnDOMPosition(items(), setItems);
    };
    const root = getCommonParent(items());
    const observer = new IntersectionObserver(callback, {
      root
    });
    for (const item of items()) {
      const itemEl = item.ref();
      if (itemEl) {
        observer.observe(itemEl);
      }
    }
    solidJs.onCleanup(() => observer.disconnect());
  });
}

function createDomCollection(props = {}) {
  const [items, setItems] = createControllableArraySignal({
    value: () => utils.access(props.items),
    onChange: value => props.onItemsChange?.(value)
  });
  createSortBasedOnDOMPosition(items, setItems);
  const registerItem = item => {
    setItems(prevItems => {
      const index = findDOMIndex(prevItems, item);
      return utils.addItemToArray(prevItems, item, index);
    });
    return () => {
      setItems(prevItems => {
        const nextItems = prevItems.filter(prevItem => prevItem.ref() !== item.ref());
        if (prevItems.length === nextItems.length) {
          return prevItems;
        }
        return nextItems;
      });
    };
  };
  const DomCollectionProvider = props => {
    return solidJs.createComponent(DomCollectionContext.Provider, {
      value: {
        registerItem
      },
      get children() {
        return props.children;
      }
    });
  };
  return {
    DomCollectionProvider
  };
}

function createDomCollectionItem(props) {
  const context = useDomCollectionContext();
  const mergedProps = utils.mergeDefaultProps({
    shouldRegisterItem: true
  }, props);
  solidJs.createEffect(() => {
    if (!mergedProps.shouldRegisterItem) {
      return;
    }
    const unregister = context.registerItem(mergedProps.getItem());
    solidJs.onCleanup(unregister);
  });
}

function AccordionRoot(props) {
  let ref;
  const defaultId = `accordion-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    multiple: false,
    collapsible: false,
    shouldFocusWrap: true
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "multiple", "collapsible", "shouldFocusWrap", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const [items, setItems] = solidJs.createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createListState({
    selectedKeys: () => local.value,
    defaultSelectedKeys: () => local.defaultValue,
    onSelectionChange: value => local.onChange?.(Array.from(value)),
    disallowEmptySelection: () => !local.multiple && !local.collapsible,
    selectionMode: () => local.multiple ? "multiple" : "single",
    dataSource: items
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState.selectionManager(),
    collection: () => listState.collection(),
    disallowEmptySelection: () => listState.selectionManager().disallowEmptySelection(),
    shouldFocusWrap: () => local.shouldFocusWrap,
    disallowTypeAhead: true,
    allowsTabNavigation: true
  }, () => ref);
  const context = {
    listState: () => listState,
    generateId: utils.createGenerateId(() => others.id)
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(AccordionContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get onKeyDown() {
              return utils.composeEventHandlers([local.onKeyDown, selectableList.onKeyDown]);
            },
            get onMouseDown() {
              return utils.composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
            },
            get onFocusIn() {
              return utils.composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
            },
            get onFocusOut() {
              return utils.composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
            }
          }, others));
        }
      });
    }
  });
}

function AccordionTrigger(props) {
  let ref;
  const accordionContext = useAccordionContext();
  const itemContext = useAccordionItemContext();
  const collapsibleContext = useCollapsibleContext();
  const defaultId = itemContext.generateId("trigger");
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: itemContext.value(),
      textValue: "",
      disabled: collapsibleContext.disabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => itemContext.value(),
    selectionManager: () => accordionContext.listState().selectionManager(),
    disabled: () => collapsibleContext.disabled(),
    shouldSelectOnPressUp: true
  }, () => ref);
  const onKeyDown = e => {
    if (["Enter", " "].includes(e.key)) {
      e.preventDefault();
    }
    utils.callHandler(e, local.onKeyDown);
    utils.callHandler(e, selectableItem.onKeyDown);
  };
  solidJs.createEffect(() => solidJs.onCleanup(itemContext.registerTriggerId(others.id)));
  return web.createComponent(CollapsibleTrigger, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get onPointerDown() {
      return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return utils.composeEventHandlers([local.onClick, selectableItem.onClick]);
    },
    onKeyDown: onKeyDown,
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    }
  }, others));
}

var index$u = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Content: AccordionContent,
	Header: AccordionHeader,
	Item: AccordionItem,
	Root: AccordionRoot,
	Trigger: AccordionTrigger
});

function AlertRoot(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    role: "alert"
  }, props));
}

var index$t = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: AlertRoot
});

const DialogContext = solidJs.createContext();
function useDialogContext() {
  const context = solidJs.useContext(DialogContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDialogContext` must be used within a `Dialog` component");
  }
  return context;
}

function DialogCloseButton(props) {
  const context = useDialogContext();
  const [local, others] = solidJs.splitProps(props, ["aria-label", "onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.close();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-label"]() {
      return local["aria-label"] || context.translations().dismiss;
    },
    onClick: onClick
  }, others));
}

const DismissableLayerContext = solidJs.createContext();
function useOptionalDismissableLayerContext() {
  return solidJs.useContext(DismissableLayerContext);
}

function DismissableLayer(props) {
  let ref;
  const parentContext = useOptionalDismissableLayerContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "disableOutsidePointerEvents", "excludedElements", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "bypassTopMostLayerCheck"]);
  const nestedLayers = new Set([]);
  const registerNestedLayer = element => {
    nestedLayers.add(element);
    const parentUnregister = parentContext?.registerNestedLayer(element);
    return () => {
      nestedLayers.delete(element);
      parentUnregister?.();
    };
  };
  const shouldExcludeElement = element => {
    if (!ref) {
      return false;
    }
    return local.excludedElements?.some(node => utils.contains(node(), element)) || [...nestedLayers].some(layer => utils.contains(layer, element));
  };
  const onPointerDownOutside = e => {
    if (!ref || layerStack.isBelowPointerBlockingLayer(ref)) {
      return;
    }
    if (!local.bypassTopMostLayerCheck && !layerStack.isTopMostLayer(ref)) {
      return;
    }
    local.onPointerDownOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  createInteractOutside({
    shouldExcludeElement,
    onPointerDownOutside,
    onFocusOutside
  }, () => ref);
  createEscapeKeyDown({
    ownerDocument: () => utils.getDocument(ref),
    onEscapeKeyDown: e => {
      if (!ref || !layerStack.isTopMostLayer(ref)) {
        return;
      }
      local.onEscapeKeyDown?.(e);
      if (!e.defaultPrevented && local.onDismiss) {
        e.preventDefault();
        local.onDismiss();
      }
    }
  });
  solidJs.onMount(() => {
    if (!ref) {
      return;
    }
    layerStack.addLayer({
      node: ref,
      isPointerBlocking: local.disableOutsidePointerEvents,
      dismiss: local.onDismiss
    });
    const unregisterFromParentLayer = parentContext?.registerNestedLayer(ref);
    layerStack.assignPointerEventToLayers();
    layerStack.disableBodyPointerEvents(ref);
    solidJs.onCleanup(() => {
      if (!ref) {
        return;
      }
      layerStack.removeLayer(ref);
      unregisterFromParentLayer?.();
      layerStack.assignPointerEventToLayers();
      layerStack.restoreBodyPointerEvents(ref);
    });
  });
  solidJs.createEffect(solidJs.on([() => ref, () => local.disableOutsidePointerEvents], ([ref, disableOutsidePointerEvents]) => {
    if (!ref) {
      return;
    }
    const layer = layerStack.find(ref);
    if (layer && layer.isPointerBlocking !== disableOutsidePointerEvents) {
      layer.isPointerBlocking = disableOutsidePointerEvents;
      layerStack.assignPointerEventToLayers();
    }
    if (disableOutsidePointerEvents) {
      layerStack.disableBodyPointerEvents(ref);
    }
    solidJs.onCleanup(() => {
      layerStack.restoreBodyPointerEvents(ref);
    });
  }, {
    defer: true
  }));
  const context = {
    registerNestedLayer
  };
  return web.createComponent(DismissableLayerContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others));
    }
  });
}

function DialogContent(props) {
  let ref;
  const context = useDialogContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.modal() && e.detail.isContextMenu) {
      e.preventDefault();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.modal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.modal()) {
      return;
    }
    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }
    if (utils.contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.modal()) {
      e.preventDefault();
      utils.focusWithoutScrolling(context.triggerRef());
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          utils.focusWithoutScrolling(context.triggerRef());
        }
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.modal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.modal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(DismissableLayer, web.mergeProps({
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => {
            context.contentPresence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "dialog",
        tabIndex: -1,
        get disableOutsidePointerEvents() {
          return web.memo(() => !!context.modal())() && context.isOpen();
        },
        get excludedElements() {
          return [context.triggerRef];
        },
        get ["aria-labelledby"]() {
          return context.titleId();
        },
        get ["aria-describedby"]() {
          return context.descriptionId();
        },
        get ["data-expanded"]() {
          return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"]() {
          return !context.isOpen() ? "" : undefined;
        },
        onPointerDownOutside: onPointerDownOutside,
        onFocusOutside: onFocusOutside,
        onInteractOutside: onInteractOutside,
        get onDismiss() {
          return context.close;
        }
      }, others));
    }
  });
}

function DialogDescription(props) {
  const context = useDialogContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "p",
    get id() {
      return local.id;
    }
  }, others));
}

function DialogOverlay(props) {
  const context = useDialogContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "style", "onPointerDown"]);
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.overlayPresence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(context.overlayPresence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get style() {
          return {
            "pointer-events": "auto",
            ...local.style
          };
        },
        get ["data-expanded"]() {
          return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"]() {
          return !context.isOpen() ? "" : undefined;
        },
        onPointerDown: onPointerDown
      }, others));
    }
  });
}

function DialogPortal(props) {
  const context = useDialogContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent() || context.overlayPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

const DIALOG_INTL_TRANSLATIONS = {
  dismiss: "Dismiss"
};

function DialogRoot(props) {
  const defaultId = `dialog-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    modal: true,
    translations: DIALOG_INTL_TRANSLATIONS
  }, props);
  const [contentId, setContentId] = solidJs.createSignal();
  const [titleId, setTitleId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => mergedProps.open,
    defaultOpen: () => mergedProps.defaultOpen,
    onOpenChange: isOpen => mergedProps.onOpenChange?.(isOpen)
  });
  const shouldMount = () => mergedProps.forceMount || disclosureState.isOpen();
  const overlayPresence = createPresence(shouldMount);
  const contentPresence = createPresence(shouldMount);
  const context = {
    translations: () => mergedProps.translations ?? DIALOG_INTL_TRANSLATIONS,
    isOpen: disclosureState.isOpen,
    modal: () => mergedProps.modal ?? true,
    preventScroll: () => mergedProps.preventScroll ?? context.modal(),
    contentId,
    titleId,
    descriptionId,
    triggerRef,
    overlayPresence,
    contentPresence,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    setTriggerRef,
    generateId: utils.createGenerateId(() => mergedProps.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(DialogContext.Provider, {
    value: context,
    get children() {
      return mergedProps.children;
    }
  });
}

function DialogTitle(props) {
  const context = useDialogContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTitleId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h2",
    get id() {
      return local.id;
    }
  }, others));
}

function DialogTrigger(props) {
  const context = useDialogContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    get ["data-closed"]() {
      return !context.isOpen() ? "" : undefined;
    },
    onClick: onClick
  }, others));
}

var index$s = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CloseButton: DialogCloseButton,
	Content: DialogContent,
	Description: DialogDescription,
	Overlay: DialogOverlay,
	Portal: DialogPortal,
	Root: DialogRoot,
	Title: DialogTitle,
	Trigger: DialogTrigger
});

function AlertDialogContent(props) {
  return web.createComponent(DialogContent, web.mergeProps({
    role: "alertdialog"
  }, props));
}

var index$r = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CloseButton: DialogCloseButton,
	Content: AlertDialogContent,
	Description: DialogDescription,
	Overlay: DialogOverlay,
	Portal: DialogPortal,
	Root: DialogRoot,
	Title: DialogTitle,
	Trigger: DialogTrigger
});

function LinkRoot(props) {
  let ref;
  const [local, others] = solidJs.splitProps(props, ["ref", "type", "href", "disabled"]);
  const tagName = createTagName(() => ref, () => "a");
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "a",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "a" || local.disabled ? "link" : undefined;
    },
    get tabIndex() {
      return tagName() !== "a" && !local.disabled ? 0 : undefined;
    },
    get href() {
      return !local.disabled ? local.href : undefined;
    },
    get ["aria-disabled"]() {
      return local.disabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    }
  }, others));
}

var index$q = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: LinkRoot
});

function BreadcrumbsLink(props) {
  const [local, others] = solidJs.splitProps(props, ["current", "disabled", "aria-current"]);
  const ariaCurrent = () => {
    if (!local.current) {
      return undefined;
    }
    return local["aria-current"] || "page";
  };
  return web.createComponent(LinkRoot, web.mergeProps({
    get disabled() {
      return local.disabled || local.current;
    },
    get ["aria-current"]() {
      return ariaCurrent();
    },
    get ["data-current"]() {
      return local.current ? "" : undefined;
    }
  }, others));
}

const BreadcrumbsContext = solidJs.createContext();
function useBreadcrumbsContext() {
  const context = solidJs.useContext(BreadcrumbsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useBreadcrumbsContext` must be used within a `Breadcrumbs.Root` component");
  }
  return context;
}

const BREADCRUMBS_INTL_TRANSLATIONS = {
  breadcrumbs: "Breadcrumbs"
};

function BreadcrumbsRoot(props) {
  const mergedProps = utils.mergeDefaultProps({
    separator: "/",
    translations: BREADCRUMBS_INTL_TRANSLATIONS
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["separator", "translations"]);
  const context = {
    separator: () => local.separator
  };
  return web.createComponent(BreadcrumbsContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "nav",
        get ["aria-label"]() {
          return local.translations?.breadcrumbs;
        }
      }, others));
    }
  });
}

function BreadcrumbsSeparator(props) {
  const context = useBreadcrumbsContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    get children() {
      return context.separator();
    },
    "aria-hidden": "true"
  }, props));
}

var index$p = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Link: BreadcrumbsLink,
	Root: BreadcrumbsRoot,
	Separator: BreadcrumbsSeparator
});

function CalendarBody(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, props));
}

const CalendarContext = solidJs.createContext();
function useCalendarContext() {
  const context = solidJs.useContext(CalendarContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarContext` must be used within a `Calendar` component");
  }
  return context;
}

const CalendarGridContext = solidJs.createContext();
function useCalendarGridContext() {
  const context = solidJs.useContext(CalendarGridContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarGridContext` must be used within a `Calendar.Grid` component");
  }
  return context;
}

function constrainStart(date$1, aligned, duration, locale, min, max) {
  let computedDate = aligned;
  if (min && date$1.compare(min) >= 0) {
    computedDate = date.maxDate(computedDate, alignStart(date.toCalendarDate(min), duration, locale));
  }
  if (max && date$1.compare(max) <= 0) {
    computedDate = date.minDate(computedDate, alignEnd(date.toCalendarDate(max), duration, locale));
  }
  return computedDate;
}
function constrainValue(date$1, min, max) {
  let computedDate = date$1;
  if (min) {
    computedDate = date.maxDate(computedDate, date.toCalendarDate(min));
  }
  if (max) {
    computedDate = date.minDate(computedDate, date.toCalendarDate(max));
  }
  return computedDate;
}
function alignStart(date$1, duration, locale, min, max) {
  let aligned = date$1;
  if (duration.years) {
    aligned = date.startOfYear(date$1);
  } else if (duration.months) {
    aligned = date.startOfMonth(date$1);
  } else if (duration.weeks) {
    aligned = date.startOfWeek(date$1, locale);
  }
  return constrainStart(date$1, aligned, duration, locale, min, max);
}
function alignCenter(date, duration, locale, min, max) {
  const halfDuration = {};
  for (const key in duration) {
    halfDuration[key] = Math.floor(duration[key] / 2);
    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignEnd(date, duration, locale, min, max) {
  const d = {
    ...duration
  };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  const aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignDate(date, alignment, duration, locale, min, max) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min, max);
    case "end":
      return alignEnd(date, duration, locale, min, max);
    default:
      return alignCenter(date, duration, locale, min, max);
  }
}
function isDateInvalid(date, minValue, maxValue) {
  return date != null && (minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0);
}
function isPreviousVisibleRangeInvalid(startDate, min, max) {
  const prevDate = startDate.subtract({
    days: 1
  });
  return date.isSameDay(prevDate, startDate) || isDateInvalid(prevDate, min, max);
}
function isNextVisibleRangeInvalid(endDate, min, max) {
  const nextDate = endDate.add({
    days: 1
  });
  return date.isSameDay(nextDate, endDate) || isDateInvalid(nextDate, min, max);
}
function getEndDate(startDate, duration) {
  const d = {
    ...duration
  };
  if (d.days) {
    d.days--;
  } else {
    d.days = -1;
  }
  return startDate.add(d);
}
function getAdjustedDateFn(visibleDuration, locale, min, max) {
  return function getDate(options) {
    const {
      startDate,
      focusedDate
    } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, min, max)) {
      return {
        startDate,
        endDate,
        focusedDate: constrainValue(focusedDate, min, max)
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, min, max),
        endDate,
        focusedDate: constrainValue(focusedDate, min, max)
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, min, max),
        endDate,
        focusedDate: constrainValue(focusedDate, min, max)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, min, max)
    };
  };
}
function getUnitDuration(duration) {
  const unit = {
    ...duration
  };
  for (const key in unit) {
    unit[key] = 1;
  }
  return unit;
}
function getNextUnavailableDate(anchorDate, start, end, isDateUnavailableFn, dir) {
  let nextDate = anchorDate.add({
    days: dir
  });
  while ((dir < 0 ? nextDate.compare(start) >= 0 : nextDate.compare(end) <= 0) && !isDateUnavailableFn(nextDate)) {
    nextDate = nextDate.add({
      days: dir
    });
  }
  if (isDateUnavailableFn(nextDate)) {
    return nextDate.add({
      days: -dir
    });
  }
  return undefined;
}
function getPreviousAvailableDate(date, min, isDateUnavailable) {
  if (!isDateUnavailable) {
    return date;
  }
  while (date.compare(min) >= 0 && isDateUnavailable(date)) {
    date = date.subtract({
      days: 1
    });
  }
  if (date.compare(min) >= 0) {
    return date;
  }
}
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : undefined;
}
function getFirstValueOfSelection(selectionMode, value) {
  let firstValue;
  if (selectionMode === "single") {
    firstValue = asSingleValue(value);
  } else if (selectionMode === "multiple") {
    firstValue = asArrayValue(value)?.[0];
  } else if (selectionMode === "range") {
    const {
      start
    } = asRangeValue(value) ?? {};
    firstValue = start;
  }
  return firstValue;
}
function getArrayValueOfSelection(selectionMode, value) {
  let values = [];
  if (selectionMode === "single") {
    values = [asSingleValue(value)];
  } else if (selectionMode === "multiple") {
    values = asArrayValue(value) ?? [];
  } else if (selectionMode === "range") {
    const {
      start,
      end
    } = asRangeValue(value) ?? {};
    values = [start, end];
  }
  return values.filter(Boolean);
}
function formatRange(dateFormatter, translations, start, end, timeZone) {
  const parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let startValue = "";
  let endValue = "";
  for (let i = 0; i < parts.length; i++) {
    if (i < separatorIndex) {
      startValue += parts[i].value;
    } else if (i > separatorIndex) {
      endValue += parts[i].value;
    }
  }
  return translations.dateRange(startValue, endValue);
}
function getSelectedDateDescription(translations, value, timeZone) {
  const dateFormatter = createDateFormatter(() => ({
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(value),
    timeZone: timeZone
  }));
  return translations.selectedDateDescription(dateFormatter().format(value.toDate(timeZone)));
}
function getSelectedDateRangeDescription(translations, highlightedRange, anchorDate, timeZone) {
  const start = highlightedRange.start;
  const end = highlightedRange.end;
  if (!anchorDate && start && end) {
    const dateFormatter = createDateFormatter(() => ({
      weekday: "long",
      month: "long",
      year: "numeric",
      day: "numeric",
      era: getEraFormat(start) || getEraFormat(end),
      timeZone: timeZone
    }));
    if (date.isSameDay(start, end)) {
      const date = dateFormatter().format(start.toDate(timeZone));
      return translations.selectedDateDescription(date);
    }
    const dateRange = formatRange(dateFormatter(), translations, start, end, timeZone);
    return translations.selectedRangeDescription(dateRange);
  }
  return "";
}
function getVisibleRangeDescription(translations, startDate, endDate, timeZone, isAria) {
  const era = getEraFormat(startDate) || getEraFormat(endDate);
  const monthFormatter = createDateFormatter(() => ({
    month: "long",
    year: "numeric",
    era,
    calendar: startDate.calendar.identifier,
    timeZone
  }));
  const dateFormatter = createDateFormatter(() => ({
    month: "long",
    year: "numeric",
    day: "numeric",
    era,
    calendar: startDate.calendar.identifier,
    timeZone
  }));
  if (date.isSameDay(startDate, date.startOfMonth(startDate))) {
    if (date.isSameDay(endDate, date.endOfMonth(startDate))) {
      return monthFormatter().format(startDate.toDate(timeZone));
    }
    if (date.isSameDay(endDate, date.endOfMonth(endDate))) {
      if (isAria) {
        return formatRange(monthFormatter(), translations, startDate, endDate, timeZone);
      }
      return monthFormatter().formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));
    }
  }
  if (isAria) {
    return formatRange(dateFormatter(), translations, startDate, endDate, timeZone);
  }
  return dateFormatter().formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(constrainStart(focusedDate, start, visibleDuration, locale, min, max), visibleDuration, locale)
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  const start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(constrainStart(focusedDate, start, visibleDuration, locale, min, max), visibleDuration, locale)
  });
}
function getNextRow(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({
        weeks: 1
      }),
      startDate
    });
  }
}
function getPreviousRow(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({
        weeks: 1
      }),
      startDate
    });
  }
}
function getSectionStart(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: startDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: date.startOfWeek(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: date.startOfMonth(focusedDate),
      startDate
    });
  }
}
function getSectionEnd(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  const endDate = getEndDate(startDate, visibleDuration);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: endDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: date.endOfWeek(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: date.endOfMonth(focusedDate),
      startDate
    });
  }
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({
        months: 1
      }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({
        years: 1
      }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({
        months: 1
      }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({
        years: 1
      }),
      startDate
    });
  }
}
function asSingleValue(value) {
  return value;
}
function asArrayValue(value) {
  return value;
}
function asRangeValue(value) {
  return value;
}
function sortDates(values) {
  return values.sort((a, b) => a.compare(b));
}
function makeCalendarDateRange(start, end) {
  if (!start || !end) {
    return undefined;
  }
  if (end.compare(start) < 0) {
    [start, end] = [end, start];
  }
  return {
    start: date.toCalendarDate(start),
    end: date.toCalendarDate(end)
  };
}

function CalendarGrid(props) {
  const rootContext = useCalendarContext();
  const mergedProps = utils.mergeDefaultProps({
    weekDayFormat: "short"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["offset", "weekDayFormat", "onKeyDown", "onFocusIn", "onFocusOut", "aria-label"]);
  const startDate = solidJs.createMemo(() => {
    if (local.offset) {
      return rootContext.startDate().add(local.offset);
    }
    return rootContext.startDate();
  });
  const endDate = solidJs.createMemo(() => date.endOfMonth(startDate()));
  const dayFormatter = createDateFormatter(() => ({
    weekday: local.weekDayFormat,
    timeZone: rootContext.timeZone()
  }));
  const weekDays = solidJs.createMemo(() => {
    const firstDayOfWeek = date.startOfWeek(date.today(rootContext.timeZone()), rootContext.locale());
    return [...new Array(7).keys()].map(index => {
      const date = firstDayOfWeek.add({
        days: index
      });
      return dayFormatter().format(date.toDate(rootContext.timeZone()));
    });
  });
  const visibleRangeDescription = solidJs.createMemo(() => {
    return getVisibleRangeDescription(rootContext.translations(), startDate(), endDate(), rootContext.timeZone(), true);
  });
  const ariaLabel = () => {
    return [local["aria-label"], visibleRangeDescription()].filter(Boolean).join(", ");
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    switch (e.key) {
      case "Enter":
      case " ":
        e.preventDefault();
        rootContext.selectFocusedDate();
        break;
      case "PageUp":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusPreviousSection(e.shiftKey);
        break;
      case "PageDown":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusNextSection(e.shiftKey);
        break;
      case "End":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusSectionEnd();
        break;
      case "Home":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusSectionStart();
        break;
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        if (rootContext.direction() === "rtl") {
          rootContext.focusNextDay();
        } else {
          rootContext.focusPreviousDay();
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusPreviousRow();
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        if (rootContext.direction() === "rtl") {
          rootContext.focusPreviousDay();
        } else {
          rootContext.focusNextDay();
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusNextRow();
        break;
      case "Escape":
        if (rootContext.selectionMode() === "range") {
          e.preventDefault();
          rootContext.setAnchorDate(undefined);
        }
        break;
    }
  };
  const onFocusIn = e => {
    utils.callHandler(e, local.onFocusIn);
    rootContext.setIsFocused(true);
  };
  const onFocusOut = e => {
    utils.callHandler(e, local.onFocusOut);
    rootContext.setIsFocused(false);
  };
  const context = {
    startDate,
    weekDays
  };
  return web.createComponent(CalendarGridContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "table",
        role: "grid",
        get ["aria-readonly"]() {
          return rootContext.isReadOnly() || undefined;
        },
        get ["aria-disabled"]() {
          return rootContext.isDisabled() || undefined;
        },
        get ["aria-multiselectable"]() {
          return rootContext.selectionMode() !== "single";
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        onKeyDown: onKeyDown,
        onFocusIn: onFocusIn,
        onFocusOut: onFocusOut
      }, others));
    }
  });
}

function CalendarGridBody(props) {
  const rootContext = useCalendarContext();
  const context = useCalendarGridContext();
  const [local, others] = solidJs.splitProps(props, ["children"]);
  const weekIndexes = solidJs.createMemo(() => {
    const weeksInMonth = date.getWeeksInMonth(context.startDate(), rootContext.locale());
    return [...new Array(weeksInMonth).keys()];
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "tbody"
  }, others, {
    get children() {
      return web.createComponent(solidJs.Index, {
        get each() {
          return weekIndexes();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}

const CalendarGridBodyCellContext = solidJs.createContext();
function useCalendarGriBodyCellContext() {
  const context = solidJs.useContext(CalendarGridBodyCellContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarGriBodyCellContext` must be used within a `Calendar.GridBodyCell` component");
  }
  return context;
}

function CalendarGridBodyCell(props) {
  const rootContext = useCalendarContext();
  const [local, others] = solidJs.splitProps(props, ["date", "disabled"]);
  const isSelected = solidJs.createMemo(() => {
    return rootContext.isCellSelected(local.date);
  });
  const isFocused = solidJs.createMemo(() => {
    return rootContext.isCellFocused(local.date);
  });
  const isDisabled = solidJs.createMemo(() => {
    return local.disabled || rootContext.isCellDisabled(local.date);
  });
  const isUnavailable = solidJs.createMemo(() => {
    return rootContext.isCellUnavailable(local.date);
  });
  const isSelectable = () => {
    return !rootContext.isReadOnly() && !isDisabled() && !isUnavailable();
  };
  const isInvalid = solidJs.createMemo(() => {
    return rootContext.validationState() === "invalid" && isSelected();
  });
  const isDateToday = () => date.isToday(local.date, rootContext.timeZone());
  const context = {
    date: () => local.date,
    isSelected,
    isFocused,
    isUnavailable,
    isSelectable,
    isDisabled,
    isInvalid,
    isDateToday
  };
  return web.createComponent(CalendarGridBodyCellContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "td",
        role: "gridcell",
        get ["aria-disabled"]() {
          return !isSelectable() || undefined;
        },
        get ["aria-selected"]() {
          return isSelected() || undefined;
        },
        get ["aria-invalid"]() {
          return isInvalid() || undefined;
        },
        get ["aria-current"]() {
          return isDateToday() ? "date" : undefined;
        },
        get ["data-value"]() {
          return local.date.toString();
        }
      }, others));
    }
  });
}

function CalendarGridBodyCellTrigger(props) {
  let ref;
  const rootContext = useCalendarContext();
  const gridContext = useCalendarGridContext();
  const context = useCalendarGriBodyCellContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "disabled", "onPointerEnter", "onPointerDown", "onPointerUp", "onPointerLeave", "onClick", "onKeyDown"]);
  const isDisabled = () => local.disabled || context.isDisabled();
  const isDateWeekend = () => {
    return date.isWeekend(context.date(), rootContext.locale());
  };
  const isOutsideVisibleRange = () => {
    return context.date().compare(rootContext.startDate()) < 0 || context.date().compare(rootContext.endDate()) > 0;
  };
  const isOutsideMonth = () => {
    return !date.isSameMonth(gridContext.startDate(), context.date());
  };
  const isSelectionStart = () => {
    if (rootContext.selectionMode() !== "range") {
      return false;
    }
    const start = rootContext.highlightedRange()?.start;
    return start != null && date.isSameDay(context.date(), start);
  };
  const isSelectionEnd = () => {
    if (rootContext.selectionMode() !== "range") {
      return false;
    }
    const end = rootContext.highlightedRange()?.end;
    return end != null && date.isSameDay(context.date(), end);
  };
  const tabIndex = solidJs.createMemo(() => {
    if (!isDisabled()) {
      return date.isSameDay(context.date(), rootContext.focusedDate()) ? 0 : -1;
    }
    return undefined;
  });
  const labelDateFormatter = createDateFormatter(() => ({
    weekday: "long",
    day: "numeric",
    month: "long",
    year: "numeric",
    era: getEraFormat(context.date()),
    timeZone: rootContext.timeZone()
  }));
  const cellDateFormatter = createDateFormatter(() => ({
    day: "numeric",
    timeZone: rootContext.timeZone(),
    calendar: context.date().calendar.identifier
  }));
  const nativeDate = solidJs.createMemo(() => {
    return context.date().toDate(rootContext.timeZone());
  });
  const formattedDate = solidJs.createMemo(() => {
    return cellDateFormatter().formatToParts(nativeDate()).find(part => part.type === "day")?.value;
  });
  const ariaLabel = solidJs.createMemo(() => {
    let label = "";
    if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
      const {
        start,
        end
      } = asRangeValue(rootContext.value()) ?? {};
      if (start && end && (date.isSameDay(context.date(), start) || date.isSameDay(context.date(), end))) {
        label = `${getSelectedDateDescription(rootContext.translations(), context.date(), rootContext.timeZone())}, `;
      }
    }
    label += labelDateFormatter().format(nativeDate());
    if (context.isDateToday()) {
      label = rootContext.translations().todayDate(label, context.isSelected());
    } else if (context.isSelected()) {
      label = rootContext.translations().dateSelected(label);
    }
    const min = rootContext.min();
    const max = rootContext.max();
    if (min && date.isSameDay(context.date(), min)) {
      label += `, ${rootContext.translations().minimumDate}`;
    } else if (max && date.isSameDay(context.date(), max)) {
      label += `, ${rootContext.translations().maximumDate}`;
    }
    return label;
  });
  let isPointerDown = false;
  let isAnchorPressed = false;
  let isRangeBoundaryPressed = false;
  let touchDragTimerRef;
  const onPressEnd = () => {
    isRangeBoundaryPressed = false;
    isAnchorPressed = false;
    if (touchDragTimerRef != null) {
      utils.getWindow(ref).clearTimeout(touchDragTimerRef);
      touchDragTimerRef = undefined;
    }
  };
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (rootContext.selectionMode() === "range" && (e.pointerType !== "touch" || rootContext.isDragging()) && context.isSelectable()) {
      rootContext.highlightDate(context.date());
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (isPointerDown) {
      onPressEnd();
    }
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    isPointerDown = true;
    if ("releasePointerCapture" in e.target) {
      e.target.releasePointerCapture(e.pointerId);
    }
    if (rootContext.isReadOnly()) {
      rootContext.focusCell(context.date());
      return;
    }
    if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
      const highlightedRange = rootContext.highlightedRange();
      if (highlightedRange && !context.isInvalid()) {
        if (date.isSameDay(context.date(), highlightedRange.start)) {
          rootContext.setAnchorDate(highlightedRange.end);
          rootContext.focusCell(context.date());
          rootContext.setIsDragging(true);
          isRangeBoundaryPressed = true;
          return;
        }
        if (date.isSameDay(context.date(), highlightedRange.end)) {
          rootContext.setAnchorDate(highlightedRange.start);
          rootContext.focusCell(context.date());
          rootContext.setIsDragging(true);
          isRangeBoundaryPressed = true;
          return;
        }
      }
      const startDragging = () => {
        rootContext.setIsDragging(true);
        touchDragTimerRef = undefined;
        rootContext.selectDate(context.date());
        rootContext.focusCell(context.date());
        isAnchorPressed = true;
      };
      if (e.pointerType === "touch") {
        touchDragTimerRef = utils.getWindow(ref).setTimeout(startDragging, 200);
      } else {
        startDragging();
      }
    }
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    isPointerDown = false;
    if (rootContext.isReadOnly() || rootContext.selectionMode() !== "range") {
      onPressEnd();
      return;
    }
    if (touchDragTimerRef != null) {
      rootContext.selectDate(context.date());
      rootContext.focusCell(context.date());
    }
    if (isRangeBoundaryPressed) {
      rootContext.setAnchorDate(context.date());
    } else if (rootContext.anchorDate() && !isAnchorPressed) {
      rootContext.selectDate(context.date());
      rootContext.focusCell(context.date());
    }
    onPressEnd();
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (rootContext.selectionMode() !== "range" && context.isSelectable()) {
      rootContext.selectDate(context.date());
      rootContext.focusCell(context.date());
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (!["Enter", " "].includes(e.key)) {
      return;
    }
    if (rootContext.isReadOnly()) {
      rootContext.focusCell(context.date());
      return;
    }
    if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
      e.stopPropagation();
      rootContext.selectDate(context.date());
      let nextDay = context.date().add({
        days: 1
      });
      if (rootContext.isCellInvalid(nextDay)) {
        nextDay = context.date().subtract({
          days: 1
        });
      }
      if (!rootContext.isCellInvalid(nextDay)) {
        rootContext.focusCell(nextDay);
      }
    }
  };
  solidJs.createEffect(() => {
    if (ref && context.isFocused()) {
      utils.focusWithoutScrolling(ref);
    }
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "button",
    get tabIndex() {
      return tabIndex();
    },
    get disabled() {
      return isDisabled();
    },
    get ["aria-disabled"]() {
      return !context.isSelectable() || undefined;
    },
    get ["aria-invalid"]() {
      return context.isInvalid() || undefined;
    },
    get ["aria-label"]() {
      return ariaLabel();
    },
    get ["data-disabled"]() {
      return isDisabled() || undefined;
    },
    get ["data-invalid"]() {
      return context.isInvalid() || undefined;
    },
    get ["data-selected"]() {
      return context.isSelected() || undefined;
    },
    get ["data-value"]() {
      return context.date().toString();
    },
    "data-type": "day",
    get ["data-today"]() {
      return context.isDateToday() || undefined;
    },
    get ["data-weekend"]() {
      return isDateWeekend() || undefined;
    },
    get ["data-highlighted"]() {
      return context.isFocused() || undefined;
    },
    get ["data-unavailable"]() {
      return context.isUnavailable() || undefined;
    },
    get ["data-selection-start"]() {
      return isSelectionStart() || undefined;
    },
    get ["data-selection-end"]() {
      return isSelectionEnd() || undefined;
    },
    get ["data-outside-visible-range"]() {
      return isOutsideVisibleRange() || undefined;
    },
    get ["data-outside-month"]() {
      return isOutsideMonth() || undefined;
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onPointerDown: onPointerDown,
    onPointerUp: onPointerUp,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onContextMenu: e => {
      e.preventDefault();
    }
  }, others, {
    get children() {
      return formattedDate();
    }
  }));
}

function CalendarGridBodyRow(props) {
  const rootContext = useCalendarContext();
  const context = useCalendarGridContext();
  const [local, others] = solidJs.splitProps(props, ["weekIndex", "children"]);
  const datesInWeek = solidJs.createMemo(() => {
    return rootContext.getDatesInWeek(local.weekIndex, context.startDate());
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "tr"
  }, others, {
    get children() {
      return web.createComponent(solidJs.Index, {
        get each() {
          return datesInWeek();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}

function CalendarGridHeader(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "thead",
    "aria-hidden": "true"
  }, props));
}

function CalendarGridHeaderCell(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "th"
  }, props));
}

function CalendarGridHeaderRow(props) {
  const [local, others] = solidJs.splitProps(props, ["children"]);
  const context = useCalendarGridContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "tr"
  }, others, {
    get children() {
      return web.createComponent(solidJs.Index, {
        get each() {
          return context.weekDays();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}

function CalendarHeader(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "header"
  }, props));
}

function CalendarHeading(props) {
  const rootContext = useCalendarContext();
  const title = solidJs.createMemo(() => {
    return getVisibleRangeDescription(rootContext.translations(), rootContext.startDate(), rootContext.endDate(), rootContext.timeZone(), false);
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h2"
  }, props, {
    get children() {
      return title();
    }
  }));
}

function CalendarNextTrigger(props) {
  const context = useCalendarContext();
  const [local, others] = solidJs.splitProps(props, ["disabled", "onClick", "onFocus", "onBlur"]);
  let nextTriggerFocused = false;
  const nextTriggerDisabled = solidJs.createMemo(() => {
    return local.disabled || context.isDisabled() || isNextVisibleRangeInvalid(context.endDate(), context.min(), context.max());
  });
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.focusNextPage();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    nextTriggerFocused = true;
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    nextTriggerFocused = false;
  };
  solidJs.createEffect(() => {
    if (nextTriggerDisabled() && nextTriggerFocused) {
      nextTriggerFocused = false;
      context.setIsFocused(true);
    }
  });
  return web.createComponent(ButtonRoot, web.mergeProps({
    get disabled() {
      return nextTriggerDisabled();
    },
    get ["aria-label"]() {
      return context.translations().next;
    },
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
}

function CalendarPrevTrigger(props) {
  const context = useCalendarContext();
  const [local, others] = solidJs.splitProps(props, ["disabled", "onClick", "onFocus", "onBlur"]);
  let prevTriggerFocused = false;
  const prevTriggerDisabled = solidJs.createMemo(() => {
    return local.disabled || context.isDisabled() || isPreviousVisibleRangeInvalid(context.startDate(), context.min(), context.max());
  });
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.focusPreviousPage();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    prevTriggerFocused = true;
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    prevTriggerFocused = false;
  };
  solidJs.createEffect(() => {
    if (prevTriggerDisabled() && prevTriggerFocused) {
      prevTriggerFocused = false;
      context.setIsFocused(true);
    }
  });
  return web.createComponent(ButtonRoot, web.mergeProps({
    get disabled() {
      return prevTriggerDisabled();
    },
    get ["aria-label"]() {
      return context.translations().previous;
    },
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
}

const CALENDAR_INTL_MESSAGES = {
  previous: "Previous",
  next: "Next",
  selectedDateDescription: date => `Selected Date: ${date}`,
  selectedRangeDescription: dateRange => `Selected Range: ${dateRange}`,
  todayDate: (date, isSelected) => `Today, ${date} ${isSelected ? " selected" : ""}`,
  dateSelected: date => `${date} selected`,
  startRangeSelectionPrompt: "Click to start selecting date range",
  finishRangeSelectionPrompt: "Click to finish selecting date range",
  minimumDate: "First available date",
  maximumDate: "Last available date",
  dateRange: (startDate, endDate) => `${startDate} to ${endDate}`
};

function CalendarRoot(props) {
  let ref;
  const mergedProps = utils.mergeDefaultProps({
    visibleDuration: {
      months: 1
    },
    selectionMode: "single",
    translations: CALENDAR_INTL_MESSAGES
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["translations", "ref", "locale", "createCalendar", "visibleDuration", "selectionAlignment", "selectionMode", "value", "defaultValue", "onChange", "minValue", "maxValue", "isDateUnavailable", "allowsNonContiguousRanges", "autoFocus", "focusedValue", "defaultFocusedValue", "onFocusChange", "validationState", "disabled", "readOnly", "aria-label"]);
  const locale = solidJs.createMemo(() => {
    return local.locale ?? useLocale().locale();
  });
  const resolvedOptions = solidJs.createMemo(() => {
    return new date.DateFormatter(locale()).resolvedOptions();
  });
  const direction = solidJs.createMemo(() => {
    return getReadingDirection(locale());
  });
  const calendar = solidJs.createMemo(() => {
    return local.createCalendar(resolvedOptions().calendar);
  });
  const [value, setControlledValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const [availableRange, setAvailableRange] = solidJs.createSignal();
  const selectionAlignment = solidJs.createMemo(() => {
    if (local.selectionMode === "range") {
      const valueRange = asRangeValue(value());
      if (valueRange?.start && valueRange.end) {
        const start = alignCenter(date.toCalendarDate(valueRange.start), local.visibleDuration, locale(), local.minValue, local.maxValue);
        const end = start.add(local.visibleDuration).subtract({
          days: 1
        });
        if (valueRange.end.compare(end) > 0) {
          return "start";
        }
      }
      return "center";
    }
    return local.selectionAlignment ?? "center";
  });
  const min = solidJs.createMemo(() => {
    const startRange = availableRange()?.start;
    if (local.selectionMode === "range" && local.minValue && startRange) {
      return date.maxDate(local.minValue, startRange);
    }
    return local.minValue;
  });
  const max = solidJs.createMemo(() => {
    const endRange = availableRange()?.end;
    if (local.selectionMode === "range" && local.maxValue && endRange) {
      return date.minDate(local.maxValue, endRange);
    }
    return local.maxValue;
  });
  const calendarDateValue = solidJs.createMemo(() => {
    return getArrayValueOfSelection(local.selectionMode, value()).map(date$1 => date.toCalendar(date.toCalendarDate(date$1), calendar()));
  });
  const timeZone = solidJs.createMemo(() => {
    const firstValue = getFirstValueOfSelection(local.selectionMode, value());
    if (firstValue && "timeZone" in firstValue) {
      return firstValue.timeZone;
    }
    return resolvedOptions().timeZone;
  });
  const focusedCalendarDate = solidJs.createMemo(() => {
    if (local.focusedValue) {
      return constrainValue(date.toCalendar(date.toCalendarDate(local.focusedValue), calendar()), min(), max());
    }
    return undefined;
  });
  const defaultFocusedCalendarDate = solidJs.createMemo(() => {
    return constrainValue(local.defaultFocusedValue ? date.toCalendar(date.toCalendarDate(local.defaultFocusedValue), calendar()) : calendarDateValue()[0] || date.toCalendar(date.today(timeZone()), calendar()), min(), max());
  });
  const [focusedDate, setFocusedDate] = createControllableSignal({
    value: focusedCalendarDate,
    defaultValue: defaultFocusedCalendarDate,
    onChange: value => local.onFocusChange?.(value)
  });
  const [startDate, setStartDate] = solidJs.createSignal(alignDate(focusedDate(), selectionAlignment(), local.visibleDuration, locale(), min(), max()));
  const endDate = solidJs.createMemo(() => {
    return getEndDate(startDate(), local.visibleDuration);
  });
  const [isFocused, setIsFocused] = solidJs.createSignal(local.autoFocus || false);
  const [isDragging, setIsDragging] = solidJs.createSignal(false);
  const visibleRangeDescription = solidJs.createMemo(() => {
    return getVisibleRangeDescription(local.translations, startDate(), endDate(), timeZone(), true);
  });
  const ariaLabel = () => {
    return [local["aria-label"], visibleRangeDescription()].filter(Boolean).join(", ");
  };
  const isCellDisabled = date => {
    return local.disabled || date.compare(startDate()) < 0 || date.compare(endDate()) > 0 || isDateInvalid(date, min(), max());
  };
  const isCellUnavailable = date => {
    return local.isDateUnavailable?.(date) ?? false;
  };
  const updateAvailableRange = date => {
    if (date && local.isDateUnavailable && !local.allowsNonContiguousRanges) {
      setAvailableRange({
        start: getNextUnavailableDate(date, startDate(), endDate(), isCellUnavailable, -1),
        end: getNextUnavailableDate(date, startDate(), endDate(), isCellUnavailable, 1)
      });
    } else {
      setAvailableRange(undefined);
    }
  };
  const [anchorDate, setAnchorDate] = createControllableSignal({
    onChange: value => updateAvailableRange(value)
  });
  const highlightedRange = solidJs.createMemo(() => {
    if (local.selectionMode !== "range") {
      return undefined;
    }
    const resolvedAnchorDate = anchorDate();
    if (resolvedAnchorDate) {
      return makeCalendarDateRange(resolvedAnchorDate, focusedDate());
    }
    const {
      start,
      end
    } = asRangeValue(value()) ?? {};
    return makeCalendarDateRange(start, end);
  });
  const validationState = solidJs.createMemo(() => {
    if (local.validationState) {
      return local.validationState;
    }
    if (calendarDateValue().length <= 0) {
      return null;
    }
    if (local.selectionMode === "range" && anchorDate()) {
      return null;
    }
    const isSomeDateInvalid = calendarDateValue().some(date => {
      return local.isDateUnavailable?.(date) || isDateInvalid(date, min(), max());
    });
    return isSomeDateInvalid ? "invalid" : null;
  });
  const isCellSelected = cellDate => {
    const isAvailable = !isCellDisabled(cellDate) && !isCellUnavailable(cellDate);
    if (local.selectionMode === "range") {
      const {
        start,
        end
      } = highlightedRange() ?? {};
      const isInRange = start != null && cellDate.compare(start) >= 0 && end != null && cellDate.compare(end) <= 0;
      return isInRange && isAvailable;
    }
    return calendarDateValue().some(date$1 => date.isSameDay(cellDate, date$1)) && isAvailable;
  };
  const isCellFocused = date$1 => {
    const resolvedFocusedDate = focusedDate();
    return isFocused() && resolvedFocusedDate != null && date.isSameDay(date$1, resolvedFocusedDate);
  };
  const isCellInvalid = date => {
    if (local.selectionMode === "range") {
      return isDateInvalid(date, min(), max()) || isDateInvalid(date, availableRange()?.start, availableRange()?.end);
    }
    return isDateInvalid(date, min(), max());
  };
  const selectDate = date$1 => {
    if (local.readOnly || local.disabled) {
      return;
    }
    let newValue = getPreviousAvailableDate(constrainValue(date$1, min(), max()), startDate(), local.isDateUnavailable);
    if (!newValue) {
      return;
    }
    if (local.selectionMode === "single") {
      setControlledValue(prev => {
        const prevValue = asSingleValue(prev);
        if (!newValue) {
          return prevValue;
        }
        return convertValue$1(newValue, prevValue);
      });
    } else if (local.selectionMode === "multiple") {
      setControlledValue(prev => {
        const prevValue = asArrayValue(prev) ?? [];
        if (!newValue) {
          return prevValue;
        }
        newValue = convertValue$1(newValue, prevValue[0]);
        const index = prevValue.findIndex(date$1 => newValue != null && date.isSameDay(date$1, newValue));
        if (index !== -1) {
          const nextValues = [...prevValue];
          nextValues.splice(index, 1);
          return sortDates(nextValues);
        }
        return sortDates([...prevValue, newValue]);
      });
    } else if (local.selectionMode === "range") {
      if (!anchorDate()) {
        setAnchorDate(newValue);
      } else {
        setControlledValue(prev => {
          const prevRange = asRangeValue(prev);
          const range = makeCalendarDateRange(anchorDate(), newValue);
          if (!range) {
            return prevRange;
          }
          return {
            start: convertValue$1(range.start, prevRange?.start),
            end: convertValue$1(range.end, prevRange?.end)
          };
        });
        setAnchorDate(undefined);
      }
    }
  };
  const selectFocusedDate = () => {
    selectDate(focusedDate());
  };
  const focusCell = date => {
    setFocusedDate(constrainValue(date, min(), max()));
    if (!isFocused()) {
      setIsFocused(true);
    }
  };
  const highlightDate = date => {
    if (anchorDate()) {
      focusCell(date);
    }
  };
  const focusNextDay = () => {
    focusCell(focusedDate().add({
      days: 1
    }));
  };
  const focusPreviousDay = () => {
    focusCell(focusedDate().subtract({
      days: 1
    }));
  };
  const focusNextRow = () => {
    const row = getNextRow(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (row) {
      setStartDate(row.startDate);
      focusCell(row.focusedDate);
    }
  };
  const focusPreviousRow = () => {
    const row = getPreviousRow(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (row) {
      setStartDate(row.startDate);
      focusCell(row.focusedDate);
    }
  };
  const focusNextPage = () => {
    const page = getNextPage(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    setFocusedDate(constrainValue(page.focusedDate, min(), max()));
    setStartDate(page.startDate);
  };
  const focusPreviousPage = () => {
    const page = getPreviousPage(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    setFocusedDate(constrainValue(page.focusedDate, min(), max()));
    setStartDate(page.startDate);
  };
  const focusSectionStart = () => {
    const section = getSectionStart(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const focusSectionEnd = () => {
    const section = getSectionEnd(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const focusNextSection = larger => {
    const section = getNextSection(focusedDate(), startDate(), larger, local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const focusPreviousSection = larger => {
    const section = getPreviousSection(focusedDate(), startDate(), larger, local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const getDatesInWeek = (weekIndex, from) => {
    let date$1 = from.add({
      weeks: weekIndex
    });
    const dates = [];
    date$1 = date.startOfWeek(date$1, locale());
    const dayOfWeek = date.getDayOfWeek(date$1, locale());
    for (let i = 0; i < dayOfWeek; i++) {
      dates.push(null);
    }
    while (dates.length < 7) {
      dates.push(date$1);
      const nextDate = date$1.add({
        days: 1
      });
      if (date.isSameDay(date$1, nextDate)) {
        break;
      }
      date$1 = nextDate;
    }
    while (dates.length < 7) {
      dates.push(null);
    }
    return dates;
  };
  createInteractOutside({
    onInteractOutside: e => {
      if (local.selectionMode === "range" && anchorDate()) {
        selectFocusedDate();
      }
    }
  }, () => ref);
  let lastCalendarIdentifier = calendar().identifier;
  solidJs.createEffect(solidJs.on(calendar, calendar => {
    if (calendar.identifier !== lastCalendarIdentifier) {
      const newFocusedDate = date.toCalendar(focusedDate(), calendar);
      setStartDate(alignCenter(newFocusedDate, local.visibleDuration, locale(), min(), max()));
      setFocusedDate(newFocusedDate);
      lastCalendarIdentifier = calendar.identifier;
    }
  }));
  solidJs.createEffect(() => {
    const adjust = getAdjustedDateFn(local.visibleDuration, locale(), min(), max());
    const adjustment = adjust({
      startDate: startDate(),
      focusedDate: focusedDate()
    });
    setStartDate(adjustment.startDate);
    setFocusedDate(adjustment.focusedDate);
  });
  solidJs.createEffect(() => {
    if (!isFocused()) {
      announce(visibleRangeDescription());
    }
  });
  solidJs.createEffect(() => {
    let description;
    if (local.selectionMode === "single") {
      const date = asSingleValue(value());
      description = date && getSelectedDateDescription(local.translations, date, timeZone());
    } else if (local.selectionMode === "multiple") {
      const dates = asArrayValue(value());
      description = dates?.map(date => getSelectedDateDescription(local.translations, date, timeZone())).join(", ");
    } else if (local.selectionMode === "range") {
      const dateRange = asRangeValue(value()) ?? {};
      description = getSelectedDateRangeDescription(local.translations, dateRange, anchorDate(), timeZone());
    }
    if (description) {
      announce(description, "polite", 4000);
    }
  });
  solidJs.createEffect(solidJs.on([startDate, endDate], () => {
    if (local.selectionMode === "range") {
      updateAvailableRange(anchorDate());
    }
  }));
  let isVirtualClick = false;
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    if (local.selectionMode !== "range" || !ref) {
      return;
    }
    const win = utils.getWindow(ref);
    const doc = utils.getDocument(ref);
    const onWindowPointerDown = e => {
      isVirtualClick = e.width === 0 && e.height === 0;
    };
    const endDragging = e => {
      if (isVirtualClick) {
        isVirtualClick = false;
        return;
      }
      setIsDragging(false);
      if (!anchorDate()) {
        return;
      }
      const target = e.target;
      if (utils.contains(ref, doc.activeElement) && (!utils.contains(ref, target) || !target.closest('button, [role="button"]'))) {
        selectFocusedDate();
      }
    };
    const onTouchMove = e => {
      if (isDragging()) {
        e.preventDefault();
      }
    };
    win.addEventListener("pointerdown", onWindowPointerDown);
    win.addEventListener("pointerup", endDragging);
    win.addEventListener("pointercancel", endDragging);
    ref.addEventListener("touchmove", onTouchMove, {
      passive: false,
      capture: true
    });
    solidJs.onCleanup(() => {
      win.removeEventListener("pointerdown", onWindowPointerDown);
      win.removeEventListener("pointerup", endDragging);
      win.removeEventListener("pointercancel", endDragging);
      ref?.removeEventListener("touchmove", onTouchMove, {
        capture: true
      });
    });
  });
  const dataset = solidJs.createMemo(() => ({}));
  const context = {
    dataset,
    value,
    isDisabled: () => local.disabled ?? false,
    isReadOnly: () => local.readOnly ?? false,
    isDragging,
    isCellUnavailable,
    isCellDisabled,
    isCellSelected,
    isCellFocused,
    isCellInvalid,
    validationState,
    startDate,
    endDate,
    anchorDate,
    focusedDate: () => focusedDate(),
    visibleDuration: () => local.visibleDuration,
    selectionMode: () => local.selectionMode,
    locale,
    highlightedRange,
    direction,
    min,
    max,
    timeZone,
    translations: () => local.translations,
    setStartDate,
    setAnchorDate,
    setIsFocused,
    setIsDragging,
    selectFocusedDate,
    selectDate,
    highlightDate,
    focusCell,
    focusNextDay,
    focusPreviousDay,
    focusNextPage,
    focusPreviousPage,
    focusNextRow,
    focusPreviousRow,
    focusSectionStart,
    focusSectionEnd,
    focusNextSection,
    focusPreviousSection,
    getDatesInWeek
  };
  return web.createComponent(CalendarContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        as: "div",
        role: "group",
        get ["aria-label"]() {
          return ariaLabel();
        }
      }, others));
    }
  });
}
function convertValue$1(newValue, oldValue) {
  newValue = date.toCalendar(newValue, oldValue?.calendar || new date.GregorianCalendar());
  if (oldValue && "hour" in oldValue) {
    return oldValue.set(newValue);
  }
  return newValue;
}

var index$o = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Body: CalendarBody,
	Grid: CalendarGrid,
	GridBody: CalendarGridBody,
	GridBodyCell: CalendarGridBodyCell,
	GridBodyCellTrigger: CalendarGridBodyCellTrigger,
	GridBodyRow: CalendarGridBodyRow,
	GridHeader: CalendarGridHeader,
	GridHeaderCell: CalendarGridHeaderCell,
	GridHeaderRow: CalendarGridHeaderRow,
	Header: CalendarHeader,
	Heading: CalendarHeading,
	NextTrigger: CalendarNextTrigger,
	PrevTrigger: CalendarPrevTrigger,
	Root: CalendarRoot
});

const CheckboxContext = solidJs.createContext();
function useCheckboxContext() {
  const context = solidJs.useContext(CheckboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCheckboxContext` must be used within a `Checkbox` component");
  }
  return context;
}

function CheckboxControl(props) {
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["onClick", "onKeyDown"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === utils.EventKey.Space) {
      context.toggle();
      context.inputRef()?.focus();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => formControlContext.dataset(), () => context.dataset(), others));
}

function CheckboxDescription(props) {
  const context = useCheckboxContext();
  return web.createComponent(FormControlDescription, web.mergeProps(() => context.dataset(), props));
}

function CheckboxErrorMessage(props) {
  const context = useCheckboxContext();
  return web.createComponent(FormControlErrorMessage, web.mergeProps(() => context.dataset(), props));
}

function CheckboxIndicator(props) {
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "forceMount"]);
  const presence = createPresence(() => local.forceMount || context.indeterminate() || context.checked());
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, () => formControlContext.dataset(), () => context.dataset(), others));
    }
  });
}

const _tmpl$$h = /*#__PURE__*/web.template(`<input type="checkbox">`);
function CheckboxInput(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "style", "onChange", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const [isInternalChangeEvent, setIsInternalChangeEvent] = solidJs.createSignal(false);
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    e.stopPropagation();
    if (!isInternalChangeEvent()) {
      const target = e.target;
      context.setIsChecked(target.checked);
      target.checked = context.checked();
    }
    setIsInternalChangeEvent(false);
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    context.setIsFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.setIsFocused(false);
  };
  solidJs.createEffect(solidJs.on([() => context.checked(), () => context.value()], () => {
    setIsInternalChangeEvent(true);
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));
  solidJs.createEffect(solidJs.on([() => ref, () => context.indeterminate(), () => context.checked()], ([ref, indeterminate]) => {
    if (ref) {
      ref.indeterminate = indeterminate;
    }
  }));
  return (() => {
    const _el$ = _tmpl$$h();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(el => {
      context.setInputRef(el);
      ref = el;
    }, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.checked();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => formControlContext.dataset(), () => context.dataset(), others), false, false);
    return _el$;
  })();
}

function CheckboxLabel(props) {
  const context = useCheckboxContext();
  return web.createComponent(FormControlLabel, web.mergeProps(() => context.dataset(), props));
}

function CheckboxRoot(props) {
  let ref;
  const defaultId = `checkbox-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(mergedProps, ["ref", "children", "value", "checked", "defaultChecked", "indeterminate", "onChange", "onPointerDown"], FORM_CONTROL_PROP_NAMES);
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [isFocused, setIsFocused] = solidJs.createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => formControlContext.isDisabled(),
    isReadOnly: () => formControlContext.isReadOnly()
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultChecked ?? false));
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-checked": state.isSelected() ? "" : undefined,
    "data-indeterminate": local.indeterminate ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    checked: () => state.isSelected(),
    indeterminate: () => local.indeterminate ?? false,
    inputRef,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    toggle: () => state.toggle(),
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setInputRef
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(CheckboxContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            },
            onPointerDown: onPointerDown
          }, () => formControlContext.dataset(), dataset, others, {
            get children() {
              return web.createComponent(CheckboxRootChild, {
                state: context,
                get children() {
                  return local.children;
                }
              });
            }
          }));
        }
      });
    }
  });
}
function CheckboxRootChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

var index$n = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Control: CheckboxControl,
	Description: CheckboxDescription,
	ErrorMessage: CheckboxErrorMessage,
	Indicator: CheckboxIndicator,
	Input: CheckboxInput,
	Label: CheckboxLabel,
	Root: CheckboxRoot
});

const PopperContext = solidJs.createContext();
function usePopperContext() {
  const context = solidJs.useContext(PopperContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopperContext` must be used within a `Popper` component");
  }
  return context;
}

const _tmpl$$g = /*#__PURE__*/web.template(`<svg display="block" viewBox="0 0 30 30"><g><path fill="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"></path><path stroke="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z">`);
const DEFAULT_SIZE = 30;
const HALF_DEFAULT_SIZE = DEFAULT_SIZE / 2;
const ROTATION_DEG = {
  top: 180,
  right: -90,
  bottom: 0,
  left: 90
};
function PopperArrow(props) {
  const context = usePopperContext();
  const mergedProps = utils.mergeDefaultProps({
    size: DEFAULT_SIZE
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "style", "children", "size"]);
  const dir = () => context.currentPlacement().split("-")[0];
  const contentStyle = createComputedStyle(context.contentRef);
  const fill = () => contentStyle()?.getPropertyValue("background-color") || "none";
  const stroke = () => contentStyle()?.getPropertyValue(`border-${dir()}-color`) || "none";
  const borderWidth = () => contentStyle()?.getPropertyValue(`border-${dir()}-width`) || "0px";
  const strokeWidth = () => {
    return parseInt(borderWidth()) * 2 * (DEFAULT_SIZE / local.size);
  };
  const rotate = () => {
    return `rotate(${ROTATION_DEG[dir()]} ${HALF_DEFAULT_SIZE} ${HALF_DEFAULT_SIZE})`;
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setArrowRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-hidden": "true",
    get style() {
      return {
        position: "absolute",
        "font-size": `${local.size}px`,
        width: "1em",
        height: "1em",
        "pointer-events": "none",
        fill: fill(),
        stroke: stroke(),
        "stroke-width": strokeWidth(),
        ...local.style
      };
    }
  }, others, {
    get children() {
      const _el$ = _tmpl$$g(),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.firstChild;
        _el$3.nextSibling;
      web.effect(() => web.setAttribute(_el$2, "transform", rotate()));
      return _el$;
    }
  }));
}
function createComputedStyle(element) {
  const [style, setStyle] = solidJs.createSignal();
  solidJs.createEffect(() => {
    const el = element();
    el && setStyle(utils.getWindow(el).getComputedStyle(el));
  });
  return style;
}

function PopperPositioner(props) {
  const context = usePopperContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "style"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setPositionerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "data-popper-positioner": "",
    get style() {
      return {
        position: "absolute",
        top: 0,
        left: 0,
        "min-width": "max-content",
        ...local.style
      };
    }
  }, others));
}

function createDOMRect(anchorRect) {
  const {
    x = 0,
    y = 0,
    width = 0,
    height = 0
  } = anchorRect ?? {};
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return {
    ...rect,
    toJSON: () => rect
  };
}
function getAnchorElement(anchor, getAnchorRect) {
  const contextElement = anchor;
  return {
    contextElement,
    getBoundingClientRect: () => {
      const anchorRect = getAnchorRect(anchor);
      if (anchorRect) {
        return createDOMRect(anchorRect);
      }
      if (anchor) {
        return anchor.getBoundingClientRect();
      }
      return createDOMRect();
    }
  };
}
function isValidPlacement(flip) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip);
}
const REVERSE_BASE_PLACEMENT = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function getTransformOrigin(placement, readingDirection) {
  const [basePlacement, alignment] = placement.split("-");
  const reversePlacement = REVERSE_BASE_PLACEMENT[basePlacement];
  if (!alignment) {
    return `${reversePlacement} center`;
  }
  if (basePlacement === "left" || basePlacement === "right") {
    return `${reversePlacement} ${alignment === "start" ? "top" : "bottom"}`;
  }
  if (alignment === "start") {
    return `${reversePlacement} ${readingDirection === "rtl" ? "right" : "left"}`;
  }
  return `${reversePlacement} ${readingDirection === "rtl" ? "left" : "right"}`;
}

function PopperRoot(props) {
  const mergedProps = utils.mergeDefaultProps({
    getAnchorRect: anchor => anchor?.getBoundingClientRect(),
    placement: "bottom",
    gutter: 0,
    shift: 0,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    hideWhenDetached: false,
    detachedPadding: 0,
    arrowPadding: 4,
    overflowPadding: 8
  }, props);
  const [positionerRef, setPositionerRef] = solidJs.createSignal();
  const [arrowRef, setArrowRef] = solidJs.createSignal();
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(mergedProps.placement);
  const anchorRef = () => getAnchorElement(mergedProps.anchorRef(), mergedProps.getAnchorRect);
  const {
    direction
  } = useLocale();
  async function updatePosition() {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    const arrowEl = arrowRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const arrowOffset = (arrowEl?.clientHeight || 0) / 2;
    const finalGutter = typeof mergedProps.gutter === "number" ? mergedProps.gutter + arrowOffset : mergedProps.gutter ?? arrowOffset;
    floatingEl.style.setProperty("--kb-popper-content-overflow-padding", `${mergedProps.overflowPadding}px`);
    referenceEl.getBoundingClientRect();
    const middleware = [dom.offset(({
      placement
    }) => {
      const hasAlignment = !!placement.split("-")[1];
      return {
        mainAxis: finalGutter,
        crossAxis: !hasAlignment ? mergedProps.shift : undefined,
        alignmentAxis: mergedProps.shift
      };
    })];
    if (mergedProps.flip !== false) {
      const fallbackPlacements = typeof mergedProps.flip === "string" ? mergedProps.flip.split(" ") : undefined;
      if (fallbackPlacements !== undefined && !fallbackPlacements.every(isValidPlacement)) {
        throw new Error("`flip` expects a spaced-delimited list of placements");
      }
      middleware.push(dom.flip({
        padding: mergedProps.overflowPadding,
        fallbackPlacements: fallbackPlacements
      }));
    }
    if (mergedProps.slide || mergedProps.overlap) {
      middleware.push(dom.shift({
        mainAxis: mergedProps.slide,
        crossAxis: mergedProps.overlap,
        padding: mergedProps.overflowPadding
      }));
    }
    middleware.push(dom.size({
      padding: mergedProps.overflowPadding,
      apply({
        availableWidth,
        availableHeight,
        rects
      }) {
        const referenceWidth = Math.round(rects.reference.width);
        availableWidth = Math.floor(availableWidth);
        availableHeight = Math.floor(availableHeight);
        floatingEl.style.setProperty("--kb-popper-anchor-width", `${referenceWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-width", `${availableWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-height", `${availableHeight}px`);
        if (mergedProps.sameWidth) {
          floatingEl.style.width = `${referenceWidth}px`;
        }
        if (mergedProps.fitViewport) {
          floatingEl.style.maxWidth = `${availableWidth}px`;
          floatingEl.style.maxHeight = `${availableHeight}px`;
        }
      }
    }));
    if (mergedProps.hideWhenDetached) {
      middleware.push(dom.hide({
        padding: mergedProps.detachedPadding
      }));
    }
    if (arrowEl) {
      middleware.push(dom.arrow({
        element: arrowEl,
        padding: mergedProps.arrowPadding
      }));
    }
    const pos = await dom.computePosition(referenceEl, floatingEl, {
      placement: mergedProps.placement,
      strategy: "absolute",
      middleware,
      platform: {
        ...dom.platform,
        isRTL: () => direction() === "rtl"
      }
    });
    setCurrentPlacement(pos.placement);
    mergedProps.onCurrentPlacementChange?.(pos.placement);
    if (!floatingEl) {
      return;
    }
    floatingEl.style.setProperty("--kb-popper-content-transform-origin", getTransformOrigin(pos.placement, direction()));
    const x = Math.round(pos.x);
    const y = Math.round(pos.y);
    let visibility;
    if (mergedProps.hideWhenDetached) {
      visibility = pos.middlewareData.hide?.referenceHidden ? "hidden" : "visible";
    }
    Object.assign(floatingEl.style, {
      top: "0",
      left: "0",
      transform: `translate3d(${x}px, ${y}px, 0)`,
      visibility
    });
    if (arrowEl && pos.middlewareData.arrow) {
      const {
        x: arrowX,
        y: arrowY
      } = pos.middlewareData.arrow;
      const dir = pos.placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: arrowX != null ? `${arrowX}px` : "",
        top: arrowY != null ? `${arrowY}px` : "",
        [dir]: "100%"
      });
    }
  }
  solidJs.createEffect(() => {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const cleanupAutoUpdate = dom.autoUpdate(referenceEl, floatingEl, updatePosition, {
      elementResize: typeof ResizeObserver === "function"
    });
    solidJs.onCleanup(cleanupAutoUpdate);
  });
  solidJs.createEffect(() => {
    const positioner = positionerRef();
    const content = mergedProps.contentRef();
    if (!positioner || !content) {
      return;
    }
    queueMicrotask(() => {
      positioner.style.zIndex = getComputedStyle(content).zIndex;
    });
  });
  const context = {
    currentPlacement,
    contentRef: () => mergedProps.contentRef(),
    setPositionerRef,
    setArrowRef
  };
  return web.createComponent(PopperContext.Provider, {
    value: context,
    get children() {
      return mergedProps.children;
    }
  });
}

const ComboboxContext = solidJs.createContext();
function useComboboxContext() {
  const context = solidJs.useContext(ComboboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useComboboxContext` must be used within a `Combobox` component");
  }
  return context;
}

function ComboboxContent(props) {
  let ref;
  const context = useComboboxContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "style", "onCloseAutoFocus", "onFocusOutside"]);
  const close = () => {
    context.resetInputValue(context.listState().selectionManager().selectedKeys());
    context.close();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => {
      const excludedElements = [];
      if (ref) {
        excludedElements.push(ref);
      }
      const controlEl = context.controlRef();
      if (controlEl) {
        excludedElements.push(controlEl);
      }
      return excludedElements;
    }
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: e => {
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      local.onCloseAutoFocus?.(e);
      if (!e.defaultPrevented) {
        utils.focusWithoutScrolling(context.inputRef());
        e.preventDefault();
      }
    }
  }, () => ref);
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.controlRef];
            },
            get style() {
              return {
                "--kb-combobox-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: onFocusOutside,
            onDismiss: close
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function ComboboxInput(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "disabled", "onInput", "onPointerDown", "onClick", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const collection = () => context.listState().collection();
  const selectionManager = () => context.listState().selectionManager();
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled();
  };
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onInput = e => {
    utils.callHandler(e, local.onInput);
    if (formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    const target = e.target;
    context.setInputValue(target.value);
    target.value = context.inputValue() ?? "";
    if (context.isOpen()) {
      if (collection().getSize() <= 0 && !context.allowsEmptyCollection()) {
        context.close();
      }
    } else {
      if (collection().getSize() > 0) {
        context.open(false, "input");
      }
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    if (context.isOpen()) {
      utils.callHandler(e, context.onInputKeyDown);
    }
    switch (e.key) {
      case "Enter":
        if (context.isOpen()) {
          e.preventDefault();
          const focusedKey = selectionManager().focusedKey();
          if (focusedKey != null) {
            selectionManager().select(focusedKey);
          }
        }
        break;
      case "Tab":
        if (context.isOpen()) {
          context.close();
          context.resetInputValue(context.listState().selectionManager().selectedKeys());
        }
        break;
      case "Escape":
        if (context.isOpen()) {
          context.close();
          context.resetInputValue(context.listState().selectionManager().selectedKeys());
        } else {
          context.setInputValue("");
        }
        break;
      case "ArrowDown":
        if (!context.isOpen()) {
          context.open(e.altKey ? false : "first", "manual");
        }
        break;
      case "ArrowUp":
        if (!context.isOpen()) {
          context.open("last", "manual");
        } else {
          if (e.altKey) {
            context.close();
            context.resetInputValue(context.listState().selectionManager().selectedKeys());
          }
        }
        break;
      case "ArrowLeft":
      case "ArrowRight":
        selectionManager().setFocusedKey(undefined);
        break;
      case "Backspace":
        if (context.removeOnBackspace() && selectionManager().selectionMode() === "multiple" && context.inputValue() === "") {
          const lastSelectedKey = [...selectionManager().selectedKeys()].pop() ?? "";
          selectionManager().toggleSelection(lastSelectedKey);
        }
        break;
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (context.isInputFocused()) {
      return;
    }
    context.setIsInputFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    if (utils.contains(context.controlRef(), e.relatedTarget) || utils.contains(context.contentRef(), e.relatedTarget)) {
      return;
    }
    context.setIsInputFocused(false);
  };
  let lastEventTime = 0;
  const onTouchEnd = e => {
    if (!ref || formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    if (e.timeStamp - lastEventTime < 500) {
      e.preventDefault();
      ref.focus();
      return;
    }
    const rect = e.target.getBoundingClientRect();
    const touch = e.changedTouches[0];
    const centerX = Math.ceil(rect.left + 0.5 * rect.width);
    const centerY = Math.ceil(rect.top + 0.5 * rect.height);
    if (touch.clientX === centerX && touch.clientY === centerY) {
      e.preventDefault();
      ref.focus();
      context.toggle(false, "manual");
      lastEventTime = e.timeStamp;
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "input",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setInputRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get value() {
      return context.inputValue();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get placeholder() {
      return context.placeholder();
    },
    type: "text",
    role: "combobox",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: "false",
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-activedescendant"]() {
      return context.activeDescendant();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    onInput: onInput,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur,
    onTouchEnd: onTouchEnd
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const ListboxContext = solidJs.createContext();
function useListboxContext() {
  const context = solidJs.useContext(ListboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxContext` must be used within a `Listbox` component");
  }
  return context;
}

const ListboxItemContext = solidJs.createContext();
function useListboxItemContext() {
  const context = solidJs.useContext(ListboxItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxItemContext` must be used within a `Listbox.Item` component");
  }
  return context;
}

function ListboxItem(props) {
  let ref;
  const listBoxContext = useListboxContext();
  const defaultId = `${listBoxContext.generateId("item")}-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "item", "aria-label", "aria-labelledby", "aria-describedby", "onPointerMove", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const selectionManager = () => listBoxContext.listState().selectionManager();
  const isHighlighted = () => selectionManager().focusedKey() === local.item.key;
  const selectableItem = createSelectableItem({
    key: () => local.item.key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: listBoxContext.shouldSelectOnPressUp,
    allowsDifferentPressOrigin: () => {
      return listBoxContext.shouldSelectOnPressUp() && listBoxContext.shouldFocusOnHover();
    },
    shouldUseVirtualFocus: listBoxContext.shouldUseVirtualFocus,
    disabled: () => local.item.disabled
  }, () => ref);
  const ariaSelected = () => {
    if (selectionManager().selectionMode() === "none") {
      return undefined;
    }
    return selectableItem.isSelected();
  };
  const isNotSafariMacOS = solidJs.createMemo(() => !(utils.isMac() && utils.isWebKit()));
  const ariaLabel = () => isNotSafariMacOS() ? local["aria-label"] : undefined;
  const ariaLabelledBy = () => isNotSafariMacOS() ? labelId() : undefined;
  const ariaDescribedBy = () => isNotSafariMacOS() ? descriptionId() : undefined;
  const ariaPosInSet = () => {
    if (!listBoxContext.isVirtualized()) {
      return undefined;
    }
    const index = listBoxContext.listState().collection().getItem(local.item.key)?.index;
    return index != null ? index + 1 : undefined;
  };
  const ariaSetSize = () => {
    if (!listBoxContext.isVirtualized()) {
      return undefined;
    }
    return getItemCount(listBoxContext.listState().collection());
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (!selectableItem.isDisabled() && listBoxContext.shouldFocusOnHover()) {
      utils.focusWithoutScrolling(e.currentTarget);
      selectionManager().setFocused(true);
      selectionManager().setFocusedKey(local.item.key);
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-disabled": selectableItem.isDisabled() ? "" : undefined,
    "data-selected": selectableItem.isSelected() ? "" : undefined,
    "data-highlighted": isHighlighted() ? "" : undefined
  }));
  const context = {
    isSelected: selectableItem.isSelected,
    dataset,
    generateId: utils.createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(ListboxItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "li",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "option",
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-disabled"]() {
          return selectableItem.isDisabled();
        },
        get ["aria-selected"]() {
          return ariaSelected();
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        },
        get ["aria-posinset"]() {
          return ariaPosInSet();
        },
        get ["aria-setsize"]() {
          return ariaSetSize();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return utils.composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return utils.composeEventHandlers([local.onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove: onPointerMove
      }, dataset, others));
    }
  });
}

function ListboxItemDescription(props) {
  const context = useListboxItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function ListboxItemIndicator(props) {
  const context = useListboxItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["forceMount"]);
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.forceMount || context.isSelected();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        "aria-hidden": "true"
      }, () => context.dataset(), others));
    }
  });
}

function ListboxItemLabel(props) {
  const context = useListboxItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabelId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function ListboxRoot(props) {
  let ref;
  const defaultId = `listbox-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    virtualized: false
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "children", "renderItem", "renderSection", "value", "defaultValue", "onChange", "options", "optionValue", "optionTextValue", "optionDisabled", "optionGroupChildren", "state", "keyboardDelegate", "autoFocus", "selectionMode", "shouldFocusWrap", "shouldUseVirtualFocus", "shouldSelectOnPressUp", "shouldFocusOnHover", "allowDuplicateSelectionEvents", "disallowEmptySelection", "selectionBehavior", "selectOnFocus", "disallowTypeAhead", "allowsTabNavigation", "virtualized", "scrollToItem", "scrollRef", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const listState = solidJs.createMemo(() => {
    if (local.state) {
      return local.state;
    }
    return createListState({
      selectedKeys: () => local.value,
      defaultSelectedKeys: () => local.defaultValue,
      onSelectionChange: local.onChange,
      allowDuplicateSelectionEvents: () => utils.access(local.allowDuplicateSelectionEvents),
      disallowEmptySelection: () => utils.access(local.disallowEmptySelection),
      selectionBehavior: () => utils.access(local.selectionBehavior),
      selectionMode: () => utils.access(local.selectionMode),
      dataSource: () => local.options ?? [],
      getKey: () => local.optionValue,
      getTextValue: () => local.optionTextValue,
      getDisabled: () => local.optionDisabled,
      getSectionChildren: () => local.optionGroupChildren
    });
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState().selectionManager(),
    collection: () => listState().collection(),
    autoFocus: () => utils.access(local.autoFocus),
    shouldFocusWrap: () => utils.access(local.shouldFocusWrap),
    keyboardDelegate: () => local.keyboardDelegate,
    disallowEmptySelection: () => utils.access(local.disallowEmptySelection),
    selectOnFocus: () => utils.access(local.selectOnFocus),
    disallowTypeAhead: () => utils.access(local.disallowTypeAhead),
    shouldUseVirtualFocus: () => utils.access(local.shouldUseVirtualFocus),
    allowsTabNavigation: () => utils.access(local.allowsTabNavigation),
    isVirtualized: () => local.virtualized,
    scrollToKey: () => local.scrollToItem
  }, () => ref, () => local.scrollRef?.());
  const context = {
    listState,
    generateId: utils.createGenerateId(() => others.id),
    shouldUseVirtualFocus: () => mergedProps.shouldUseVirtualFocus,
    shouldSelectOnPressUp: () => mergedProps.shouldSelectOnPressUp,
    shouldFocusOnHover: () => mergedProps.shouldFocusOnHover,
    isVirtualized: () => local.virtualized
  };
  return web.createComponent(ListboxContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "ul",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "listbox",
        get tabIndex() {
          return selectableList.tabIndex();
        },
        get ["aria-multiselectable"]() {
          return listState().selectionManager().selectionMode() === "multiple" ? true : undefined;
        },
        get onKeyDown() {
          return utils.composeEventHandlers([local.onKeyDown, selectableList.onKeyDown]);
        },
        get onMouseDown() {
          return utils.composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
        },
        get onFocusIn() {
          return utils.composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
        },
        get onFocusOut() {
          return utils.composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
        }
      }, others, {
        get children() {
          return web.createComponent(solidJs.Show, {
            get when() {
              return !local.virtualized;
            },
            get fallback() {
              return local.children?.(listState().collection);
            },
            get children() {
              return web.createComponent(utils.Key, {
                get each() {
                  return [...listState().collection()];
                },
                by: "key",
                children: item => web.createComponent(solidJs.Switch, {
                  get children() {
                    return [web.createComponent(solidJs.Match, {
                      get when() {
                        return item().type === "section";
                      },
                      get children() {
                        return local.renderSection?.(item());
                      }
                    }), web.createComponent(solidJs.Match, {
                      get when() {
                        return item().type === "item";
                      },
                      get children() {
                        return local.renderItem?.(item());
                      }
                    })];
                  }
                })
              });
            }
          });
        }
      }));
    }
  });
}

function ListboxSection(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "li",
    role: "presentation"
  }, props));
}

var index$m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Item: ListboxItem,
	ItemDescription: ListboxItemDescription,
	ItemIndicator: ListboxItemIndicator,
	ItemLabel: ListboxItemLabel,
	Root: ListboxRoot,
	Section: ListboxSection
});

function ComboboxListbox(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("listbox")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref"]);
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, context.listboxAriaLabel(), undefined);
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerListboxId(others.id)));
  return web.createComponent(ListboxRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get state() {
      return context.listState();
    },
    get autoFocus() {
      return context.autoFocus();
    },
    shouldUseVirtualFocus: true,
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get ["aria-label"]() {
      return context.listboxAriaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get renderItem() {
      return context.renderItem;
    },
    get renderSection() {
      return context.renderSection;
    },
    get virtualized() {
      return context.isVirtualized();
    }
  }, others));
}

function ComboboxPortal(props) {
  const context = useComboboxContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

function ComboboxControl(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "children"]);
  const selectionManager = () => context.listState().selectionManager();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setControlRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, () => context.dataset(), () => formControlContext.dataset(), others, {
    get children() {
      return web.createComponent(ComboboxControlChild, {
        state: {
          selectedOptions: () => context.selectedOptions(),
          remove: option => context.removeOptionFromSelection(option),
          clear: () => selectionManager().clearSelection()
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
function ComboboxControlChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

const _tmpl$$f = /*#__PURE__*/web.template(`<option>`),
  _tmpl$2 = /*#__PURE__*/web.template(`<div aria-hidden="true"><input type="text"><select tabindex="-1"><option>`);
function HiddenSelectBase(props) {
  let ref;
  const [local, others] = solidJs.splitProps(props, ["ref", "onChange", "collection", "selectionManager", "isOpen", "isMultiple", "isVirtualized", "focusTrigger"]);
  const formControlContext = useFormControlContext();
  const [isInternalChangeEvent, setIsInternalChangeEvent] = solidJs.createSignal(false);
  const renderOption = key => {
    const item = local.collection.getItem(key);
    return web.createComponent(solidJs.Show, {
      get when() {
        return item?.type === "item";
      },
      get children() {
        const _el$ = _tmpl$$f();
        _el$.value = key;
        web.insert(_el$, () => item?.textValue);
        web.effect(() => _el$.selected = local.selectionManager.isSelected(key));
        return _el$;
      }
    });
  };
  solidJs.createEffect(solidJs.on(() => local.selectionManager.selectedKeys(), (keys, prevKeys) => {
    if (prevKeys && isSameSelection(keys, prevKeys)) {
      return;
    }
    setIsInternalChangeEvent(true);
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));
  return (() => {
    const _el$2 = _tmpl$2(),
      _el$3 = _el$2.firstChild,
      _el$4 = _el$3.nextSibling;
      _el$4.firstChild;
    _el$3.addEventListener("focus", () => local.focusTrigger());
    _el$3.style.setProperty("font-size", "16px");
    _el$4.addEventListener("change", e => {
      utils.callHandler(e, local.onChange);
      if (!isInternalChangeEvent()) {
        local.selectionManager.setSelectedKeys(new Set([e.target.value]));
      }
      setIsInternalChangeEvent(false);
    });
    const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$4);
    web.spread(_el$4, web.mergeProps({
      get multiple() {
        return local.isMultiple;
      },
      get name() {
        return formControlContext.name();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get size() {
        return local.collection.getSize();
      },
      get value() {
        return local.selectionManager.firstSelectedKey() ?? "";
      }
    }, others), false, true);
    web.insert(_el$4, web.createComponent(solidJs.Show, {
      get when() {
        return local.isVirtualized;
      },
      get fallback() {
        return web.createComponent(solidJs.For, {
          get each() {
            return [...local.collection.getKeys()];
          },
          children: renderOption
        });
      },
      get children() {
        return web.createComponent(solidJs.For, {
          get each() {
            return [...local.selectionManager.selectedKeys()];
          },
          children: renderOption
        });
      }
    }), null);
    web.effect(_p$ => {
      const _v$ = utils.visuallyHiddenStyles,
        _v$2 = local.selectionManager.isFocused() || local.isOpen ? -1 : 0,
        _v$3 = formControlContext.isRequired(),
        _v$4 = formControlContext.isDisabled(),
        _v$5 = formControlContext.isReadOnly();
      _p$._v$ = web.style(_el$2, _v$, _p$._v$);
      _v$2 !== _p$._v$2 && web.setAttribute(_el$3, "tabindex", _p$._v$2 = _v$2);
      _v$3 !== _p$._v$3 && (_el$3.required = _p$._v$3 = _v$3);
      _v$4 !== _p$._v$4 && (_el$3.disabled = _p$._v$4 = _v$4);
      _v$5 !== _p$._v$5 && (_el$3.readOnly = _p$._v$5 = _v$5);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined,
      _v$3: undefined,
      _v$4: undefined,
      _v$5: undefined
    });
    return _el$2;
  })();
}

function ComboboxHiddenSelect(props) {
  const context = useComboboxContext();
  return web.createComponent(HiddenSelectBase, web.mergeProps({
    get collection() {
      return context.listState().collection();
    },
    get selectionManager() {
      return context.listState().selectionManager();
    },
    get isOpen() {
      return context.isOpen();
    },
    get isMultiple() {
      return context.isMultiple();
    },
    get isVirtualized() {
      return context.isVirtualized();
    },
    focusTrigger: () => context.inputRef()?.focus()
  }, props));
}

function ComboboxIcon(props) {
  const context = useComboboxContext();
  const mergedProps = utils.mergeDefaultProps({
    children: ""
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}

const COMBOBOX_INTL_TRANSLATIONS = {
  focusAnnouncement: (optionText, isSelected) => `${optionText}${isSelected ? ", selected" : ""}`,
  countAnnouncement: optionCount => {
    switch (optionCount) {
      case 1:
        return "one option available";
    }
  },
  selectedAnnouncement: optionText => `${optionText}, selected`,
  triggerLabel: "Show suggestions",
  listboxLabel: "Suggestions"
};

function ComboboxBase(props) {
  const defaultId = `combobox-${solidJs.createUniqueId()}`;
  const filter = createFilter({
    sensitivity: "base"
  });
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    allowsEmptyCollection: false,
    disallowEmptySelection: false,
    allowDuplicateSelectionEvents: true,
    closeOnSelection: props.selectionMode === "single",
    removeOnBackspace: true,
    gutter: 8,
    sameWidth: true,
    modal: false,
    defaultFilter: "contains",
    triggerMode: "input",
    translations: COMBOBOX_INTL_TRANSLATIONS
  }, props);
  const [local, popperProps, formControlProps, others] = solidJs.splitProps(mergedProps, ["translations", "itemComponent", "sectionComponent", "open", "defaultOpen", "onOpenChange", "onInputChange", "value", "defaultValue", "onChange", "triggerMode", "placeholder", "options", "optionValue", "optionTextValue", "optionLabel", "optionDisabled", "optionGroupChildren", "keyboardDelegate", "allowDuplicateSelectionEvents", "disallowEmptySelection", "defaultFilter", "shouldFocusWrap", "allowsEmptyCollection", "closeOnSelection", "removeOnBackspace", "selectionBehavior", "selectionMode", "virtualized", "modal", "preventScroll", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [listboxId, setListboxId] = solidJs.createSignal();
  const [controlRef, setControlRef] = solidJs.createSignal();
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [listboxRef, setListboxRef] = solidJs.createSignal();
  const [focusStrategy, setFocusStrategy] = solidJs.createSignal(false);
  const [isInputFocused, setIsInputFocusedState] = solidJs.createSignal(false);
  const [showAllOptions, setShowAllOptions] = solidJs.createSignal(false);
  const [lastDisplayedOptions, setLastDisplayedOptions] = solidJs.createSignal(local.options);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen, openTriggerMode)
  });
  const [inputValue, setInputValue] = createControllableSignal({
    defaultValue: () => "",
    onChange: value => {
      local.onInputChange?.(value);
      if (value === "" && local.selectionMode === "single" && !listState.selectionManager().isEmpty() && local.value === undefined) {
        listState.selectionManager().setSelectedKeys([]);
      }
      listState.selectionManager().setFocusedKey(undefined);
    }
  });
  const getOptionValue = option => {
    const optionValue = local.optionValue;
    if (optionValue == null) {
      return String(option);
    }
    return String(utils.isFunction(optionValue) ? optionValue(option) : option[optionValue]);
  };
  const getOptionLabel = option => {
    const optionLabel = local.optionLabel;
    if (optionLabel == null) {
      return String(option);
    }
    return String(utils.isFunction(optionLabel) ? optionLabel(option) : option[optionLabel]);
  };
  const allOptions = solidJs.createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;
    if (optionGroupChildren == null) {
      return local.options;
    }
    return local.options.flatMap(item => item[optionGroupChildren] ?? item);
  });
  const filterFn = option => {
    const inputVal = inputValue() ?? "";
    if (utils.isFunction(local.defaultFilter)) {
      return local.defaultFilter?.(option, inputVal);
    }
    const textVal = getOptionLabel(option);
    switch (local.defaultFilter) {
      case "startsWith":
        return filter.startsWith(textVal, inputVal);
      case "endsWith":
        return filter.endsWith(textVal, inputVal);
      case "contains":
        return filter.contains(textVal, inputVal);
    }
  };
  const filteredOptions = solidJs.createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;
    if (optionGroupChildren == null) {
      return local.options.filter(filterFn);
    }
    const filteredGroups = [];
    for (const optGroup of local.options) {
      const filteredChildrenOptions = optGroup[optionGroupChildren].filter(filterFn);
      if (filteredChildrenOptions.length === 0) continue;
      filteredGroups.push({
        ...optGroup,
        [optionGroupChildren]: filteredChildrenOptions
      });
    }
    return filteredGroups;
  });
  const displayedOptions = solidJs.createMemo(() => {
    if (disclosureState.isOpen()) {
      if (showAllOptions()) {
        return local.options;
      }
      return filteredOptions();
    }
    return lastDisplayedOptions();
  });
  let openTriggerMode = "focus";
  const getOptionsFromValues = values => {
    return [...values].map(value => allOptions().find(option => getOptionValue(option) === value)).filter(option => option != null);
  };
  const listState = createListState({
    selectedKeys: () => {
      if (local.value != null) {
        return local.value.map(getOptionValue);
      }
      return local.value;
    },
    defaultSelectedKeys: () => {
      if (local.defaultValue != null) {
        return local.defaultValue.map(getOptionValue);
      }
      return local.defaultValue;
    },
    onSelectionChange: selectedKeys => {
      local.onChange?.(getOptionsFromValues(selectedKeys));
      if (local.closeOnSelection) {
        if (disclosureState.isOpen() && selectedKeys.size > 0) {
          close();
        }
      }
      const inputEl = inputRef();
      if (inputEl) {
        inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
        utils.focusWithoutScrolling(inputEl);
      }
    },
    allowDuplicateSelectionEvents: () => utils.access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => local.disallowEmptySelection,
    selectionBehavior: () => utils.access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: displayedOptions,
    getKey: () => local.optionValue,
    getTextValue: () => local.optionTextValue,
    getDisabled: () => local.optionDisabled,
    getSectionChildren: () => local.optionGroupChildren
  });
  const selectedOptions = solidJs.createMemo(() => {
    return getOptionsFromValues(listState.selectionManager().selectedKeys());
  });
  const removeOptionFromSelection = option => {
    listState.selectionManager().toggleSelection(getOptionValue(option));
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const open = (focusStrategy, triggerMode) => {
    const showAllOptions = setShowAllOptions(triggerMode === "manual");
    const hasOptions = showAllOptions ? local.options.length > 0 : filteredOptions().length > 0;
    if (!hasOptions && !local.allowsEmptyCollection) {
      return;
    }
    openTriggerMode = triggerMode;
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
  };
  const toggle = (focusStrategy, triggerMode) => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy, triggerMode);
    }
  };
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(inputRef, () => {
    const defaultSelectedKeys = local.defaultValue ? [...local.defaultValue].map(getOptionValue) : new Selection();
    listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
  });
  const delegate = solidJs.createMemo(() => {
    const keyboardDelegate = utils.access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, listboxRef, undefined);
  });
  const selectableCollection = createSelectableCollection({
    selectionManager: () => listState.selectionManager(),
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap: () => local.shouldFocusWrap,
    isVirtualized: true
  }, inputRef);
  const setIsInputFocused = isFocused => {
    if (isFocused && local.triggerMode === "focus") {
      open(false, "focus");
    }
    setIsInputFocusedState(isFocused);
    listState.selectionManager().setFocused(isFocused);
  };
  const activeDescendant = solidJs.createMemo(() => {
    const focusedKey = listState.selectionManager().focusedKey();
    if (focusedKey) {
      return listboxRef()?.querySelector(`[data-key="${focusedKey}"]`)?.id;
    }
    return undefined;
  });
  const resetInputValue = selectedKeys => {
    if (local.selectionMode === "single") {
      const selectedKey = [...selectedKeys][0];
      const selectedOption = allOptions().find(option => getOptionValue(option) === selectedKey);
      setInputValue(selectedOption ? getOptionLabel(selectedOption) : "");
    } else {
      setInputValue("");
    }
  };
  const renderItem = item => {
    return local.itemComponent?.({
      item
    });
  };
  const renderSection = section => {
    return local.sectionComponent?.({
      section
    });
  };
  solidJs.createEffect(solidJs.on([filteredOptions, showAllOptions], (input, prevInput) => {
    if (disclosureState.isOpen() && prevInput != null) {
      const prevFilteredOptions = prevInput[0];
      const prevShowAllOptions = prevInput[1];
      setLastDisplayedOptions(prevShowAllOptions ? local.options : prevFilteredOptions);
    } else {
      const filteredOptions = input[0];
      const showAllOptions = input[1];
      setLastDisplayedOptions(showAllOptions ? local.options : filteredOptions);
    }
  }));
  solidJs.createEffect(solidJs.on(inputValue, () => {
    if (showAllOptions()) {
      setShowAllOptions(false);
    }
  }));
  solidJs.createEffect(solidJs.on(() => listState.selectionManager().selectedKeys(), resetInputValue));
  let lastAnnouncedFocusedKey = "";
  solidJs.createEffect(() => {
    const focusedKey = listState.selectionManager().focusedKey() ?? "";
    const focusedItem = listState.collection().getItem(focusedKey);
    if (utils.isAppleDevice() && focusedItem != null && focusedKey !== lastAnnouncedFocusedKey) {
      const isSelected = listState.selectionManager().isSelected(focusedKey);
      const announcement = local.translations?.focusAnnouncement(focusedItem?.textValue || "", isSelected) ?? "";
      announce(announcement);
    }
    if (focusedKey) {
      lastAnnouncedFocusedKey = focusedKey;
    }
  });
  let lastOptionCount = getItemCount(listState.collection());
  let lastOpen = disclosureState.isOpen();
  solidJs.createEffect(() => {
    const optionCount = getItemCount(listState.collection());
    const isOpen = disclosureState.isOpen();
    const didOpenWithoutFocusedItem = isOpen !== lastOpen && (listState.selectionManager().focusedKey() == null || utils.isAppleDevice());
    if (isOpen && (didOpenWithoutFocusedItem || optionCount !== lastOptionCount)) {
      const announcement = local.translations?.countAnnouncement(optionCount) ?? "";
      announce(announcement);
    }
    lastOptionCount = optionCount;
    lastOpen = isOpen;
  });
  let lastAnnouncedSelectedKey = "";
  solidJs.createEffect(() => {
    const lastSelectedKey = [...listState.selectionManager().selectedKeys()].pop() ?? "";
    const lastSelectedItem = listState.collection().getItem(lastSelectedKey);
    if (utils.isAppleDevice() && isInputFocused() && lastSelectedItem && lastSelectedKey !== lastAnnouncedSelectedKey) {
      const announcement = local.translations?.selectedAnnouncement(lastSelectedItem?.textValue || "") ?? "";
      announce(announcement);
    }
    if (lastSelectedKey) {
      lastAnnouncedSelectedKey = lastSelectedKey;
    }
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => utils.access(local.selectionMode) === "multiple",
    isVirtualized: () => local.virtualized ?? false,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    allowsEmptyCollection: () => local.allowsEmptyCollection ?? false,
    shouldFocusWrap: () => local.shouldFocusWrap ?? false,
    removeOnBackspace: () => local.removeOnBackspace ?? true,
    selectedOptions,
    isInputFocused,
    contentPresence,
    autoFocus: focusStrategy,
    inputValue,
    triggerMode: () => local.triggerMode,
    activeDescendant,
    controlRef,
    inputRef,
    triggerRef,
    contentRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    listboxId,
    triggerAriaLabel: () => local.translations?.triggerLabel,
    listboxAriaLabel: () => local.translations?.listboxLabel,
    setIsInputFocused,
    resetInputValue,
    setInputValue,
    setControlRef,
    setInputRef,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    placeholder: () => local.placeholder,
    renderItem,
    renderSection,
    removeOptionFromSelection,
    onInputKeyDown: e => selectableCollection.onKeyDown(e),
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    registerListboxId: createRegisterId(setListboxId)
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(ComboboxContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: controlRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return web.createComponent(Polymorphic, web.mergeProps({
                as: "div",
                role: "group",
                get id() {
                  return utils.access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

function ComboboxRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["value", "defaultValue", "onChange", "multiple"]);
  const value = solidJs.createMemo(() => {
    if (local.value != null) {
      return local.multiple ? local.value : [local.value];
    }
    return local.value;
  });
  const defaultValue = solidJs.createMemo(() => {
    if (local.defaultValue != null) {
      return local.multiple ? local.defaultValue : [local.defaultValue];
    }
    return local.defaultValue;
  });
  const onChange = value => {
    if (local.multiple) {
      local.onChange?.(value);
    } else {
      local.onChange?.(value[0] ?? null);
    }
  };
  return web.createComponent(ComboboxBase, web.mergeProps({
    get value() {
      return value();
    },
    get defaultValue() {
      return defaultValue();
    },
    onChange: onChange,
    get selectionMode() {
      return local.multiple ? "multiple" : "single";
    }
  }, others));
}

function ComboboxTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "disabled", "onPointerDown", "onClick", "aria-labelledby"]);
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
      e.preventDefault();
      context.toggle(false, "manual");
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!isDisabled()) {
      if (e.currentTarget.dataset.pointerType === "touch") {
        context.toggle(false, "manual");
      }
      context.inputRef()?.focus();
    }
  };
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, context.triggerAriaLabel(), local["aria-labelledby"]);
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get disabled() {
      return isDisabled();
    },
    tabIndex: "-1",
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return context.triggerAriaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$l = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: ComboboxContent,
	Control: ComboboxControl,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	HiddenSelect: ComboboxHiddenSelect,
	Icon: ComboboxIcon,
	Input: ComboboxInput,
	Item: ListboxItem,
	ItemDescription: ListboxItemDescription,
	ItemIndicator: ListboxItemIndicator,
	ItemLabel: ListboxItemLabel,
	Label: FormControlLabel,
	Listbox: ComboboxListbox,
	Portal: ComboboxPortal,
	Root: ComboboxRoot,
	Section: ListboxSection,
	Trigger: ComboboxTrigger
});

const MenuContext = solidJs.createContext();
function useOptionalMenuContext() {
  return solidJs.useContext(MenuContext);
}
function useMenuContext() {
  const context = useOptionalMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuContext` must be used within a `Menu` component");
  }
  return context;
}

const MenuRootContext = solidJs.createContext();
function useMenuRootContext() {
  const context = solidJs.useContext(MenuRootContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRootContext` must be used within a `MenuRoot` component");
  }
  return context;
}

function getPointerGraceArea(placement, event, contentEl) {
  const basePlacement = placement.split("-")[0];
  const contentRect = contentEl.getBoundingClientRect();
  const polygon = [];
  const pointerX = event.clientX;
  const pointerY = event.clientY;
  switch (basePlacement) {
    case "top":
      polygon.push([pointerX, pointerY + 5]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      break;
    case "right":
      polygon.push([pointerX - 5, pointerY]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      break;
    case "bottom":
      polygon.push([pointerX, pointerY - 5]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      break;
    case "left":
      polygon.push([pointerX + 5, pointerY]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      break;
  }
  return polygon;
}
function isPointerInGraceArea(event, area) {
  if (!area) {
    return false;
  }
  return utils.isPointInPolygon([event.clientX, event.clientY], area);
}

function Menu(props) {
  const rootContext = useMenuRootContext();
  const parentDomCollectionContext = useOptionalDomCollectionContext();
  const parentMenuContext = useOptionalMenuContext();
  const mergedProps = utils.mergeDefaultProps({
    placement: "bottom-start"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["open", "defaultOpen", "onOpenChange"]);
  let pointerGraceTimeoutId = 0;
  let pointerGraceIntent = null;
  let pointerDir = "right";
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [focusStrategy, setFocusStrategy] = solidJs.createSignal(true);
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(others.placement);
  const [nestedMenus, setNestedMenus] = solidJs.createSignal([]);
  const [items, setItems] = solidJs.createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => rootContext.forceMount() || disclosureState.isOpen());
  const listState = createListState({
    selectionMode: "none",
    dataSource: items
  });
  const open = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.open();
  };
  const close = (recursively = false) => {
    disclosureState.close();
    if (recursively && parentMenuContext) {
      parentMenuContext.close(true);
    }
  };
  const toggle = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.toggle();
  };
  const focusContent = () => {
    const content = contentRef();
    if (content) {
      utils.focusWithoutScrolling(content);
      listState.selectionManager().setFocused(true);
      listState.selectionManager().setFocusedKey(undefined);
    }
  };
  const registerNestedMenu = element => {
    setNestedMenus(prev => [...prev, element]);
    const parentUnregister = parentMenuContext?.registerNestedMenu(element);
    return () => {
      setNestedMenus(prev => utils.removeItemFromArray(prev, element));
      parentUnregister?.();
    };
  };
  const isPointerMovingToSubmenu = e => {
    const isMovingTowards = pointerDir === pointerGraceIntent?.side;
    return isMovingTowards && isPointerInGraceArea(e, pointerGraceIntent?.area);
  };
  const onItemEnter = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  const onItemLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    focusContent();
  };
  const onTriggerLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => {
      return !(parentMenuContext == null && disclosureState.isOpen() && rootContext.isModal());
    },
    targets: () => [contentRef(), ...nestedMenus()].filter(Boolean)
  });
  solidJs.createEffect(() => {
    const contentEl = contentRef();
    if (!contentEl || !parentMenuContext) {
      return;
    }
    const parentUnregister = parentMenuContext.registerNestedMenu(contentEl);
    solidJs.onCleanup(() => {
      parentUnregister();
    });
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresence,
    nestedMenus,
    currentPlacement,
    pointerGraceTimeoutId: () => pointerGraceTimeoutId,
    autoFocus: focusStrategy,
    listState: () => listState,
    parentMenuContext: () => parentMenuContext,
    triggerRef,
    contentRef,
    triggerId,
    contentId,
    setTriggerRef,
    setContentRef,
    open,
    close,
    toggle,
    focusContent,
    onItemEnter,
    onItemLeave,
    onTriggerLeave,
    setPointerDir: dir => pointerDir = dir,
    setPointerGraceTimeoutId: id => pointerGraceTimeoutId = id,
    setPointerGraceIntent: intent => pointerGraceIntent = intent,
    registerNestedMenu,
    registerItemToParentDomCollection: parentDomCollectionContext?.registerItem,
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(MenuContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: triggerRef,
            contentRef: contentRef,
            onCurrentPlacementChange: setCurrentPlacement
          }, others));
        }
      });
    }
  });
}

const MenuItemContext = solidJs.createContext();
function useMenuItemContext() {
  const context = solidJs.useContext(MenuItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuItemContext` must be used within a `Menu.Item` component");
  }
  return context;
}

function MenuItemBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const mergedProps = utils.mergeDefaultProps({
    id: rootContext.generateId(`item-${solidJs.createUniqueId()}`)
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "textValue", "disabled", "closeOnSelect", "checked", "indeterminate", "onSelect", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [labelRef, setLabelRef] = solidJs.createSignal();
  const selectionManager = () => menuContext.listState().selectionManager();
  const key = () => others.id;
  const isHighlighted = () => selectionManager().focusedKey() === key();
  const onSelect = () => {
    local.onSelect?.();
    if (local.closeOnSelect) {
      menuContext.close(true);
    }
  };
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    })
  });
  const selectableItem = createSelectableItem({
    key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (local.disabled) {
      menuContext.onItemLeave(e);
    } else {
      menuContext.onItemEnter(e);
      if (!e.defaultPrevented) {
        utils.focusWithoutScrolling(e.currentTarget);
        menuContext.listState().selectionManager().setFocused(true);
        menuContext.listState().selectionManager().setFocusedKey(key());
      }
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    menuContext.onItemLeave(e);
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    if (!local.disabled && e.button === 0) {
      onSelect();
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
        onSelect();
        break;
    }
  };
  const ariaChecked = solidJs.createMemo(() => {
    if (local.indeterminate) {
      return "mixed";
    }
    if (local.checked == null) {
      return undefined;
    }
    return local.checked;
  });
  const dataset = solidJs.createMemo(() => ({
    "data-indeterminate": local.indeterminate ? "" : undefined,
    "data-checked": local.checked && !local.indeterminate ? "" : undefined,
    "data-disabled": local.disabled ? "" : undefined,
    "data-highlighted": isHighlighted() ? "" : undefined
  }));
  const context = {
    isChecked: () => local.checked,
    dataset,
    setLabelRef,
    generateId: utils.createGenerateId(() => others.id),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId)
  };
  return web.createComponent(MenuItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-checked"]() {
          return ariaChecked();
        },
        get ["aria-disabled"]() {
          return local.disabled;
        },
        get ["aria-labelledby"]() {
          return labelId();
        },
        get ["aria-describedby"]() {
          return descriptionId();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return utils.composeEventHandlers([onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return utils.composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return utils.composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove: onPointerMove,
        onPointerLeave: onPointerLeave
      }, dataset, others));
    }
  });
}

function MenuCheckboxItem(props) {
  const mergedProps = utils.mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["checked", "defaultChecked", "onChange", "onSelect"]);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: checked => local.onChange?.(checked),
    isDisabled: () => others.disabled
  });
  const onSelect = () => {
    local.onSelect?.();
    state.toggle();
  };
  return web.createComponent(MenuItemBase, web.mergeProps({
    role: "menuitemcheckbox",
    get checked() {
      return state.isSelected();
    },
    onSelect: onSelect
  }, others));
}

const MenubarContext = solidJs.createContext();
function useOptionalMenubarContext() {
  return solidJs.useContext(MenubarContext);
}
function useMenubarContext() {
  const context = useOptionalMenubarContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenubarContext` must be used within a `Menubar` component");
  }
  return context;
}

function MenuContentBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const mergedProps = utils.mergeDefaultProps({
    id: rootContext.generateId(`content-${solidJs.createUniqueId()}`)
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onEscapeKeyDown", "onFocusOutside", "onPointerEnter", "onPointerMove", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  let lastPointerX = 0;
  const isRootModalContent = () => {
    return context.parentMenuContext() == null && optionalMenubarContext === undefined && rootContext.isModal();
  };
  const selectableList = createSelectableList({
    selectionManager: context.listState().selectionManager,
    collection: context.listState().collection,
    autoFocus: context.autoFocus,
    deferAutoFocus: true,
    shouldFocusWrap: true,
    disallowTypeAhead: () => !context.listState().selectionManager().isFocused()
  }, () => ref);
  createFocusScope({
    trapFocus: () => isRootModalContent() && context.isOpen(),
    onMountAutoFocus: event => {
      if (optionalMenubarContext === undefined) local.onOpenAutoFocus?.(event);
    },
    onUnmountAutoFocus: local.onCloseAutoFocus
  }, () => ref);
  const onKeyDown = e => {
    if (!utils.contains(e.currentTarget, e.target)) {
      return;
    }
    if (e.key === "Tab" && context.isOpen()) {
      e.preventDefault();
    }
    if (optionalMenubarContext !== undefined) {
      if (e.currentTarget.getAttribute("aria-haspopup") !== "true") switch (e.key) {
        case "ArrowRight":
          e.stopPropagation();
          e.preventDefault();
          context.close(true);
          optionalMenubarContext.setAutoFocusMenu(true);
          optionalMenubarContext.nextMenu();
          break;
        case "ArrowLeft":
          if (e.currentTarget.hasAttribute("data-closed")) break;
          e.stopPropagation();
          e.preventDefault();
          context.close(true);
          optionalMenubarContext.setAutoFocusMenu(true);
          optionalMenubarContext.previousMenu();
          break;
      }
    }
  };
  const onEscapeKeyDown = e => {
    local.onEscapeKeyDown?.(e);
    optionalMenubarContext?.setAutoFocusMenu(false);
    context.close(true);
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (rootContext.isModal()) {
      e.preventDefault();
    }
  };
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (!context.isOpen()) {
      return;
    }
    context.parentMenuContext()?.listState().selectionManager().setFocused(false);
    context.parentMenuContext()?.listState().selectionManager().setFocusedKey(undefined);
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const target = e.target;
    const pointerXHasChanged = lastPointerX !== e.clientX;
    if (utils.contains(e.currentTarget, target) && pointerXHasChanged) {
      context.setPointerDir(e.clientX > lastPointerX ? "right" : "left");
      lastPointerX = e.clientX;
    }
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(local.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "menu",
            get id() {
              return local.id;
            },
            get tabIndex() {
              return selectableList.tabIndex();
            },
            get disableOutsidePointerEvents() {
              return web.memo(() => !!isRootModalContent())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            bypassTopMostLayerCheck: true,
            get style() {
              return {
                "--kb-menu-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.triggerId();
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            },
            get onKeyDown() {
              return utils.composeEventHandlers([local.onKeyDown, selectableList.onKeyDown, onKeyDown]);
            },
            get onMouseDown() {
              return utils.composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
            },
            get onFocusIn() {
              return utils.composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
            },
            get onFocusOut() {
              return utils.composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
            },
            onPointerEnter: onPointerEnter,
            onPointerMove: onPointerMove
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function MenuContent(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = solidJs.splitProps(props, ["ref"]);
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && rootContext.preventScroll()
  });
  return web.createComponent(MenuContentBase, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}

const MenuGroupContext = solidJs.createContext();
function useMenuGroupContext() {
  const context = solidJs.useContext(MenuGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuGroupContext` must be used within a `Menu.Group` component");
  }
  return context;
}

function MenuGroup(props) {
  const rootContext = useMenuRootContext();
  const mergedProps = utils.mergeDefaultProps({
    id: rootContext.generateId(`group-${solidJs.createUniqueId()}`)
  }, props);
  const [labelId, setLabelId] = solidJs.createSignal();
  const context = {
    generateId: utils.createGenerateId(() => mergedProps.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return web.createComponent(MenuGroupContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "group",
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, mergedProps));
    }
  });
}

function MenuGroupLabel(props) {
  const context = useMenuGroupContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabelId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    get id() {
      return local.id;
    },
    "aria-hidden": "true"
  }, others));
}

function MenuIcon(props) {
  const context = useMenuContext();
  const mergedProps = utils.mergeDefaultProps({
    children: ""
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}

function MenuItem(props) {
  return web.createComponent(MenuItemBase, web.mergeProps({
    role: "menuitem",
    closeOnSelect: true
  }, props));
}

function MenuItemDescription(props) {
  const context = useMenuItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescription(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function MenuItemIndicator(props) {
  const context = useMenuItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["forceMount"]);
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.forceMount || context.isChecked();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}

function MenuItemLabel(props) {
  const context = useMenuItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabel(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setLabelRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function MenuPortal(props) {
  const context = useMenuContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

const MenuRadioGroupContext = solidJs.createContext();
function useMenuRadioGroupContext() {
  const context = solidJs.useContext(MenuRadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRadioGroupContext` must be used within a `Menu.RadioGroup` component");
  }
  return context;
}

function MenuRadioGroup(props) {
  const rootContext = useMenuRootContext();
  const defaultId = rootContext.generateId(`radiogroup-${solidJs.createUniqueId()}`);
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value", "defaultValue", "onChange", "disabled"]);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const context = {
    isDisabled: () => local.disabled,
    isSelectedValue: value => value === selected(),
    setSelectedValue: setSelected
  };
  return web.createComponent(MenuRadioGroupContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(MenuGroup, others);
    }
  });
}

function MenuRadioItem(props) {
  const context = useMenuRadioGroupContext();
  const mergedProps = utils.mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value", "onSelect"]);
  const onSelect = () => {
    local.onSelect?.();
    context.setSelectedValue(local.value);
  };
  return web.createComponent(MenuItemBase, web.mergeProps({
    role: "menuitemradio",
    get checked() {
      return context.isSelectedValue(local.value);
    },
    onSelect: onSelect
  }, others));
}

function MenuRoot(props) {
  const defaultId = `menu-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    modal: true
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id", "modal", "preventScroll", "forceMount", "open", "defaultOpen", "onOpenChange", "value"]);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    isModal: () => local.modal ?? true,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    forceMount: () => local.forceMount ?? false,
    generateId: utils.createGenerateId(() => local.id),
    value: () => local.value
  };
  return web.createComponent(MenuRootContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Menu, web.mergeProps({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        }
      }, others));
    }
  });
}

function MenuSub(props) {
  const {
    direction
  } = useLocale();
  return web.createComponent(Menu, web.mergeProps({
    get placement() {
      return direction() === "rtl" ? "left-start" : "right-start";
    },
    flip: true
  }, props));
}

const SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function MenuSubContent(props) {
  const context = useMenuContext();
  const [local, others] = solidJs.splitProps(props, ["onFocusOutside", "onKeyDown", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const onOpenAutoFocus = e => {
    e.preventDefault();
  };
  const onCloseAutoFocus = e => {
    e.preventDefault();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    const target = e.target;
    if (!utils.contains(context.triggerRef(), target)) {
      context.close();
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    const isKeyDownInside = utils.contains(e.currentTarget, e.target);
    const isCloseKey = SUB_CLOSE_KEYS[direction()].includes(e.key);
    const isSubMenu = context.parentMenuContext() != null;
    if (isKeyDownInside && isCloseKey && isSubMenu) {
      context.close();
      utils.focusWithoutScrolling(context.triggerRef());
    }
  };
  return web.createComponent(MenuContentBase, web.mergeProps({
    onOpenAutoFocus: onOpenAutoFocus,
    onCloseAutoFocus: onCloseAutoFocus,
    onFocusOutside: onFocusOutside,
    onKeyDown: onKeyDown
  }, others));
}

const SELECTION_KEYS = ["Enter", " "];
const SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
function MenuSubTrigger(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const mergedProps = utils.mergeDefaultProps({
    id: rootContext.generateId(`sub-trigger-${solidJs.createUniqueId()}`)
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id", "textValue", "disabled", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  let openTimeoutId = null;
  const clearOpenTimeout = () => {
    if (web.isServer) {
      return;
    }
    if (openTimeoutId) {
      window.clearTimeout(openTimeoutId);
    }
    openTimeoutId = null;
  };
  const {
    direction
  } = useLocale();
  const key = () => local.id;
  const parentSelectionManager = () => {
    const parentMenuContext = context.parentMenuContext();
    if (parentMenuContext == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    return parentMenuContext.listState().selectionManager();
  };
  const collection = () => context.listState().collection();
  const isHighlighted = () => parentSelectionManager().focusedKey() === key();
  const selectableItem = createSelectableItem({
    key,
    selectionManager: parentSelectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!context.isOpen() && !local.disabled) {
      context.open(true);
    }
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const parentMenuContext = context.parentMenuContext();
    parentMenuContext?.onItemEnter(e);
    if (e.defaultPrevented) {
      return;
    }
    if (local.disabled) {
      parentMenuContext?.onItemLeave(e);
      return;
    }
    if (!context.isOpen() && !openTimeoutId) {
      context.parentMenuContext()?.setPointerGraceIntent(null);
      openTimeoutId = window.setTimeout(() => {
        context.open(false);
        clearOpenTimeout();
      }, 100);
    }
    parentMenuContext?.onItemEnter(e);
    if (!e.defaultPrevented) {
      if (context.listState().selectionManager().isFocused()) {
        context.listState().selectionManager().setFocused(false);
        context.listState().selectionManager().setFocusedKey(undefined);
      }
      utils.focusWithoutScrolling(e.currentTarget);
      parentMenuContext?.listState().selectionManager().setFocused(true);
      parentMenuContext?.listState().selectionManager().setFocusedKey(key());
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    clearOpenTimeout();
    const parentMenuContext = context.parentMenuContext();
    const contentEl = context.contentRef();
    if (contentEl) {
      parentMenuContext?.setPointerGraceIntent({
        area: getPointerGraceArea(context.currentPlacement(), e, contentEl),
        side: context.currentPlacement().split("-")[0]
      });
      window.clearTimeout(parentMenuContext?.pointerGraceTimeoutId());
      const pointerGraceTimeoutId = window.setTimeout(() => {
        parentMenuContext?.setPointerGraceIntent(null);
      }, 300);
      parentMenuContext?.setPointerGraceTimeoutId(pointerGraceTimeoutId);
    } else {
      parentMenuContext?.onTriggerLeave(e);
      if (e.defaultPrevented) {
        return;
      }
      parentMenuContext?.setPointerGraceIntent(null);
    }
    parentMenuContext?.onItemLeave(e);
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    if (SUB_OPEN_KEYS[direction()].includes(e.key)) {
      e.stopPropagation();
      e.preventDefault();
      parentSelectionManager().setFocused(false);
      parentSelectionManager().setFocusedKey(undefined);
      if (!context.isOpen()) {
        context.open("first");
      }
      context.focusContent();
      context.listState().selectionManager().setFocused(true);
      context.listState().selectionManager().setFocusedKey(collection().getFirstKey());
    }
  };
  solidJs.createEffect(() => {
    if (context.registerItemToParentDomCollection == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    const unregister = context.registerItemToParentDomCollection({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    });
    solidJs.onCleanup(unregister);
  });
  solidJs.createEffect(solidJs.on(() => context.parentMenuContext()?.pointerGraceTimeoutId(), pointerGraceTimer => {
    solidJs.onCleanup(() => {
      window.clearTimeout(pointerGraceTimer);
      context.parentMenuContext()?.setPointerGraceIntent(null);
    });
  }));
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(local.id)));
  solidJs.onCleanup(() => {
    clearOpenTimeout();
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    role: "menuitem",
    get tabIndex() {
      return selectableItem.tabIndex();
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["aria-disabled"]() {
      return local.disabled;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    },
    get onPointerDown() {
      return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return utils.composeEventHandlers([onClick, selectableItem.onClick]);
    },
    get onKeyDown() {
      return utils.composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    onPointerMove: onPointerMove,
    onPointerLeave: onPointerLeave
  }, () => context.dataset(), others));
}

function MenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const mergedProps = utils.mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id", "disabled", "onPointerDown", "onClick", "onKeyDown", "onMouseOver", "onFocus"]);
  let key;
  if (optionalMenubarContext !== undefined) {
    key = rootContext.value() ?? local.id;
    solidJs.createEffect(() => {
      optionalMenubarContext.registerMenu(key, [context.contentRef(), ...context.nestedMenus()]);
    });
    solidJs.createEffect(() => {
      if (optionalMenubarContext.value() === key) {
        context.triggerRef()?.focus();
        if (optionalMenubarContext.autoFocusMenu()) context.open(true);
      } else context.close(true);
    });
    solidJs.createEffect(() => {
      if (context.isOpen()) optionalMenubarContext.setValue(key);
    });
    solidJs.onCleanup(() => {
      optionalMenubarContext.unregisterMenu(key);
    });
    if (optionalMenubarContext.lastValue() === undefined) optionalMenubarContext.setLastValue(key);
  }
  const handleClick = () => {
    optionalMenubarContext?.setAutoFocusMenu(true);
    if (optionalMenubarContext !== undefined) context.toggle(false);else context.toggle(true);
    if (optionalMenubarContext !== undefined && !context.isOpen() && optionalMenubarContext.value() === key) {
      optionalMenubarContext.closeMenu();
    }
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!local.disabled && e.pointerType !== "touch" && e.button === 0) {
      handleClick();
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!local.disabled) {
      if (e.currentTarget.dataset.pointerType === "touch") handleClick();
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (local.disabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        utils.scrollIntoViewport(e.currentTarget);
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowRight":
        if (optionalMenubarContext === undefined) break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.nextMenu();
        break;
      case "ArrowLeft":
        if (optionalMenubarContext === undefined) break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.previousMenu();
        break;
    }
  };
  const onMouseOver = e => {
    utils.callHandler(e, local.onMouseOver);
    if (!local.disabled && optionalMenubarContext !== undefined && optionalMenubarContext.value() !== undefined) {
      optionalMenubarContext.setValue(key);
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (optionalMenubarContext !== undefined) optionalMenubarContext.setValue(key);
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(local.id)));
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get disabled() {
      return local.disabled;
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-highlighted"]() {
      return key !== undefined && optionalMenubarContext?.value() === key ? true : undefined;
    },
    get tabIndex() {
      return optionalMenubarContext !== undefined ? optionalMenubarContext.value() === key || optionalMenubarContext.lastValue() === key ? 0 : -1 : undefined;
    },
    onPointerDown: onPointerDown,
    onMouseOver: onMouseOver,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    role: optionalMenubarContext !== undefined ? "menuitem" : undefined
  }, () => context.dataset(), others));
}

function SeparatorRoot(props) {
  let ref;
  const mergedProps = utils.mergeDefaultProps({
    orientation: "horizontal"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "orientation"]);
  const tagName = createTagName(() => ref, () => "hr");
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "hr",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "hr" ? "separator" : undefined;
    },
    get ["aria-orientation"]() {
      return local.orientation === "vertical" ? "vertical" : undefined;
    },
    get ["data-orientation"]() {
      return local.orientation;
    }
  }, others));
}

var index$k = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: SeparatorRoot
});

function ContextMenuContent(props) {
  const rootContext = useMenuRootContext();
  const [local, others] = solidJs.splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!e.defaultPrevented && hasInteractedOutside) {
      e.preventDefault();
    }
    hasInteractedOutside = false;
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented && !rootContext.isModal()) {
      hasInteractedOutside = true;
    }
  };
  return web.createComponent(MenuContent, web.mergeProps({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
}

const ContextMenuContext = solidJs.createContext();
function useOptionalContextMenuContext() {
  return solidJs.useContext(ContextMenuContext);
}
function useContextMenuContext() {
  const context = useOptionalContextMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useContextMenuContext` must be used within a `ContextMenu` component");
  }
  return context;
}

function ContextMenuRoot(props) {
  const defaultId = `contextmenu-${solidJs.createUniqueId()}`;
  const {
    direction
  } = useLocale();
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    placement: direction() === "rtl" ? "left-start" : "right-start",
    gutter: 2,
    shift: 2
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["onOpenChange"]);
  const [anchorRect, setAnchorRect] = solidJs.createSignal({
    x: 0,
    y: 0
  });
  const disclosureState = createDisclosureState({
    defaultOpen: false,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    setAnchorRect
  };
  return web.createComponent(ContextMenuContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(MenuRoot, web.mergeProps({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        },
        getAnchorRect: anchorRect
      }, others));
    }
  });
}

function ContextMenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const context = useContextMenuContext();
  const mergedProps = utils.mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "style", "disabled", "onContextMenu", "onPointerDown", "onPointerMove", "onPointerCancel", "onPointerUp"]);
  let longPressTimoutId = 0;
  const clearLongPressTimeout = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(longPressTimoutId);
  };
  solidJs.onCleanup(() => {
    clearLongPressTimeout();
  });
  const onContextMenu = e => {
    if (local.disabled) {
      utils.callHandler(e, local.onContextMenu);
      return;
    }
    clearLongPressTimeout();
    e.preventDefault();
    e.stopPropagation();
    context.setAnchorRect({
      x: e.clientX,
      y: e.clientY
    });
    if (menuContext.isOpen()) {
      menuContext.focusContent();
    } else {
      menuContext.open(true);
    }
  };
  const isTouchOrPen = e => e.pointerType === "touch" || e.pointerType === "pen";
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
      context.setAnchorRect({
        x: e.clientX,
        y: e.clientY
      });
      longPressTimoutId = window.setTimeout(() => menuContext.open(false), 700);
    }
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  const onPointerCancel = e => {
    utils.callHandler(e, local.onPointerCancel);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(menuContext.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get style() {
      return {
        "-webkit-touch-callout": "none",
        ...local.style
      };
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    },
    onContextMenu: onContextMenu,
    onPointerDown: onPointerDown,
    onPointerMove: onPointerMove,
    onPointerCancel: onPointerCancel,
    onPointerUp: onPointerUp
  }, () => menuContext.dataset(), others));
}

var index$j = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	CheckboxItem: MenuCheckboxItem,
	Content: ContextMenuContent,
	Group: MenuGroup,
	GroupLabel: MenuGroupLabel,
	Icon: MenuIcon,
	Item: MenuItem,
	ItemDescription: MenuItemDescription,
	ItemIndicator: MenuItemIndicator,
	ItemLabel: MenuItemLabel,
	Portal: MenuPortal,
	RadioGroup: MenuRadioGroup,
	RadioItem: MenuRadioItem,
	Root: ContextMenuRoot,
	Separator: SeparatorRoot,
	Sub: MenuSub,
	SubContent: MenuSubContent,
	SubTrigger: MenuSubTrigger,
	Trigger: ContextMenuTrigger
});

const DatePickerContext = solidJs.createContext();
function useDatePickerContext() {
  const context = solidJs.useContext(DatePickerContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDatePickerContext` must be used within a `DatePicker` component");
  }
  return context;
}

function DatePickerCalendar(props) {
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("calendar")
  }, props);
  return web.createComponent(CalendarRoot, web.mergeProps({
    autoFocus: true,
    get selectionMode() {
      return context.selectionMode();
    },
    get value() {
      return context.dateValue();
    },
    get onChange() {
      return context.setDateValue;
    },
    get locale() {
      return context.locale();
    },
    get createCalendar() {
      return context.createCalendar;
    },
    get isDateUnavailable() {
      return context.isDateUnavailable;
    },
    get visibleDuration() {
      return context.visibleDuration();
    },
    get allowsNonContiguousRanges() {
      return context.allowsNonContiguousRanges();
    },
    get defaultFocusedValue() {
      return web.memo(() => !!context.dateValue())() ? undefined : context.placeholderValue();
    },
    get minValue() {
      return context.minValue();
    },
    get maxValue() {
      return context.maxValue();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readOnly() {
      return formControlContext.isReadOnly();
    },
    get validationState() {
      return context.validationState();
    }
  }, mergedProps));
}

function DatePickerContent(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "style", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "aria-labelledby"]);
  let isRightClickOutside = false;
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(context.triggerId(), others["aria-label"], local["aria-labelledby"]);
  };
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      if (!isRightClickOutside) {
        utils.focusWithoutScrolling(context.triggerRef());
      }
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          utils.focusWithoutScrolling(context.triggerRef());
        }
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.isModal()) {
      isRightClickOutside = e.detail.isContextMenu;
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.isModal()) {
      return;
    }
    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }
    if (utils.contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isModal() && context.isOpen()),
    targets: () => {
      const excludedElements = [];
      if (ref) {
        excludedElements.push(ref);
      }
      const controlEl = context.controlRef();
      if (controlEl) {
        excludedElements.push(controlEl);
      }
      return excludedElements;
    }
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isModal() && context.isOpen()
  });
  createFocusScope({
    trapFocus: () => context.isModal() && context.isOpen(),
    onMountAutoFocus: e => {
      e.preventDefault();
    },
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "dialog",
            tabIndex: -1,
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.controlRef];
            },
            get style() {
              return {
                "--kb-date-picker-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return ariaLabelledBy();
            },
            onPointerDownOutside: onPointerDownOutside,
            onFocusOutside: onFocusOutside,
            onInteractOutside: onInteractOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function DatePickerControl(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "onPointerDown", "onClick", "onKeyDown", "aria-labelledby"]);
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, others["aria-label"], local["aria-labelledby"]);
  };
  const focusLast = () => {
    if (!ref) {
      return;
    }
    let target = utils.getWindow(ref).event?.target;
    const walker = utils.getFocusableTreeWalker(ref, {
      tabbable: true
    });
    if (target) {
      walker.currentNode = target;
      target = walker.previousNode();
    }
    if (!target) {
      let last;
      do {
        last = walker.lastChild();
        if (last) {
          target = last;
        }
      } while (last);
    }
    while (target?.hasAttribute("data-placeholder")) {
      const prev = walker.previousNode();
      if (prev?.hasAttribute("data-placeholder")) {
        target = prev;
      } else {
        break;
      }
    }
    if (target) {
      target.focus();
    }
  };
  let pointerDownType = null;
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    pointerDownType = e.pointerType;
    if (e.pointerType === "mouse") {
      focusLast();
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (pointerDownType !== "mouse") {
      focusLast();
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.altKey && (e.key === "ArrowDown" || e.key === "ArrowUp")) {
      e.preventDefault();
      e.stopPropagation();
      context.open();
    }
    switch (e.key) {
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        if (context.direction() === "rtl") {
          context.focusManager().focusNext();
        } else {
          context.focusManager().focusPrevious();
        }
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        if (context.direction() === "rtl") {
          context.focusManager().focusPrevious();
        } else {
          context.focusManager().focusNext();
        }
        break;
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    role: "group",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setControlRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["aria-disabled"]() {
      return context.isDisabled() || undefined;
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return context.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const DatePickerInputContext = solidJs.createContext();
function useDatePickerInputContext() {
  const context = solidJs.useContext(DatePickerInputContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDatePickerInputContext` must be used within a `DatePicker.Input` component");
  }
  return context;
}

const DEFAULT_FIELD_OPTIONS = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  second: "2-digit"
};
const TWO_DIGIT_FIELD_OPTIONS = {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
};
function getDateFieldFormatOptions(fieldOptions, options) {
  const defaultFieldOptions = options.shouldForceLeadingZeros ? TWO_DIGIT_FIELD_OPTIONS : DEFAULT_FIELD_OPTIONS;
  const finalFieldOptions = {
    ...defaultFieldOptions,
    ...fieldOptions
  };
  const granularity = options.granularity || "minute";
  const keys = Object.keys(finalFieldOptions);
  let startIdx = keys.indexOf(options.maxGranularity ?? "year");
  if (startIdx < 0) {
    startIdx = 0;
  }
  let endIdx = keys.indexOf(granularity);
  if (endIdx < 0) {
    endIdx = 2;
  }
  if (startIdx > endIdx) {
    throw new Error("maxGranularity must be greater than granularity");
  }
  const opts = keys.slice(startIdx, endIdx + 1).reduce((opts, key) => {
    opts[key] = finalFieldOptions[key];
    return opts;
  }, {});
  if (options.hourCycle != null) {
    opts.hour12 = options.hourCycle === 12;
  }
  opts.timeZone = options.timeZone || "UTC";
  const hasTime = granularity === "hour" || granularity === "minute" || granularity === "second";
  if (hasTime && options.timeZone && !options.hideTimeZone) {
    opts.timeZoneName = "short";
  }
  if (options.showEra && startIdx === 0) {
    opts.era = "short";
  }
  return opts;
}
function getPlaceholderTime(placeholderValue) {
  if (placeholderValue && "hour" in placeholderValue) {
    return placeholderValue;
  }
  return new date.Time();
}
function convertValue(value, calendar) {
  if (value === null) {
    return null;
  }
  if (!value) {
    return undefined;
  }
  return date.toCalendar(value, calendar);
}
function createPlaceholderDate(placeholderValue, granularity, calendar, timeZone) {
  if (placeholderValue) {
    return convertValue(placeholderValue, calendar);
  }
  const date$1 = date.toCalendar(date.now(timeZone).set({
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }), calendar);
  if (granularity === "year" || granularity === "month" || granularity === "day") {
    return date.toCalendarDate(date$1);
  }
  if (!timeZone) {
    return date.toCalendarDateTime(date$1);
  }
  return date$1;
}
function createDefaultProps(props) {
  let lastValue;
  const value = solidJs.createMemo(() => {
    const resolvedValue = props.value();
    if (resolvedValue) {
      lastValue = resolvedValue;
    }
    return lastValue;
  });
  const defaultTimeZone = solidJs.createMemo(() => {
    const resolvedValue = value();
    if (resolvedValue && "timeZone" in resolvedValue) {
      return resolvedValue.timeZone;
    }
    return undefined;
  });
  const granularity = solidJs.createMemo(() => {
    const resolvedValue = value();
    return props.granularity() || (resolvedValue && "minute" in resolvedValue ? "minute" : "day");
  });
  solidJs.createEffect(() => {
    const resolvedValue = value();
    const resolvedGranularity = granularity();
    if (resolvedValue && !(resolvedGranularity in resolvedValue)) {
      throw new Error(`Invalid granularity ${resolvedGranularity} for value ${resolvedValue.toString()}`);
    }
  });
  return {
    granularity,
    defaultTimeZone
  };
}

const EDITABLE_SEGMENTS = {
  year: true,
  month: true,
  day: true,
  hour: true,
  minute: true,
  second: true,
  dayPeriod: true,
  era: true
};
const PAGE_STEP = {
  year: 5,
  month: 2,
  day: 7,
  hour: 2,
  minute: 15,
  second: 15
};
const TYPE_MAPPING = {
  dayperiod: "dayPeriod"
};
function DatePickerInput(props) {
  const formControlContext = useFormControlContext();
  const datePickerContext = useDatePickerContext();
  const mergedProps = utils.mergeDefaultProps({
    id: datePickerContext.generateId("input")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "children", "onFocusOut", "aria-labelledby", "aria-describedby"]);
  const timeZone = solidJs.createMemo(() => datePickerContext.defaultTimeZone() || "UTC");
  const defaultFormatter = solidJs.createMemo(() => new date.DateFormatter(datePickerContext.locale()));
  const calendar = solidJs.createMemo(() => {
    return datePickerContext.createCalendar(defaultFormatter().resolvedOptions().calendar);
  });
  const calendarValue = solidJs.createMemo(() => {
    if (datePickerContext.selectionMode() === "single") {
      return convertValue(asSingleValue(datePickerContext.dateValue()), calendar());
    }
    if (datePickerContext.selectionMode() === "multiple") ; else if (datePickerContext.selectionMode() === "range") ;
  });
  const [placeholderDate, setPlaceholderDate] = solidJs.createSignal(createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone()));
  const val = solidJs.createMemo(() => calendarValue() || placeholderDate());
  const showEra = solidJs.createMemo(() => calendar().identifier === "gregory" && val()?.era === "BC");
  const formatOpts = solidJs.createMemo(() => ({
    granularity: datePickerContext.granularity(),
    maxGranularity: datePickerContext.maxGranularity() ?? "year",
    timeZone: datePickerContext.defaultTimeZone(),
    hideTimeZone: datePickerContext.hideTimeZone(),
    hourCycle: datePickerContext.hourCycle(),
    showEra: showEra(),
    shouldForceLeadingZeros: datePickerContext.shouldForceLeadingZeros()
  }));
  const opts = solidJs.createMemo(() => getDateFieldFormatOptions({}, formatOpts()));
  const dateFormatter = solidJs.createMemo(() => new date.DateFormatter(datePickerContext.locale(), opts()));
  const resolvedOptions = solidJs.createMemo(() => dateFormatter().resolvedOptions());
  const ariaLabelledBy = solidJs.createMemo(() => {
    return formControlContext.getAriaLabelledBy(others.id, others["aria-label"], local["aria-labelledby"]);
  });
  const ariaDescribedBy = solidJs.createMemo(() => {
    return [local["aria-describedby"], datePickerContext.ariaDescribedBy()].filter(Boolean).join(" ");
  });
  const allSegments = solidJs.createMemo(() => {
    return dateFormatter().formatToParts(new Date()).filter(segment => EDITABLE_SEGMENTS[segment.type]).reduce((acc, segment) => {
      acc[segment.type] = true;
      return acc;
    }, {});
  });
  const [validSegments, setValidSegments] = solidJs.createSignal(datePickerContext.value() ? {
    ...allSegments()
  } : {});
  const displayValue = solidJs.createMemo(() => {
    return calendarValue() && Object.keys(validSegments()).length >= Object.keys(allSegments()).length ? calendarValue() : placeholderDate();
  });
  const setValue = newValue => {
    if (formControlContext.isDisabled() || formControlContext.isReadOnly()) {
      return;
    }
    if (datePickerContext.selectionMode() === "single") {
      if (Object.keys(validSegments()).length >= Object.keys(allSegments()).length) {
        const v = asSingleValue(datePickerContext.value() || datePickerContext.placeholderValue());
        datePickerContext.setDateValue(date.toCalendar(newValue, v?.calendar || new date.GregorianCalendar()));
      } else {
        setPlaceholderDate(newValue);
      }
    } else if (datePickerContext.selectionMode() === "multiple") ; else if (datePickerContext.selectionMode() === "range") ;
  };
  const dateValue = solidJs.createMemo(() => displayValue()?.toDate(timeZone()));
  const segments = solidJs.createMemo(() => {
    const resolvedDateValue = dateValue();
    const resolvedDisplayValue = displayValue();
    if (!resolvedDateValue || !resolvedDisplayValue) {
      return [];
    }
    return dateFormatter().formatToParts(resolvedDateValue).map(segment => {
      const isOriginallyEditable = EDITABLE_SEGMENTS[segment.type];
      let isEditable = isOriginallyEditable;
      if (segment.type === "era" && calendar().getEras().length === 1) {
        isEditable = false;
      }
      const isPlaceholder = isOriginallyEditable && !validSegments()[segment.type];
      const placeholder = isOriginallyEditable ? getPlaceholder(datePickerContext.translations(), segment.type, segment.value) : null;
      return {
        type: TYPE_MAPPING[segment.type] || segment.type,
        text: isPlaceholder ? placeholder : segment.value,
        ...getSegmentLimits(resolvedDisplayValue, segment.type, resolvedOptions()),
        isPlaceholder,
        placeholder,
        isEditable
      };
    });
  });
  const markValid = part => {
    setValidSegments(prev => {
      const newValue = {
        ...prev,
        [part]: true
      };
      if (part === "year" && allSegments().era) {
        newValue.era = true;
      }
      return newValue;
    });
  };
  const adjustSegment = (type, amount) => {
    const resolvedDisplayValue = displayValue();
    if (!validSegments()[type]) {
      markValid(type);
      if (resolvedDisplayValue && Object.keys(validSegments()).length >= Object.keys(allSegments()).length) {
        setValue(resolvedDisplayValue);
      }
    } else if (resolvedDisplayValue) {
      const newValue = addSegment(resolvedDisplayValue, type, amount, resolvedOptions());
      if (newValue) {
        setValue(newValue);
      }
    }
  };
  const increment = part => {
    adjustSegment(part, 1);
  };
  const decrement = part => {
    adjustSegment(part, -1);
  };
  const incrementPage = part => {
    adjustSegment(part, PAGE_STEP[part] || 1);
  };
  const decrementPage = part => {
    adjustSegment(part, -(PAGE_STEP[part] || 1));
  };
  const setSegment = (part, value) => {
    markValid(part);
    const resolvedDisplayValue = displayValue();
    if (resolvedDisplayValue) {
      const newValue = setSegmentBase(resolvedDisplayValue, part, value, resolvedOptions());
      if (newValue) {
        setValue(newValue);
      }
    }
  };
  const clearSegment = part => {
    setValidSegments(prev => {
      const newValue = {
        ...prev
      };
      delete newValue[part];
      return newValue;
    });
    const placeholder = createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone());
    const resolvedDisplayValue = displayValue();
    let value = resolvedDisplayValue;
    if (resolvedDisplayValue && placeholder) {
      if (part === "dayPeriod" && "hour" in resolvedDisplayValue && "hour" in placeholder) {
        const isPM = resolvedDisplayValue.hour >= 12;
        const shouldBePM = placeholder.hour >= 12;
        if (isPM && !shouldBePM) {
          value = resolvedDisplayValue.set({
            hour: resolvedDisplayValue.hour - 12
          });
        } else if (!isPM && shouldBePM) {
          value = resolvedDisplayValue.set({
            hour: resolvedDisplayValue.hour + 12
          });
        }
      } else if (part in resolvedDisplayValue) {
        value = resolvedDisplayValue.set({
          [part]: placeholder[part]
        });
      }
    }
    datePickerContext.setDateValue(undefined);
    if (value) {
      setValue(value);
    }
  };
  const formatValue = fieldOptions => {
    const resolvedDateValue = dateValue();
    if (!calendarValue() || !resolvedDateValue) {
      return "";
    }
    const formatOptions = getDateFieldFormatOptions(fieldOptions, formatOpts());
    const formatter = new date.DateFormatter(datePickerContext.locale(), formatOptions);
    return formatter.format(resolvedDateValue);
  };
  const onFocusOut = e => {
    utils.callHandler(e, local.onFocusOut);
    if (formControlContext.isDisabled() || formControlContext.isReadOnly()) {
      return;
    }
    const validKeys = Object.keys(validSegments());
    const allKeys = Object.keys(allSegments());
    if (validKeys.length === allKeys.length - 1 && allSegments().dayPeriod && !validSegments().dayPeriod) {
      setValidSegments({
        ...allSegments()
      });
      const resolvedDisplayValue = displayValue();
      if (resolvedDisplayValue) {
        setValue(resolvedDisplayValue.copy());
      }
    }
  };
  solidJs.createEffect(solidJs.on([calendar, timeZone, validSegments, () => datePickerContext.placeholderValue(), () => datePickerContext.granularity()], ([calendar, timeZone, validSegments, placeholderValue, granularity]) => {
    setPlaceholderDate(placeholder => {
      return Object.keys(validSegments).length > 0 ? convertValue(placeholder, calendar) : createPlaceholderDate(placeholderValue, granularity, calendar, timeZone);
    });
  }));
  solidJs.createEffect(() => {
    if (datePickerContext.value() && Object.keys(validSegments()).length < Object.keys(allSegments()).length) {
      setValidSegments({
        ...allSegments()
      });
    }
  });
  solidJs.createEffect(() => {
    if (datePickerContext.value() == null) {
      setValidSegments({});
      setPlaceholderDate(createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone()));
    }
  });
  solidJs.createEffect(() => {
    if (allSegments().era && validSegments().year && !validSegments().era) {
      setValidSegments(prev => ({
        ...prev,
        era: true
      }));
    } else if (!allSegments().era && validSegments().era) {
      setValidSegments(prev => {
        const newValue = {
          ...prev
        };
        newValue.era = undefined;
        return newValue;
      });
    }
  });
  const context = {
    calendar,
    dateValue,
    dateFormatterResolvedOptions: resolvedOptions,
    ariaLabel: () => others["aria-label"],
    ariaLabelledBy,
    ariaDescribedBy,
    segments,
    increment,
    decrement,
    incrementPage,
    decrementPage,
    setSegment,
    clearSegment,
    formatValue
  };
  return web.createComponent(DatePickerInputContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "presentation",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        onFocusOut: onFocusOut,
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        }
      }, () => datePickerContext.dataset(), () => formControlContext.dataset(), others, {
        get children() {
          return web.createComponent(solidJs.Index, {
            get each() {
              return segments();
            },
            children: segment => local.children?.(segment)
          });
        }
      }));
    }
  });
}
function getSegmentLimits(date$1, type, options) {
  switch (type) {
    case "era":
      {
        const eras = date$1.calendar.getEras();
        return {
          value: eras.indexOf(date$1.era),
          minValue: 0,
          maxValue: eras.length - 1
        };
      }
    case "year":
      return {
        value: date$1.year,
        minValue: 1,
        maxValue: date$1.calendar.getYearsInEra(date$1)
      };
    case "month":
      return {
        value: date$1.month,
        minValue: date.getMinimumMonthInYear(date$1),
        maxValue: date$1.calendar.getMonthsInYear(date$1)
      };
    case "day":
      return {
        value: date$1.day,
        minValue: date.getMinimumDayInMonth(date$1),
        maxValue: date$1.calendar.getDaysInMonth(date$1)
      };
  }
  if ("hour" in date$1) {
    switch (type) {
      case "dayPeriod":
        return {
          value: date$1.hour >= 12 ? 12 : 0,
          minValue: 0,
          maxValue: 12
        };
      case "hour":
        if (options.hour12) {
          const isPM = date$1.hour >= 12;
          return {
            value: date$1.hour,
            minValue: isPM ? 12 : 0,
            maxValue: isPM ? 23 : 11
          };
        }
        return {
          value: date$1.hour,
          minValue: 0,
          maxValue: 23
        };
      case "minute":
        return {
          value: date$1.minute,
          minValue: 0,
          maxValue: 59
        };
      case "second":
        return {
          value: date$1.second,
          minValue: 0,
          maxValue: 59
        };
    }
  }
  return {};
}
function addSegment(value, part, amount, options) {
  switch (part) {
    case "era":
    case "year":
    case "month":
    case "day":
      return value.cycle(part, amount, {
        round: part === "year"
      });
  }
  if ("hour" in value) {
    switch (part) {
      case "dayPeriod":
        {
          const hours = value.hour;
          const isPM = hours >= 12;
          return value.set({
            hour: isPM ? hours - 12 : hours + 12
          });
        }
      case "hour":
      case "minute":
      case "second":
        return value.cycle(part, amount, {
          round: part !== "hour",
          hourCycle: options.hour12 ? 12 : 24
        });
    }
  }
}
function setSegmentBase(value, part, segmentValue, options) {
  switch (part) {
    case "day":
    case "month":
    case "year":
    case "era":
      return value.set({
        [part]: segmentValue
      });
  }
  if ("hour" in value) {
    switch (part) {
      case "dayPeriod":
        {
          const hours = value.hour;
          const wasPM = hours >= 12;
          const isPM = segmentValue >= 12;
          if (isPM === wasPM) {
            return value;
          }
          return value.set({
            hour: wasPM ? hours - 12 : hours + 12
          });
        }
      case "hour":
        if (options.hour12) {
          const hours = value.hour;
          const wasPM = hours >= 12;
          if (!wasPM && segmentValue === 12) {
            segmentValue = 0;
          }
          if (wasPM && segmentValue < 12) {
            segmentValue += 12;
          }
        }
        return value.set({
          [part]: segmentValue
        });
      case "minute":
      case "second":
        return value.set({
          [part]: segmentValue
        });
    }
  }
}
function getPlaceholder(translations, field, value) {
  if (field === "era" || field === "dayPeriod") {
    return value;
  }
  if (field === "year" || field === "month" || field === "day") {
    return translations.placeholder[field];
  }
  return "";
}

function DatePickerPortal(props) {
  const context = useDatePickerContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

const DATE_PICKER_INTL_MESSAGES = {
  era: "era",
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  dayPeriod: "AM/PM",
  calendar: "Calendar",
  startDate: "Start Date",
  endDate: "End Date",
  weekday: "day of the week",
  timeZoneName: "time zone",
  selectedDateDescription: date => `Selected Date: ${date}`,
  selectedRangeDescription: (startDate, endDate) => `Selected Range: ${startDate} to ${endDate}`,
  selectedTimeDescription: time => `Selected Time: ${time}`,
  placeholder: {
    year: "yyyy",
    month: "mm",
    day: "dd"
  }
};

function DatePickerRoot(props) {
  const defaultId = `date-picker-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    visibleDuration: {
      months: 1
    },
    selectionMode: "single",
    maxGranularity: "year",
    hideTimeZone: false,
    shouldForceLeadingZeros: false,
    modal: false,
    gutter: 8,
    sameWidth: false,
    placement: "bottom-start",
    translations: DATE_PICKER_INTL_MESSAGES
  }, props);
  const [local, popperProps, formControlProps, others] = solidJs.splitProps(mergedProps, ["translations", "locale", "createCalendar", "visibleDuration", "selectionMode", "isDateUnavailable", "allowsNonContiguousRanges", "closeOnSelect", "minValue", "maxValue", "placeholderValue", "hourCycle", "granularity", "maxGranularity", "hideTimeZone", "shouldForceLeadingZeros", "validationState", "open", "defaultOpen", "onOpenChange", "value", "defaultValue", "onChange", "modal", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const [controlRef, setControlRef] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const locale = solidJs.createMemo(() => {
    return local.locale ?? useLocale().locale();
  });
  const direction = solidJs.createMemo(() => {
    return getReadingDirection(locale());
  });
  const focusManager = utils.createFocusManager(controlRef);
  const closeOnSelect = solidJs.createMemo(() => {
    return local.closeOnSelect ?? local.selectionMode !== "multiple";
  });
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const [selectedDate, setSelectedDate] = solidJs.createSignal();
  const [selectedTime, setSelectedTime] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const {
    granularity,
    defaultTimeZone
  } = createDefaultProps({
    value: () => getFirstValueOfSelection(local.selectionMode, value()) ?? local.placeholderValue,
    granularity: () => local.granularity
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const validationState = solidJs.createMemo(() => {
    if (local.validationState) {
      return local.validationState;
    }
    const values = getArrayValueOfSelection(local.selectionMode, value());
    if (values.length <= 0) {
      return undefined;
    }
    const isSomeDateInvalid = values.some(date => {
      return local.isDateUnavailable?.(date) || isDateInvalid(date, local.minValue, local.maxValue);
    });
    return isSomeDateInvalid ? "invalid" : undefined;
  });
  const {
    formControlContext
  } = createFormControl(solidJs.mergeProps(formControlProps, {
    get validationState() {
      return validationState();
    }
  }));
  createFormResetListener(contentRef, () => {
    setValue(local.defaultValue);
  });
  const hasTime = solidJs.createMemo(() => {
    return granularity() === "hour" || granularity() === "minute" || granularity() === "second";
  });
  const formattedValue = solidJs.createMemo(() => {
    const firstValue = getFirstValueOfSelection(local.selectionMode, value());
    if (!firstValue) {
      return "";
    }
    const formatOptions = getDateFieldFormatOptions({
      month: "long"
    }, {
      granularity: granularity(),
      timeZone: defaultTimeZone(),
      hideTimeZone: local.hideTimeZone,
      hourCycle: local.hourCycle,
      showEra: firstValue.calendar.identifier === "gregory" && firstValue.era === "BC"
    });
    const dateFormatter = solidJs.createMemo(() => new date.DateFormatter(locale(), formatOptions));
    const formatDate = date => {
      return date ? dateFormatter().format(date.toDate(defaultTimeZone() ?? "UTC")) : "";
    };
    let formattedValue;
    if (local.selectionMode === "single") {
      formattedValue = formatDate(asSingleValue(value()));
    } else if (local.selectionMode === "multiple") {
      formattedValue = asArrayValue(value())?.map(formatDate).join(", ");
    } else if (local.selectionMode === "range") ;
    return formattedValue ?? "";
  });
  const ariaDescribedBy = () => {
    let description = "";
    if (local.selectionMode === "single" || local.selectionMode === "multiple") {
      description = local.translations.selectedDateDescription(formattedValue());
    } else if (local.selectionMode === "range") ;
    return formControlContext.getAriaDescribedBy(description);
  };
  const commitSingleValue = (date$1, time) => {
    setValue("timeZone" in time ? time.set(date.toCalendarDate(date$1)) : date.toCalendarDateTime(date$1, time));
  };
  const selectDate = newValue => {
    if (local.selectionMode === "single") {
      if (hasTime()) {
        const resolvedSelectedTime = selectedTime();
        if (resolvedSelectedTime || closeOnSelect()) {
          commitSingleValue(newValue, resolvedSelectedTime || getPlaceholderTime(local.placeholderValue));
        } else {
          setSelectedDate(newValue);
        }
      } else {
        setValue(newValue);
      }
      if (closeOnSelect()) {
        disclosureState.close();
      }
    } else if (local.selectionMode === "multiple") {
      setValue(newValue);
    } else if (local.selectionMode === "range") ;
  };
  const selectTime = newValue => {
    if (local.selectionMode === "single") {
      const resolvedSelectedDate = selectedDate();
      if (resolvedSelectedDate && newValue) {
        commitSingleValue(resolvedSelectedDate, newValue);
      } else {
        setSelectedTime(newValue);
      }
    } else if (local.selectionMode === "range") ;
  };
  const close = () => {
    if (local.selectionMode === "single") {
      const resolvedSelectedDate = selectedDate();
      const resolvedSelectedTime = selectedTime();
      if (!value() && resolvedSelectedDate && hasTime()) {
        commitSingleValue(resolvedSelectedDate, resolvedSelectedTime || getPlaceholderTime(local.placeholderValue));
      }
    } else if (local.selectionMode === "range") ;
    disclosureState.close();
  };
  const toggle = () => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      disclosureState.open();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  solidJs.createEffect(solidJs.on(value, value => {
    if (!value) {
      setSelectedDate(undefined);
      setSelectedTime(undefined);
      return;
    }
    if (local.selectionMode === "single") {
      setSelectedDate(value);
      if ("hour" in value) {
        setSelectedTime(value);
      }
    } else if (local.selectionMode === "multiple") {
      setSelectedDate(value);
    } else if (local.selectionMode === "range") ;
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isModal: () => local.modal ?? false,
    contentPresence,
    translations: () => local.translations,
    granularity,
    maxGranularity: () => local.maxGranularity,
    hourCycle: () => local.hourCycle,
    hideTimeZone: () => local.hideTimeZone ?? false,
    defaultTimeZone,
    shouldForceLeadingZeros: () => local.shouldForceLeadingZeros ?? false,
    visibleDuration: () => local.visibleDuration,
    selectionMode: () => local.selectionMode,
    allowsNonContiguousRanges: () => local.allowsNonContiguousRanges ?? false,
    placeholderValue: () => local.placeholderValue,
    minValue: () => local.minValue,
    maxValue: () => local.maxValue,
    focusManager: () => focusManager,
    locale,
    direction,
    ariaDescribedBy,
    validationState,
    value,
    dateValue: selectedDate,
    timeValue: selectedTime,
    triggerId,
    contentId,
    controlRef,
    triggerRef,
    contentRef,
    setControlRef,
    setTriggerRef,
    setContentRef,
    createCalendar: name => local.createCalendar(name),
    isDateUnavailable: date => local.isDateUnavailable?.(date) ?? false,
    setDateValue: selectDate,
    setTimeValue: selectTime,
    open: disclosureState.open,
    close,
    toggle,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(DatePickerContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: controlRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return web.createComponent(Polymorphic, web.mergeProps({
                as: "div",
                role: "group",
                get id() {
                  return utils.access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

const SPIN_BUTTON_INTL_TRANSLATIONS = {
  empty: "Empty"
};

function SpinButtonRoot(props) {
  const mergedProps = utils.mergeDefaultProps({
    translations: SPIN_BUTTON_INTL_TRANSLATIONS
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["translations", "ref", "value", "textValue", "minValue", "maxValue", "validationState", "onIncrement", "onIncrementPage", "onDecrement", "onDecrementPage", "onDecrementToMin", "onIncrementToMax", "onKeyDown", "onFocus", "onBlur"]);
  let isFocused = false;
  const textValue = solidJs.createMemo(() => {
    if (local.textValue === "") {
      return local.translations?.empty;
    }
    return (local.textValue || `${local.value}`).replace("-", "\u2212");
  });
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey || props.readOnly) {
      return;
    }
    switch (e.key) {
      case "PageUp":
        if (local.onIncrementPage) {
          e.preventDefault();
          local.onIncrementPage();
          break;
        }
      case "ArrowUp":
      case "Up":
        if (local.onIncrement) {
          e.preventDefault();
          local.onIncrement();
        }
        break;
      case "PageDown":
        if (local.onDecrementPage) {
          e.preventDefault();
          local.onDecrementPage();
          break;
        }
      case "ArrowDown":
      case "Down":
        if (local.onDecrement) {
          e.preventDefault();
          local.onDecrement();
        }
        break;
      case "Home":
        if (local.onDecrementToMin) {
          e.preventDefault();
          local.onDecrementToMin();
        }
        break;
      case "End":
        if (local.onIncrementToMax) {
          e.preventDefault();
          local.onIncrementToMax();
        }
        break;
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    isFocused = true;
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    isFocused = false;
  };
  solidJs.createEffect(solidJs.on(textValue, textValue => {
    if (isFocused) {
      clearAnnouncer("assertive");
      announce(textValue ?? "", "assertive");
    }
  }));
  return web.createComponent(Polymorphic, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    as: "div",
    role: "spinbutton",
    get ["aria-valuenow"]() {
      return local.value != null && !Number.isNaN(local.value) ? local.value : null;
    },
    get ["aria-valuetext"]() {
      return textValue();
    },
    get ["aria-valuemin"]() {
      return local.minValue;
    },
    get ["aria-valuemax"]() {
      return local.maxValue;
    },
    get ["aria-required"]() {
      return props.required || undefined;
    },
    get ["aria-disabled"]() {
      return props.disabled || undefined;
    },
    get ["aria-readonly"]() {
      return props.readOnly || undefined;
    },
    get ["aria-invalid"]() {
      return local.validationState === "invalid" || undefined;
    },
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
}

function DatePickerSegment(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const datePickerContext = useDatePickerContext();
  const inputContext = useDatePickerInputContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "segment", "children", "onKeyDown", "onBeforeInput", "onInput", "onFocus"]);
  const [textValue, setTextValue] = solidJs.createSignal(local.segment.isPlaceholder ? "" : local.segment.text);
  const resolvedChildren = solidJs.children(() => local.children);
  let enteredKeys = "";
  let composition = "";
  const touchPropOverrides = solidJs.createMemo(() => {
    return utils.isIOS() || local.segment.type === "timeZoneName" ? {
      role: "textbox",
      "aria-valuemax": undefined,
      "aria-valuemin": undefined,
      "aria-valuetext": undefined,
      "aria-valuenow": undefined
    } : {};
  });
  const firstSegment = solidJs.createMemo(() => inputContext.segments().find(s => s.isEditable));
  const name = solidJs.createMemo(() => {
    return local.segment.type === "literal" ? "" : datePickerContext.translations()[local.segment.type];
  });
  const ariaLabel = solidJs.createMemo(() => {
    return `${name()}${inputContext.ariaLabel() ? `, ${inputContext.ariaLabel()}` : ""}${inputContext.ariaLabelledBy() ? ", " : ""}`;
  });
  const ariaDescribedBy = solidJs.createMemo(() => {
    if (local.segment !== firstSegment() && formControlContext.validationState() !== "invalid") {
      return undefined;
    }
    return inputContext.ariaDescribedBy();
  });
  const isEditable = solidJs.createMemo(() => {
    return !formControlContext.isDisabled() && !formControlContext.isReadOnly() && local.segment.isEditable;
  });
  const inputMode = solidJs.createMemo(() => {
    return formControlContext.isDisabled() || local.segment.type === "dayPeriod" || local.segment.type === "era" || !isEditable() ? undefined : "numeric";
  });
  const filter = createFilter({
    sensitivity: "base"
  });
  const options = solidJs.createMemo(() => inputContext.dateFormatterResolvedOptions());
  const eraFormatter = createDateFormatter({
    year: "numeric",
    era: "narrow",
    timeZone: "UTC"
  });
  const monthDateFormatter = createDateFormatter(() => ({
    month: "long",
    timeZone: options().timeZone
  }));
  const hourDateFormatter = createDateFormatter(() => ({
    hour: "numeric",
    hour12: options().hour12,
    timeZone: options().timeZone
  }));
  const amPmFormatter = createDateFormatter({
    hour: "numeric",
    hour12: true
  });
  const eras = solidJs.createMemo(() => {
    if (local.segment.type !== "era") {
      return [];
    }
    const date$1 = date.toCalendar(new date.CalendarDate(1, 1, 1), inputContext.calendar());
    const eras = inputContext.calendar().getEras().map(era => {
      const eraDate = date$1.set({
        year: 1,
        month: 1,
        day: 1,
        era
      }).toDate("UTC");
      const parts = eraFormatter().formatToParts(eraDate);
      const formatted = parts.find(p => p.type === "era")?.value ?? "";
      return {
        era,
        formatted
      };
    });
    const prefixLength = commonPrefixLength(eras.map(era => era.formatted));
    if (prefixLength) {
      for (const era of eras) {
        era.formatted = era.formatted.slice(prefixLength);
      }
    }
    return eras;
  });
  const am = solidJs.createMemo(() => {
    const date = new Date();
    date.setHours(0);
    return amPmFormatter().formatToParts(date).find(part => part.type === "dayPeriod")?.value ?? "";
  });
  const pm = solidJs.createMemo(() => {
    const date = new Date();
    date.setHours(12);
    return amPmFormatter().formatToParts(date).find(part => part.type === "dayPeriod")?.value ?? "";
  });
  const numberParser = solidJs.createMemo(() => {
    return new number.NumberParser(datePickerContext.locale(), {
      maximumFractionDigits: 0
    });
  });
  const onBackspaceKeyDown = () => {
    if (numberParser().isValidPartialNumber(local.segment.text) && !formControlContext.isReadOnly() && !local.segment.isPlaceholder) {
      const newValue = local.segment.text.slice(0, -1);
      const parsed = numberParser().parse(newValue);
      if (newValue.length === 0 || parsed === 0) {
        inputContext.clearSegment(local.segment.type);
      } else {
        inputContext.setSegment(local.segment.type, parsed);
      }
      enteredKeys = newValue;
    } else if (local.segment.type === "dayPeriod") {
      inputContext.clearSegment(local.segment.type);
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === "a" && (utils.isMac() ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
    }
    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {
      return;
    }
    switch (e.key) {
      case "Backspace":
      case "Delete":
        {
          e.preventDefault();
          e.stopPropagation();
          onBackspaceKeyDown();
          break;
        }
    }
  };
  const onInputBase = key => {
    if (formControlContext.isDisabled() || formControlContext.isReadOnly()) {
      return;
    }
    const newValue = enteredKeys + key;
    switch (local.segment.type) {
      case "dayPeriod":
        if (filter.startsWith(am(), key)) {
          inputContext.setSegment("dayPeriod", 0);
        } else if (filter.startsWith(pm(), key)) {
          inputContext.setSegment("dayPeriod", 12);
        } else {
          break;
        }
        datePickerContext.focusManager().focusNext();
        break;
      case "era":
        {
          const matched = eras().find(e => filter.startsWith(e.formatted, key));
          if (matched) {
            inputContext.setSegment("era", +matched.era);
            datePickerContext.focusManager().focusNext();
          }
          break;
        }
      case "day":
      case "hour":
      case "minute":
      case "second":
      case "month":
      case "year":
        {
          if (!numberParser().isValidPartialNumber(newValue)) {
            return;
          }
          let numberValue = numberParser().parse(newValue);
          let segmentValue = numberValue;
          let allowsZero = local.segment.minValue === 0;
          if (local.segment.type === "hour" && inputContext.dateFormatterResolvedOptions().hour12) {
            switch (inputContext.dateFormatterResolvedOptions().hourCycle) {
              case "h11":
                if (numberValue > 11) {
                  segmentValue = numberParser().parse(key);
                }
                break;
              case "h12":
                allowsZero = false;
                if (numberValue > 12) {
                  segmentValue = numberParser().parse(key);
                }
                break;
            }
            if (local.segment.value != null && local.segment.value >= 12 && numberValue > 1) {
              numberValue += 12;
            }
          } else if (local.segment.maxValue != null && numberValue > local.segment.maxValue) {
            segmentValue = numberParser().parse(key);
          }
          if (Number.isNaN(numberValue)) {
            return;
          }
          const shouldSetValue = segmentValue !== 0 || allowsZero;
          if (shouldSetValue) {
            inputContext.setSegment(local.segment.type, segmentValue);
          }
          if (local.segment.maxValue != null && Number(`${numberValue}0`) > local.segment.maxValue || newValue.length >= String(local.segment.maxValue).length) {
            enteredKeys = "";
            if (shouldSetValue) {
              datePickerContext.focusManager().focusNext();
            }
          } else {
            enteredKeys = newValue;
          }
          break;
        }
    }
  };
  const onBeforeInput = e => {
    utils.callHandler(e, local.onBeforeInput);
    e.preventDefault();
    switch (e.inputType) {
      case "deleteContentBackward":
      case "deleteContentForward":
        if (numberParser().isValidPartialNumber(local.segment.text) && !formControlContext.isReadOnly()) {
          onBackspaceKeyDown();
        }
        break;
      case "insertCompositionText":
        if (ref) {
          composition = ref.textContent;
          ref.textContent = ref.textContent;
        }
        break;
      default:
        if (e.data != null) {
          onInputBase(e.data);
        }
        break;
    }
  };
  const onInput = e => {
    utils.callHandler(e, local.onInput);
    const {
      inputType,
      data
    } = e;
    if (ref && data != null) {
      switch (inputType) {
        case "insertCompositionText":
          ref.textContent = composition;
          if (filter.startsWith(am(), data) || filter.startsWith(pm(), data)) {
            onInputBase(data);
          }
          break;
      }
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (ref) {
      enteredKeys = "";
      utils.scrollIntoViewport(ref, {
        containingElement: utils.getScrollParent(ref)
      });
      const selection = utils.getWindow(ref).getSelection();
      selection?.collapse(ref);
    }
  };
  const onIncrement = () => {
    enteredKeys = "";
    inputContext.increment(local.segment.type);
  };
  const onDecrement = () => {
    enteredKeys = "";
    inputContext.decrement(local.segment.type);
  };
  const onIncrementPage = () => {
    enteredKeys = "";
    inputContext.incrementPage(local.segment.type);
  };
  const onDecrementPage = () => {
    enteredKeys = "";
    inputContext.decrementPage(local.segment.type);
  };
  const onDecrementToMin = () => {
    if (local.segment.minValue == null) {
      return;
    }
    enteredKeys = "";
    inputContext.setSegment(local.segment.type, local.segment.minValue);
  };
  const onIncrementToMax = () => {
    if (local.segment.maxValue == null) {
      return;
    }
    enteredKeys = "";
    inputContext.setSegment(local.segment.type, local.segment.maxValue);
  };
  solidJs.createEffect(() => {
    const resolvedDateValue = inputContext.dateValue();
    if (resolvedDateValue) {
      if (local.segment.type === "month" && !local.segment.isPlaceholder) {
        const monthTextValue = monthDateFormatter().format(resolvedDateValue);
        setTextValue(prev => monthTextValue !== prev ? `${prev}  ${monthTextValue}` : monthTextValue);
      } else if (local.segment.type === "hour" && !local.segment.isPlaceholder) {
        setTextValue(hourDateFormatter().format(resolvedDateValue));
      }
    } else {
      setTextValue(local.segment.isPlaceholder ? "" : local.segment.text);
    }
  });
  solidJs.createEffect(solidJs.on([() => ref, () => datePickerContext.focusManager()], ([ref, focusManager]) => {
    const element = ref;
    solidJs.onCleanup(() => {
      if (utils.getActiveElement(element) === element) {
        const prev = focusManager.focusPrevious();
        if (!prev) {
          focusManager.focusNext();
        }
      }
    });
  }));
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.segment.type !== "literal";
    },
    get fallback() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        "aria-hidden": true,
        "data-separator": ""
      }, others, {
        get children() {
          return local.segment.text;
        }
      }));
    },
    get children() {
      return web.createComponent(SpinButtonRoot, web.mergeProps({
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return formControlContext.isDisabled() ? undefined : 0;
        },
        get value() {
          return local.segment.value;
        },
        get textValue() {
          return textValue();
        },
        get minValue() {
          return local.segment.minValue;
        },
        get maxValue() {
          return local.segment.maxValue;
        },
        get validationState() {
          return formControlContext.validationState();
        },
        get required() {
          return formControlContext.isRequired();
        },
        get disabled() {
          return formControlContext.isDisabled();
        },
        get readOnly() {
          return formControlContext.isReadOnly() || !local.segment.isEditable;
        },
        get contentEditable() {
          return isEditable();
        },
        get inputMode() {
          return inputMode();
        },
        get autocorrect() {
          return isEditable() ? "off" : undefined;
        },
        get autoCapitalize() {
          return isEditable() ? "off" : undefined;
        },
        get spellcheck() {
          return isEditable() ? false : undefined;
        },
        get enterkeyhint() {
          return isEditable() ? "next" : undefined;
        },
        style: {
          "caret-color": "transparent"
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        get ["aria-labelledby"]() {
          return inputContext.ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        },
        get ["data-placeholder"]() {
          return local.segment.isPlaceholder ? "" : undefined;
        },
        onKeyDown: onKeyDown,
        onBeforeInput: onBeforeInput,
        onInput: onInput,
        onFocus: onFocus,
        onIncrement: onIncrement,
        onDecrement: onDecrement,
        onIncrementPage: onIncrementPage,
        onDecrementPage: onDecrementPage,
        onDecrementToMin: onDecrementToMin,
        onIncrementToMax: onIncrementToMax
      }, () => datePickerContext.dataset(), () => formControlContext.dataset(), others, touchPropOverrides, {
        get children() {
          return web.createComponent(solidJs.Show, {
            get when() {
              return resolvedChildren();
            },
            get fallback() {
              return local.segment.text;
            },
            get children() {
              return resolvedChildren();
            }
          });
        }
      }));
    }
  });
}
function commonPrefixLength(strings) {
  strings.sort();
  const first = strings[0];
  const last = strings[strings.length - 1];
  for (let i = 0; i < first.length; i++) {
    if (first[i] !== last[i]) {
      return i;
    }
  }
  return 0;
}

function DatePickerTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "disabled", "onPointerDown", "onClick", "aria-labelledby"]);
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.stopPropagation();
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    e.stopPropagation();
    if (!isDisabled()) {
      context.toggle();
    }
  };
  const ariaLabel = solidJs.createMemo(() => {
    return context.translations().calendar;
  });
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, ariaLabel(), local["aria-labelledby"]);
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(others.id)));
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get disabled() {
      return isDisabled();
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["aria-label"]() {
      return ariaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return context.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$i = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Calendar: DatePickerCalendar,
	CalendarBody: CalendarBody,
	CalendarGrid: CalendarGrid,
	CalendarGridBody: CalendarGridBody,
	CalendarGridBodyCell: CalendarGridBodyCell,
	CalendarGridBodyCellTrigger: CalendarGridBodyCellTrigger,
	CalendarGridBodyRow: CalendarGridBodyRow,
	CalendarGridHeader: CalendarGridHeader,
	CalendarGridHeaderCell: CalendarGridHeaderCell,
	CalendarGridHeaderRow: CalendarGridHeaderRow,
	CalendarHeader: CalendarHeader,
	CalendarHeading: CalendarHeading,
	CalendarNextTrigger: CalendarNextTrigger,
	CalendarPrevTrigger: CalendarPrevTrigger,
	Content: DatePickerContent,
	Control: DatePickerControl,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Input: DatePickerInput,
	Portal: DatePickerPortal,
	Root: DatePickerRoot,
	Segment: DatePickerSegment,
	Trigger: DatePickerTrigger
});

function DropdownMenuContent(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = solidJs.splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!hasInteractedOutside) {
      utils.focusWithoutScrolling(context.triggerRef());
    }
    hasInteractedOutside = false;
    e.preventDefault();
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!rootContext.isModal() || e.detail.isContextMenu) {
      hasInteractedOutside = true;
    }
  };
  return web.createComponent(MenuContent, web.mergeProps({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
}

function DropdownMenuRoot(props) {
  const defaultId = `dropdownmenu-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  return web.createComponent(MenuRoot, mergedProps);
}

var index$h = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	CheckboxItem: MenuCheckboxItem,
	Content: DropdownMenuContent,
	Group: MenuGroup,
	GroupLabel: MenuGroupLabel,
	Icon: MenuIcon,
	Item: MenuItem,
	ItemDescription: MenuItemDescription,
	ItemIndicator: MenuItemIndicator,
	ItemLabel: MenuItemLabel,
	Portal: MenuPortal,
	RadioGroup: MenuRadioGroup,
	RadioItem: MenuRadioItem,
	Root: DropdownMenuRoot,
	Separator: SeparatorRoot,
	Sub: MenuSub,
	SubContent: MenuSubContent,
	SubTrigger: MenuSubTrigger,
	Trigger: MenuTrigger
});

const HoverCardContext = solidJs.createContext();
function useHoverCardContext() {
  const context = solidJs.useContext(HoverCardContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useHoverCardContext` must be used within a `HoverCard` component");
  }
  return context;
}

function HoverCardContent(props) {
  const context = useHoverCardContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "style"]);
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            disableOutsidePointerEvents: false,
            get style() {
              return {
                "--kb-hovercard-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function HoverCardPortal(props) {
  const context = useHoverCardContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

function getHoverCardSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

function HoverCardRoot(props) {
  const defaultId = `hovercard-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id", "open", "defaultOpen", "onOpenChange", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let openTimeoutId;
  let closeTimeoutId;
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(others.placement);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const {
    addGlobalListener,
    removeGlobalListener
  } = utils.createGlobalListeners();
  const openWithDelay = () => {
    if (web.isServer) {
      return;
    }
    openTimeoutId = window.setTimeout(() => {
      openTimeoutId = undefined;
      disclosureState.open();
    }, local.openDelay);
  };
  const closeWithDelay = () => {
    if (web.isServer) {
      return;
    }
    closeTimeoutId = window.setTimeout(() => {
      closeTimeoutId = undefined;
      disclosureState.close();
    }, local.closeDelay);
  };
  const cancelOpening = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(openTimeoutId);
    openTimeoutId = undefined;
  };
  const cancelClosing = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnHoverCard = target => {
    return utils.contains(triggerRef(), target) || utils.contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getHoverCardSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;
    if (isTargetOnHoverCard(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());
      if (polygon && utils.isPointInPolygon(utils.getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }
    if (closeTimeoutId) {
      return;
    }
    closeWithDelay();
  };
  solidJs.createEffect(() => {
    if (!disclosureState.isOpen()) {
      return;
    }
    addGlobalListener(document, "pointermove", onHoverOutside, true);
    solidJs.onCleanup(() => {
      removeGlobalListener(document, "pointermove", onHoverOutside, true);
    });
  });
  solidJs.onCleanup(() => {
    cancelOpening();
    cancelClosing();
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresence,
    openWithDelay,
    closeWithDelay,
    cancelOpening,
    cancelClosing,
    close: disclosureState.close,
    isTargetOnHoverCard,
    setTriggerRef,
    setContentRef
  };
  return web.createComponent(HoverCardContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(PopperRoot, web.mergeProps({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
}

function HoverCardTrigger(props) {
  const context = useHoverCardContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onFocus", "onBlur", "onTouchStart"]);
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || others.disabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }
    context.cancelOpening();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (others.disabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.cancelOpening();
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnHoverCard(relatedTarget)) {
      return;
    }
    context.closeWithDelay();
  };
  solidJs.onCleanup(context.cancelOpening);
  return web.createComponent(LinkRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), others));
}

var index$g = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: HoverCardContent,
	Portal: HoverCardPortal,
	Root: HoverCardRoot,
	Trigger: HoverCardTrigger
});

const ImageContext = solidJs.createContext();
function useImageContext() {
  const context = solidJs.useContext(ImageContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useImageContext` must be used within an `Image.Root` component");
  }
  return context;
}

function ImageFallback(props) {
  const context = useImageContext();
  const [canRender, setCanRender] = solidJs.createSignal(context.fallbackDelay() === undefined);
  solidJs.createEffect(() => {
    const delayMs = context.fallbackDelay();
    if (delayMs !== undefined) {
      const timerId = window.setTimeout(() => setCanRender(true), delayMs);
      solidJs.onCleanup(() => window.clearTimeout(timerId));
    }
  });
  return web.createComponent(solidJs.Show, {
    get when() {
      return web.memo(() => !!canRender())() && context.imageLoadingStatus() !== "loaded";
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "span"
      }, props));
    }
  });
}

const _tmpl$$e = /*#__PURE__*/web.template(`<img>`);
function ImageImg(props) {
  const context = useImageContext();
  const [loadingStatus, setLoadingStatus] = solidJs.createSignal("idle");
  solidJs.createEffect(solidJs.on(() => props.src, src => {
    if (!src) {
      setLoadingStatus("error");
      return;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = status => () => {
      if (!isMounted) {
        return;
      }
      setLoadingStatus(status);
    };
    setLoadingStatus("loading");
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = src;
    solidJs.onCleanup(() => {
      isMounted = false;
    });
  }));
  solidJs.createEffect(() => {
    const imageLoadingStatus = loadingStatus();
    if (imageLoadingStatus !== "idle") {
      context.onImageLoadingStatusChange(imageLoadingStatus);
    }
  });
  return web.createComponent(solidJs.Show, {
    get when() {
      return loadingStatus() === "loaded";
    },
    get children() {
      const _el$ = _tmpl$$e();
      web.spread(_el$, props, false, false);
      return _el$;
    }
  });
}

function ImageRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["fallbackDelay", "onLoadingStatusChange"]);
  const [imageLoadingStatus, setImageLoadingStatus] = solidJs.createSignal("idle");
  const context = {
    fallbackDelay: () => local.fallbackDelay,
    imageLoadingStatus,
    onImageLoadingStatusChange: status => {
      setImageLoadingStatus(status);
      local.onLoadingStatusChange?.(status);
    }
  };
  return web.createComponent(ImageContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "span"
      }, others));
    }
  });
}

var index$f = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Fallback: ImageFallback,
	Img: ImageImg,
	Root: ImageRoot
});

function MenubarMenu(props) {
  const menubarContext = useMenubarContext();
  const mergedProps = utils.mergeDefaultProps({
    modal: false
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value"]);
  const uniqueid = solidJs.createUniqueId();
  const defaultId = menubarContext.generateId(`menubar-menu-${uniqueid}`);
  const mergedPropsWithId = utils.mergeDefaultProps({
    id: defaultId
  }, mergedProps);
  return web.createComponent(MenuRoot, web.mergeProps({
    get value() {
      return local.value ?? uniqueid;
    }
  }, mergedPropsWithId));
}

function MenubarRoot(props) {
  let ref;
  const defaultId = `menubar-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    loop: true
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "value", "defaultValue", "onValueChange", "loop", "focusOnAlt"]);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onValueChange?.(value)
  });
  const [lastValue, setLastValue] = solidJs.createSignal();
  const [menuRefs, setMenuRefs] = solidJs.createSignal(new Map());
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": value() !== undefined ? "" : undefined,
    "data-closed": value() === undefined ? "" : undefined
  }));
  const [autoFocusMenu, setAutoFocusMenu] = solidJs.createSignal(false);
  const context = {
    dataset,
    value,
    setValue,
    lastValue,
    setLastValue,
    menus: () => new Set([...menuRefs().keys()]),
    menuRefs: () => [...menuRefs().values()].flat(),
    registerMenu: (value, refs) => {
      setMenuRefs(prev => {
        prev.set(value, refs);
        return prev;
      });
    },
    unregisterMenu: value => {
      setMenuRefs(prev => {
        prev.delete(value);
        return prev;
      });
    },
    nextMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === undefined) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === menusArray.length - 1) {
        if (local.loop) setValue(menusArray[0]);
        return;
      }
      setValue(menusArray[currentIndex + 1]);
    },
    previousMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === undefined) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === 0) {
        if (local.loop) setValue(menusArray[menusArray.length - 1]);
        return;
      }
      setValue(menusArray[currentIndex - 1]);
    },
    closeMenu: () => {
      setAutoFocusMenu(false);
      setValue(undefined);
    },
    autoFocusMenu,
    setAutoFocusMenu,
    generateId: utils.createGenerateId(() => others.id)
  };
  createInteractOutside({
    onInteractOutside: () => {
      context.closeMenu();
    },
    shouldExcludeElement: element => {
      return [ref, ...menuRefs().values()].flat().some(ref => utils.contains(ref, element));
    }
  }, () => ref);
  const keydownHandler = e => {
    if (e.key === "Alt") {
      e.preventDefault();
      e.stopPropagation();
      if (context.value() === undefined) context.nextMenu();else context.closeMenu();
    }
  };
  solidJs.createEffect(() => {
    if (web.isServer) return;
    if (local.focusOnAlt) window.addEventListener("keydown", keydownHandler);else window.removeEventListener("keydown", keydownHandler);
  });
  solidJs.createEffect(() => {
    if (value() !== undefined) setLastValue(value());
  });
  solidJs.onCleanup(() => {
    if (web.isServer) return;
    window.removeEventListener("keydown", keydownHandler);
  });
  return web.createComponent(MenubarContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others, {
        role: "menubar",
        "data-orientation": "horizontal"
      }));
    }
  });
}

var index$e = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	CheckboxItem: MenuCheckboxItem,
	Content: MenuContent,
	Group: MenuGroup,
	GroupLabel: MenuGroupLabel,
	Icon: MenuIcon,
	Item: MenuItem,
	ItemDescription: MenuItemDescription,
	ItemIndicator: MenuItemIndicator,
	ItemLabel: MenuItemLabel,
	Menu: MenubarMenu,
	Portal: MenuPortal,
	RadioGroup: MenuRadioGroup,
	RadioItem: MenuRadioItem,
	Root: MenubarRoot,
	Separator: SeparatorRoot,
	Sub: MenuSub,
	SubContent: MenuSubContent,
	SubTrigger: MenuSubTrigger,
	Trigger: MenuTrigger
});

const NumberFieldContext = solidJs.createContext();
function useNumberFieldContext() {
  const context = solidJs.useContext(NumberFieldContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useNumberFieldContext` must be used within a `NumberField` component");
  }
  return context;
}

function NumberFieldVaryTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useNumberFieldContext();
  const [local, others] = solidJs.splitProps(props, ["numberFieldVaryType", "onClick"]);
  return web.createComponent(ButtonRoot, web.mergeProps({
    tabIndex: -1,
    get disabled() {
      return formControlContext.isDisabled() || context.rawValue() === (local.numberFieldVaryType === "increment" ? context.maxValue() : context.minValue());
    },
    get ["aria-controls"]() {
      return formControlContext.fieldId();
    },
    onClick: e => {
      utils.callHandler(e, local.onClick);
      context.varyValue(context.step() * (local.numberFieldVaryType === "increment" ? 1 : -1));
      context.inputRef()?.focus();
    }
  }, others));
}

function NumberFieldDecrementTrigger(props) {
  return web.createComponent(NumberFieldVaryTrigger, web.mergeProps({
    numberFieldVaryType: "decrement"
  }, props));
}

const _tmpl$$d = /*#__PURE__*/web.template(`<div aria-hidden="true"><input type="text" tabindex="-1">`);
function NumberFieldHiddenInput(props) {
  const context = useNumberFieldContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onChange"]);
  const formControlContext = useFormControlContext();
  return (() => {
    const _el$ = _tmpl$$d(),
      _el$2 = _el$.firstChild;
    _el$2.addEventListener("change", e => {
      utils.callHandler(e, local.onChange);
      solidJs.batch(() => {
        context.setValue(e.target.value);
        context.format();
      });
    });
    const _ref$ = utils.mergeRefs(context.setHiddenInputRef, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$2);
    _el$2.style.setProperty("font-size", "16px");
    web.spread(_el$2, web.mergeProps({
      get name() {
        return formControlContext.name();
      },
      get value() {
        return web.memo(() => !!Number.isNaN(context.rawValue()))() ? "" : context.rawValue();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readOnly() {
        return formControlContext.isReadOnly();
      }
    }, others), false, false);
    web.effect(_$p => web.style(_el$, utils.visuallyHiddenStyles, _$p));
    return _el$;
  })();
}

function NumberFieldIncrementTrigger(props) {
  return web.createComponent(NumberFieldVaryTrigger, web.mergeProps({
    numberFieldVaryType: "increment"
  }, props));
}

function NumberFieldInput(props) {
  const formControlContext = useFormControlContext();
  const context = useNumberFieldContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("input"),
    inputMode: "decimal",
    autocomplete: "off",
    autocorrect: "off",
    spellcheck: false
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "onInput", "onChange", "onWheel"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  return web.createComponent(SpinButtonRoot, {
    get value() {
      return context.value();
    },
    get validationState() {
      return formControlContext.validationState();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readOnly() {
      return formControlContext.isReadOnly();
    },
    get textValue() {
      return context.textValue();
    },
    get minValue() {
      return context.minValue();
    },
    get maxValue() {
      return context.maxValue();
    },
    onIncrement: () => {
      context.varyValue(context.step());
    },
    onIncrementPage: () => {
      context.varyValue(context.largeStep());
    },
    onIncrementToMax: () => {
      context.setValue(context.maxValue());
      context.format();
    },
    onDecrement: () => {
      context.varyValue(-context.step());
    },
    onDecrementPage: () => {
      context.varyValue(-context.largeStep());
    },
    onDecrementToMin: () => {
      context.setValue(context.minValue());
      context.format();
    },
    get translations() {
      return context.translations();
    },
    asChild: true,
    get children() {
      return web.createComponent(As, web.mergeProps({
        component: "input",
        type: "text",
        ref(r$) {
          const _ref$ = utils.mergeRefs(context.setInputRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return fieldProps.id();
        },
        get value() {
          return web.memo(() => !!Number.isNaN(context.rawValue()))() ? "" : context.formatNumber(context.rawValue());
        },
        get required() {
          return formControlContext.isRequired();
        },
        get disabled() {
          return formControlContext.isDisabled();
        },
        get readOnly() {
          return formControlContext.isReadOnly();
        },
        get ["aria-label"]() {
          return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"]() {
          return fieldProps.ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return fieldProps.ariaDescribedBy();
        },
        get onInput() {
          return utils.composeEventHandlers([local.onInput, context.onInput]);
        },
        onChange: e => {
          utils.callHandler(e, local.onChange);
          context.format();
        },
        onWheel: e => {
          utils.callHandler(e, local.onWheel);
          if (!context.changeOnWheel() || document.activeElement !== context.inputRef()) return;
          e.preventDefault();
          if (e.deltaY < 0) context.varyValue(context.step());else context.varyValue(-context.step());
        }
      }, () => formControlContext.dataset(), others));
    }
  });
}

function NumberFieldRoot(props) {
  let ref;
  const defaultId = `NumberField-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    format: true,
    minValue: Number.MIN_SAFE_INTEGER,
    maxValue: Number.MAX_SAFE_INTEGER,
    step: 1,
    changeOnWheel: true
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "rawValue", "onRawValueChange", "translations", "format", "formatOptions", "textValue", "minValue", "maxValue", "step", "largeStep", "changeOnWheel", "translations", "allowedInput"], FORM_CONTROL_PROP_NAMES);
  const {
    locale
  } = useLocale();
  const numberParser = solidJs.createMemo(() => {
    return new number.NumberParser(locale(), local.formatOptions);
  });
  const numberFormatter = solidJs.createMemo(() => {
    return new number.NumberFormatter(locale(), local.formatOptions);
  });
  const allNumberFormatParts = solidJs.createMemo(() => [...numberFormatter().formatToParts(-1234567890.1), ...numberFormatter().formatToParts(1)]);
  const uniquePartTypes = ["decimal", "minusSign", "plusSign"];
  const commonPartTypes = ["integer", "group", "percentSign"];
  const uniqueCharacters = () => new Set(allNumberFormatParts().filter(part => uniquePartTypes.includes(part.type)).map(part => part.value).join("").split(""));
  const commonCharacters = () => new Set(allNumberFormatParts().filter(part => commonPartTypes.includes(part.type)).map(part => part.value).join("").split(""));
  const parseRawValue = value => local.format && typeof value !== "number" ? numberParser().parse(value ?? "") : Number(value ?? "");
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue ?? local.rawValue,
    onChange: value => {
      local.onChange?.(typeof value === "number" ? numberFormatter().format(value) : value);
      local.onRawValueChange?.(parseRawValue(value));
    }
  });
  local.onRawValueChange?.(parseRawValue(value()));
  function isAllowedInput(char) {
    if (local.allowedInput !== undefined) return local.allowedInput.test(char);
    if (commonCharacters().has(char)) return true;
    if (uniqueCharacters().has(char)) {
      let val = value() ?? "";
      if (typeof val === "number") val = numberFormatter().format(val);
      return !val.split("").includes(char);
    }
    return false;
  }
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => {
    setValue(local.defaultValue ?? "");
  });
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [hiddenInputRef, setHiddenInputRef] = solidJs.createSignal();
  const onInput = e => {
    if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
      return;
    }
    const target = e.target;
    if (e.inputType !== "insertText" || isAllowedInput(e.data || "")) {
      setValue(target.value);
    }
    target.value = String(value() ?? "");
  };
  const context = {
    value,
    setValue,
    rawValue: () => parseRawValue(value()),
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    formatNumber: number => numberFormatter().format(number),
    format: () => {
      if (!local.format) return;
      let rawValue = context.rawValue();
      if (Number.isNaN(rawValue)) {
        if (hiddenInputRef()) hiddenInputRef().value = "";
        local.onRawValueChange?.(rawValue);
        return;
      }
      if (context.minValue()) rawValue = Math.max(rawValue, context.minValue());
      if (context.maxValue()) rawValue = Math.min(rawValue, context.maxValue());
      const formattedValue = context.formatNumber(rawValue);
      if (value() != formattedValue) setValue(formattedValue);
      if (inputRef()) inputRef().value = formattedValue;
      if (hiddenInputRef()) hiddenInputRef().value = String(rawValue);
    },
    onInput,
    textValue: () => local.textValue,
    minValue: () => local.minValue,
    maxValue: () => local.maxValue,
    step: () => local.step,
    largeStep: () => local.largeStep ?? local.step * 10,
    changeOnWheel: () => local.changeOnWheel,
    translations: () => local.translations,
    inputRef,
    setInputRef,
    hiddenInputRef,
    setHiddenInputRef,
    varyValue: offset => {
      let rawValue = context.rawValue() ?? 0;
      if (Number.isNaN(rawValue)) rawValue = 0;
      solidJs.batch(() => {
        const decimals = Math.max(local.formatOptions?.minimumFractionDigits ?? 0, local.formatOptions?.maximumFractionDigits ?? 3);
        const newValue = Number.parseFloat((rawValue + offset).toFixed(decimals));
        context.setValue(newValue);
        context.format();
      });
    }
  };
  solidJs.createEffect(solidJs.on(() => local.rawValue, rawValue => {
    if (rawValue !== context.rawValue()) {
      if (Number.isNaN(rawValue)) return;
      solidJs.batch(() => {
        setValue(rawValue ?? "");
        context.format();
      });
    }
  }, {
    defer: true
  }));
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(NumberFieldContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

var index$d = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DecrementTrigger: NumberFieldDecrementTrigger,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	HiddenInput: NumberFieldHiddenInput,
	IncrementTrigger: NumberFieldIncrementTrigger,
	Input: NumberFieldInput,
	Label: FormControlLabel,
	Root: NumberFieldRoot
});

const _tmpl$$c = /*#__PURE__*/web.template(`<li>`);
function PaginationEllipsis(props) {
  return (() => {
    const _el$ = _tmpl$$c();
    web.insert(_el$, web.createComponent(Polymorphic, web.mergeProps({
      as: "div"
    }, props)));
    return _el$;
  })();
}

const PaginationContext = solidJs.createContext();
function usePaginationContext() {
  const context = solidJs.useContext(PaginationContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePaginationContext` must be used within a `Pagination` component");
  }
  return context;
}

const _tmpl$$b = /*#__PURE__*/web.template(`<li>`);
function PaginationItem(props) {
  const context = usePaginationContext();
  const [local, others] = solidJs.splitProps(props, ["page", "onClick"]);
  const isCurrent = () => {
    return context.page() === local.page;
  };
  const onClick = () => {
    context.setPage(local.page);
  };
  return (() => {
    const _el$ = _tmpl$$b();
    web.insert(_el$, web.createComponent(Polymorphic, web.mergeProps({
      as: "button",
      get ["aria-current"]() {
        return isCurrent() ? "page" : undefined;
      },
      get ["data-current"]() {
        return isCurrent() ? "" : undefined;
      },
      get onClick() {
        return utils.composeEventHandlers([local.onClick, onClick]);
      }
    }, others)));
    return _el$;
  })();
}

function PaginationItems(props) {
  const context = usePaginationContext();
  const [showFirst, setShowFirst] = solidJs.createSignal(false);
  const [showLast, setShowLast] = solidJs.createSignal(false);
  const [showFirstEllipsis, setShowFirstEllipsis] = solidJs.createSignal(false);
  const [showLastEllipsis, setShowLastEllipsis] = solidJs.createSignal(false);
  const [previousSiblingCount, setPreviousSiblingCount] = solidJs.createSignal(0);
  const [nextSiblingCount, setNextSiblingCount] = solidJs.createSignal(0);
  solidJs.createEffect(() => {
    solidJs.batch(() => {
      setShowFirst(context.showFirst() && context.page() - 1 > context.siblingCount());
      setShowLast(context.showLast() && context.count() - context.page() > context.siblingCount());
      setShowFirstEllipsis(context.page() - (context.showFirst() ? 2 : 1) > context.siblingCount());
      setShowLastEllipsis(context.count() - context.page() - (context.showLast() ? 1 : 0) > context.siblingCount());
      setPreviousSiblingCount(Math.min(context.page() - 1, context.siblingCount()));
      setNextSiblingCount(Math.min(context.count() - context.page(), context.siblingCount()));
      if (context.fixedItems() !== false) {
        solidJs.untrack(() => {
          setPreviousSiblingCount(prev => prev + Math.max(context.siblingCount() - nextSiblingCount(), 0));
          setNextSiblingCount(prev => prev + Math.max(context.siblingCount() - previousSiblingCount(), 0));
        });
        if (!showFirst()) setNextSiblingCount(prev => prev + 1);
        if (!showLast()) setPreviousSiblingCount(prev => prev + 1);
        if (context.fixedItems() === true) {
          if (!showFirstEllipsis()) setNextSiblingCount(prev => prev + 1);
          if (!showLastEllipsis()) setPreviousSiblingCount(prev => prev + 1);
        }
      }
    });
  });
  return [web.createComponent(solidJs.Show, {
    get when() {
      return showFirst();
    },
    get children() {
      return context.renderItem(1);
    }
  }), web.createComponent(solidJs.Show, {
    get when() {
      return showFirstEllipsis();
    },
    get children() {
      return context.renderEllipsis();
    }
  }), web.createComponent(solidJs.For, {
    get each() {
      return [...Array(previousSiblingCount()).keys()].reverse();
    },
    children: offset => web.memo(() => context.renderItem(context.page() - (offset + 1)))
  }), web.memo(() => context.renderItem(context.page())), web.createComponent(solidJs.For, {
    get each() {
      return [...Array(nextSiblingCount()).keys()];
    },
    children: offset => web.memo(() => context.renderItem(context.page() + (offset + 1)))
  }), web.createComponent(solidJs.Show, {
    get when() {
      return showLastEllipsis();
    },
    get children() {
      return context.renderEllipsis();
    }
  }), web.createComponent(solidJs.Show, {
    get when() {
      return showLast();
    },
    get children() {
      return context.renderItem(context.count());
    }
  })];
}

const _tmpl$$a = /*#__PURE__*/web.template(`<li>`);
function PaginationNext(props) {
  const context = usePaginationContext();
  const [local, others] = solidJs.splitProps(props, ["onClick"]);
  const onClick = () => {
    context.setPage(context.page() + 1);
  };
  const isDisabled = () => context.page() === context.count();
  return (() => {
    const _el$ = _tmpl$$a();
    web.insert(_el$, web.createComponent(Polymorphic, web.mergeProps({
      as: "button",
      get tabIndex() {
        return isDisabled() || context.page() === context.count() ? "-1" : undefined;
      },
      get disabled() {
        return isDisabled();
      },
      get ["aria-disabled"]() {
        return isDisabled() || undefined;
      },
      get ["data-disabled"]() {
        return isDisabled() ? "" : undefined;
      },
      get onClick() {
        return utils.composeEventHandlers([local.onClick, onClick]);
      }
    }, others)));
    return _el$;
  })();
}

const _tmpl$$9 = /*#__PURE__*/web.template(`<li>`);
function PaginationPrevious(props) {
  const context = usePaginationContext();
  const mergedProps = utils.mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["onClick"]);
  const onClick = () => {
    context.setPage(context.page() - 1);
  };
  const isDisabled = () => context.page() === 1;
  return (() => {
    const _el$ = _tmpl$$9();
    web.insert(_el$, web.createComponent(Polymorphic, web.mergeProps({
      as: "button",
      get tabIndex() {
        return isDisabled() || context.page() === 1 ? "-1" : undefined;
      },
      get disabled() {
        return isDisabled();
      },
      get ["aria-disabled"]() {
        return isDisabled() || undefined;
      },
      get ["data-disabled"]() {
        return isDisabled() ? "" : undefined;
      },
      get onClick() {
        return utils.composeEventHandlers([local.onClick, onClick]);
      }
    }, others)));
    return _el$;
  })();
}

const _tmpl$$8 = /*#__PURE__*/web.template(`<ul>`);
function PaginationRoot(props) {
  const defaultId = `pagination-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["page", "defaultPage", "onPageChange", "count", "siblingCount", "showFirst", "showLast", "fixedItems", "itemComponent", "ellipsisComponent", "disabled", "children"]);
  const state = createControllableSignal({
    defaultValue: () => local.defaultPage ?? 1,
    onChange: local.onPageChange,
    value: () => local.page
  });
  const context = {
    count: () => local.count,
    siblingCount: () => local.siblingCount ?? 1,
    showFirst: () => local.showFirst ?? true,
    showLast: () => local.showLast ?? true,
    fixedItems: () => local.fixedItems ?? false,
    isDisabled: () => local.disabled ?? false,
    renderItem: page => local.itemComponent({
      page
    }),
    renderEllipsis: local.ellipsisComponent,
    page: state[0],
    setPage: state[1]
  };
  return web.createComponent(PaginationContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "nav",
        get ["data-disabled"]() {
          return local.disabled ? "" : undefined;
        }
      }, others, {
        get children() {
          const _el$ = _tmpl$$8();
          web.insert(_el$, () => local.children);
          return _el$;
        }
      }));
    }
  });
}

var index$c = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Ellipsis: PaginationEllipsis,
	Item: PaginationItem,
	Items: PaginationItems,
	Next: PaginationNext,
	Previous: PaginationPrevious,
	Root: PaginationRoot
});

const PopoverContext = solidJs.createContext();
function usePopoverContext() {
  const context = solidJs.useContext(PopoverContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopoverContext` must be used within a `Popover` component");
  }
  return context;
}

function PopoverAnchor(props) {
  const context = usePopoverContext();
  const [local, others] = solidJs.splitProps(props, ["ref"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setDefaultAnchorRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, () => context.dataset(), others));
}

function PopoverCloseButton(props) {
  const context = usePopoverContext();
  const [local, others] = solidJs.splitProps(props, ["aria-label", "onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.close();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-label"]() {
      return local["aria-label"] || context.translations().dismiss;
    },
    onClick: onClick
  }, () => context.dataset(), others));
}

function PopoverContent(props) {
  let ref;
  const context = usePopoverContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let isRightClickOutside = false;
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      if (!isRightClickOutside) {
        utils.focusWithoutScrolling(context.triggerRef());
      }
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          utils.focusWithoutScrolling(context.triggerRef());
        }
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.isModal()) {
      isRightClickOutside = e.detail.isContextMenu;
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.isModal()) {
      return;
    }
    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }
    if (utils.contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "dialog",
            tabIndex: -1,
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isOpen())() && context.isModal();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                "--kb-popover-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.titleId();
            },
            get ["aria-describedby"]() {
              return context.descriptionId();
            },
            onPointerDownOutside: onPointerDownOutside,
            onFocusOutside: onFocusOutside,
            onInteractOutside: onInteractOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function PopoverDescription(props) {
  const context = usePopoverContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "p",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function PopoverPortal(props) {
  const context = usePopoverContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

const POPOVER_INTL_TRANSLATIONS = {
  dismiss: "Dismiss"
};

function PopoverRoot(props) {
  const defaultId = `popover-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    modal: false,
    translations: POPOVER_INTL_TRANSLATIONS
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["translations", "id", "open", "defaultOpen", "onOpenChange", "modal", "preventScroll", "forceMount", "anchorRef"]);
  const [defaultAnchorRef, setDefaultAnchorRef] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const [titleId, setTitleId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const anchorRef = () => {
    return local.anchorRef?.() ?? defaultAnchorRef() ?? triggerRef();
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    translations: () => local.translations ?? POPOVER_INTL_TRANSLATIONS,
    dataset,
    isOpen: disclosureState.isOpen,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    contentPresence,
    triggerRef,
    contentId,
    titleId,
    descriptionId,
    setDefaultAnchorRef,
    setTriggerRef,
    setContentRef,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    generateId: utils.createGenerateId(() => local.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(PopoverContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(PopperRoot, web.mergeProps({
        anchorRef: anchorRef,
        contentRef: contentRef
      }, others));
    }
  });
}

function PopoverTitle(props) {
  const context = usePopoverContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTitleId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h2",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function PopoverTrigger(props) {
  const context = usePopoverContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onClick", "onPointerDown"]);
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.preventDefault();
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$b = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Anchor: PopoverAnchor,
	Arrow: PopperArrow,
	CloseButton: PopoverCloseButton,
	Content: PopoverContent,
	Description: PopoverDescription,
	Portal: PopoverPortal,
	Root: PopoverRoot,
	Title: PopoverTitle,
	Trigger: PopoverTrigger
});

const ProgressContext = solidJs.createContext();
function useProgressContext() {
  const context = solidJs.useContext(ProgressContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useProgressContext` must be used within a `Progress.Root` component");
  }
  return context;
}

function ProgressFill(props) {
  const context = useProgressContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get style() {
      return {
        "--kb-progress-fill-width": context.progressFillWidth(),
        ...local.style
      };
    }
  }, () => context.dataset(), others));
}

function ProgressLabel(props) {
  const context = useProgressContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabelId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function ProgressRoot(props) {
  const defaultId = `progress-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    value: 0,
    minValue: 0,
    maxValue: 100
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value", "minValue", "maxValue", "indeterminate", "getValueLabel"]);
  const [labelId, setLabelId] = solidJs.createSignal();
  const defaultFormatter = createNumberFormatter(() => ({
    style: "percent"
  }));
  const value = () => {
    return utils.clamp(local.value, local.minValue, local.maxValue);
  };
  const valuePercent = () => {
    return (value() - local.minValue) / (local.maxValue - local.minValue);
  };
  const valueLabel = () => {
    if (local.indeterminate) {
      return undefined;
    }
    if (local.getValueLabel) {
      return local.getValueLabel({
        value: value(),
        min: local.minValue,
        max: local.maxValue
      });
    }
    return defaultFormatter().format(valuePercent());
  };
  const progressFillWidth = () => {
    return local.indeterminate ? undefined : `${Math.round(valuePercent() * 100)}%`;
  };
  const dataset = solidJs.createMemo(() => {
    let dataProgress = undefined;
    if (!local.indeterminate) {
      dataProgress = valuePercent() === 1 ? "complete" : "loading";
    }
    return {
      "data-progress": dataProgress,
      "data-indeterminate": local.indeterminate ? "" : undefined
    };
  });
  const context = {
    dataset,
    value,
    valuePercent,
    valueLabel,
    labelId,
    progressFillWidth,
    generateId: utils.createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return web.createComponent(ProgressContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "progressbar",
        get ["aria-valuenow"]() {
          return web.memo(() => !!local.indeterminate)() ? undefined : value();
        },
        get ["aria-valuemin"]() {
          return local.minValue;
        },
        get ["aria-valuemax"]() {
          return local.maxValue;
        },
        get ["aria-valuetext"]() {
          return valueLabel();
        },
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, dataset, others));
    }
  });
}

function ProgressTrack(props) {
  const context = useProgressContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), props));
}

function ProgressValueLabel(props) {
  const context = useProgressContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get children() {
      return context.valueLabel();
    }
  }, () => context.dataset(), props));
}

var index$a = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Fill: ProgressFill,
	Label: ProgressLabel,
	Root: ProgressRoot,
	Track: ProgressTrack,
	ValueLabel: ProgressValueLabel
});

const RadioGroupContext = solidJs.createContext();
function useRadioGroupContext() {
  const context = solidJs.useContext(RadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupContext` must be used within a `RadioGroup` component");
  }
  return context;
}

const RadioGroupItemContext = solidJs.createContext();
function useRadioGroupItemContext() {
  const context = solidJs.useContext(RadioGroupItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupItemContext` must be used within a `RadioGroup.Item` component");
  }
  return context;
}

function RadioGroupItem(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const defaultId = `${formControlContext.generateId("item")}-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value", "disabled", "onPointerDown"]);
  const [inputId, setInputId] = solidJs.createSignal();
  const [labelId, setLabelId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [isFocused, setIsFocused] = solidJs.createSignal(false);
  const isSelected = solidJs.createMemo(() => {
    return radioGroupContext.isSelectedValue(local.value);
  });
  const isDisabled = solidJs.createMemo(() => {
    return local.disabled || formControlContext.isDisabled() || false;
  });
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    ...formControlContext.dataset(),
    "data-disabled": isDisabled() ? "" : undefined,
    "data-checked": isSelected() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    isSelected,
    isDisabled,
    inputId,
    labelId,
    descriptionId,
    inputRef,
    select: () => radioGroupContext.setSelectedValue(local.value),
    generateId: utils.createGenerateId(() => others.id),
    registerInput: createRegisterId(setInputId),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId),
    setIsFocused,
    setInputRef
  };
  return web.createComponent(RadioGroupItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "group",
        onPointerDown: onPointerDown
      }, dataset, others));
    }
  });
}

function RadioGroupItemControl(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["onClick", "onKeyDown"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.select();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === utils.EventKey.Space) {
      context.select();
      context.inputRef()?.focus();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => context.dataset(), others));
}

function RadioGroupItemDescription(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescription(mergedProps.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), mergedProps));
}

function RadioGroupItemIndicator(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "forceMount"]);
  const presence = createPresence(() => local.forceMount || context.isSelected());
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, () => context.dataset(), others));
    }
  });
}

const _tmpl$$7 = /*#__PURE__*/web.template(`<input type="radio">`);
function RadioGroupItemInput(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const radioContext = useRadioGroupItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: radioContext.generateId("input")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "style", "aria-labelledby", "aria-describedby", "onChange", "onFocus", "onBlur"]);
  const ariaLabelledBy = () => {
    return [local["aria-labelledby"], radioContext.labelId(), local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined].filter(Boolean).join(" ") || undefined;
  };
  const ariaDescribedBy = () => {
    return [local["aria-describedby"], radioContext.descriptionId(), radioGroupContext.ariaDescribedBy()].filter(Boolean).join(" ") || undefined;
  };
  const [isInternalChangeEvent, setIsInternalChangeEvent] = solidJs.createSignal(false);
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    e.stopPropagation();
    if (!isInternalChangeEvent()) {
      radioGroupContext.setSelectedValue(radioContext.value());
      const target = e.target;
      target.checked = radioContext.isSelected();
    }
    setIsInternalChangeEvent(false);
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    radioContext.setIsFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    radioContext.setIsFocused(false);
  };
  solidJs.createEffect(solidJs.on([() => radioContext.isSelected(), () => radioContext.value()], c => {
    if (!c[0] && c[1] === radioContext.value()) return;
    setIsInternalChangeEvent(true);
    const ref = radioContext.inputRef();
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));
  solidJs.createEffect(() => solidJs.onCleanup(radioContext.registerInput(others.id)));
  return (() => {
    const _el$ = _tmpl$$7();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(radioContext.setInputRef, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get name() {
        return formControlContext.name();
      },
      get value() {
        return radioContext.value();
      },
      get checked() {
        return radioContext.isSelected();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return radioContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-labelledby"]() {
        return ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return ariaDescribedBy();
      }
    }, () => radioContext.dataset(), others), false, false);
    return _el$;
  })();
}

const _tmpl$$6 = /*#__PURE__*/web.template(`<label>`);
function RadioGroupItemLabel(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabel(mergedProps.id)));
  return (() => {
    const _el$ = _tmpl$$6();
    web.spread(_el$, web.mergeProps({
      get ["for"]() {
        return context.inputId();
      }
    }, () => context.dataset(), mergedProps), false, false);
    return _el$;
  })();
}

function RadioGroupLabel(props) {
  return web.createComponent(FormControlLabel, web.mergeProps({
    as: "span"
  }, props));
}

function RadioGroupRoot(props) {
  let ref;
  const defaultId = `radiogroup-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    orientation: "vertical"
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "orientation", "aria-labelledby", "aria-describedby"], FORM_CONTROL_PROP_NAMES);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setSelected(local.defaultValue ?? ""));
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(utils.access(formControlProps.id), others["aria-label"], local["aria-labelledby"]);
  };
  const ariaDescribedBy = () => {
    return formControlContext.getAriaDescribedBy(local["aria-describedby"]);
  };
  const isSelectedValue = value => {
    return value === selected();
  };
  const context = {
    ariaDescribedBy,
    isSelectedValue,
    setSelectedValue: value => {
      if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
        return;
      }
      setSelected(value);
      if (ref) for (const el of ref.querySelectorAll("[type='radio']")) {
        const radio = el;
        radio.checked = isSelectedValue(radio.value);
      }
    }
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(RadioGroupContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "radiogroup",
            get id() {
              return utils.access(formControlProps.id);
            },
            get ["aria-invalid"]() {
              return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"]() {
              return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"]() {
              return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"]() {
              return formControlContext.isReadOnly() || undefined;
            },
            get ["aria-orientation"]() {
              return local.orientation;
            },
            get ["aria-labelledby"]() {
              return ariaLabelledBy();
            },
            get ["aria-describedby"]() {
              return ariaDescribedBy();
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

var index$9 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Item: RadioGroupItem,
	ItemControl: RadioGroupItemControl,
	ItemDescription: RadioGroupItemDescription,
	ItemIndicator: RadioGroupItemIndicator,
	ItemInput: RadioGroupItemInput,
	ItemLabel: RadioGroupItemLabel,
	Label: RadioGroupLabel,
	Root: RadioGroupRoot
});

const SelectContext = solidJs.createContext();
function useSelectContext() {
  const context = solidJs.useContext(SelectContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSelectContext` must be used within a `Select` component");
  }
  return context;
}

function SelectContent(props) {
  let ref;
  const context = useSelectContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "style", "onCloseAutoFocus", "onFocusOutside"]);
  const onEscapeKeyDown = e => {
    context.close();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: e => {
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      local.onCloseAutoFocus?.(e);
      if (!e.defaultPrevented) {
        utils.focusWithoutScrolling(context.triggerRef());
        e.preventDefault();
      }
    }
  }, () => ref);
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                "--kb-select-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function SelectHiddenSelect(props) {
  const context = useSelectContext();
  return web.createComponent(HiddenSelectBase, web.mergeProps({
    get collection() {
      return context.listState().collection();
    },
    get selectionManager() {
      return context.listState().selectionManager();
    },
    get isOpen() {
      return context.isOpen();
    },
    get isMultiple() {
      return context.isMultiple();
    },
    get isVirtualized() {
      return context.isVirtualized();
    },
    focusTrigger: () => context.triggerRef()?.focus()
  }, props));
}

function SelectIcon(props) {
  const context = useSelectContext();
  const mergedProps = utils.mergeDefaultProps({
    children: ""
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}

function SelectLabel(props) {
  const context = useSelectContext();
  const [local, others] = solidJs.splitProps(props, ["onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!context.isDisabled()) {
      context.triggerRef()?.focus();
    }
  };
  return web.createComponent(FormControlLabel, web.mergeProps({
    as: "span",
    onClick: onClick
  }, others));
}

function SelectListbox(props) {
  const context = useSelectContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("listbox")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id", "onKeyDown"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerListboxId(local.id)));
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === "Escape") {
      e.preventDefault();
    }
  };
  return web.createComponent(ListboxRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get state() {
      return context.listState();
    },
    get virtualized() {
      return context.isVirtualized();
    },
    get autoFocus() {
      return context.autoFocus();
    },
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get shouldFocusWrap() {
      return context.shouldFocusWrap();
    },
    get disallowTypeAhead() {
      return context.disallowTypeAhead();
    },
    get ["aria-labelledby"]() {
      return context.listboxAriaLabelledBy();
    },
    get renderItem() {
      return context.renderItem;
    },
    get renderSection() {
      return context.renderSection;
    },
    onKeyDown: onKeyDown
  }, others));
}

function SelectPortal(props) {
  const context = useSelectContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

function SelectBase(props) {
  const defaultId = `select-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    disallowEmptySelection: false,
    closeOnSelection: props.selectionMode === "single",
    allowDuplicateSelectionEvents: true,
    gutter: 8,
    sameWidth: true,
    modal: false
  }, props);
  const [local, popperProps, formControlProps, others] = solidJs.splitProps(mergedProps, ["itemComponent", "sectionComponent", "open", "defaultOpen", "onOpenChange", "value", "defaultValue", "onChange", "placeholder", "options", "optionValue", "optionTextValue", "optionDisabled", "optionGroupChildren", "keyboardDelegate", "allowDuplicateSelectionEvents", "disallowEmptySelection", "closeOnSelection", "disallowTypeAhead", "shouldFocusWrap", "selectionBehavior", "selectionMode", "virtualized", "modal", "preventScroll", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [valueId, setValueId] = solidJs.createSignal();
  const [listboxId, setListboxId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [listboxRef, setListboxRef] = solidJs.createSignal();
  const [listboxAriaLabelledBy, setListboxAriaLabelledBy] = solidJs.createSignal();
  const [focusStrategy, setFocusStrategy] = solidJs.createSignal(true);
  const getOptionValue = option => {
    const optionValue = local.optionValue;
    if (optionValue == null) {
      return String(option);
    }
    return String(utils.isFunction(optionValue) ? optionValue(option) : option[optionValue]);
  };
  const flattenOptions = solidJs.createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;
    if (optionGroupChildren == null) {
      return local.options;
    }
    return local.options.flatMap(item => item[optionGroupChildren] ?? item);
  });
  const flattenOptionKeys = solidJs.createMemo(() => {
    return flattenOptions().map(option => getOptionValue(option));
  });
  const getOptionsFromValues = values => {
    return [...values].map(value => flattenOptions().find(option => getOptionValue(option) === value)).filter(option => option != null);
  };
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const listState = createListState({
    selectedKeys: () => {
      if (local.value != null) {
        return local.value.map(getOptionValue);
      }
      return local.value;
    },
    defaultSelectedKeys: () => {
      if (local.defaultValue != null) {
        return local.defaultValue.map(getOptionValue);
      }
      return local.defaultValue;
    },
    onSelectionChange: selectedKeys => {
      local.onChange?.(getOptionsFromValues(selectedKeys));
      if (local.closeOnSelection) {
        close();
      }
    },
    allowDuplicateSelectionEvents: () => utils.access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => utils.access(local.disallowEmptySelection),
    selectionBehavior: () => utils.access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: () => local.options ?? [],
    getKey: () => local.optionValue,
    getTextValue: () => local.optionTextValue,
    getDisabled: () => local.optionDisabled,
    getSectionChildren: () => local.optionGroupChildren
  });
  const selectedOptions = solidJs.createMemo(() => {
    return getOptionsFromValues(listState.selectionManager().selectedKeys());
  });
  const removeOptionFromSelection = option => {
    listState.selectionManager().toggleSelection(getOptionValue(option));
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const focusListbox = () => {
    const listboxEl = listboxRef();
    if (listboxEl) {
      utils.focusWithoutScrolling(listboxEl);
    }
  };
  const open = focusStrategy => {
    if (local.options.length <= 0) {
      return;
    }
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    focusListbox();
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
  };
  const toggle = focusStrategy => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy);
    }
  };
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(triggerRef, () => {
    const defaultSelectedKeys = local.defaultValue ? [...local.defaultValue].map(getOptionValue) : new Selection();
    listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
  });
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });
  const delegate = solidJs.createMemo(() => {
    const keyboardDelegate = utils.access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, undefined, collator);
  });
  const renderItem = item => {
    return local.itemComponent?.({
      item
    });
  };
  const renderSection = section => {
    return local.sectionComponent?.({
      section
    });
  };
  solidJs.createEffect(solidJs.on([flattenOptionKeys], ([flattenOptionKeys]) => {
    const currentSelectedKeys = [...listState.selectionManager().selectedKeys()];
    const keysToKeep = currentSelectedKeys.filter(key => flattenOptionKeys.includes(key));
    listState.selectionManager().setSelectedKeys(keysToKeep);
  }, {
    defer: true
  }));
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => utils.access(local.selectionMode) === "multiple",
    isVirtualized: () => local.virtualized ?? false,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    disallowTypeAhead: () => local.disallowTypeAhead ?? false,
    shouldFocusWrap: () => local.shouldFocusWrap ?? false,
    selectedOptions,
    contentPresence,
    autoFocus: focusStrategy,
    triggerRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    triggerId,
    valueId,
    listboxId,
    listboxAriaLabelledBy,
    setListboxAriaLabelledBy,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    placeholder: () => local.placeholder,
    renderItem,
    renderSection,
    removeOptionFromSelection,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    registerTriggerId: createRegisterId(setTriggerId),
    registerValueId: createRegisterId(setValueId),
    registerListboxId: createRegisterId(setListboxId)
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(SelectContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: triggerRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return web.createComponent(Polymorphic, web.mergeProps({
                as: "div",
                role: "group",
                get id() {
                  return utils.access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

function SelectRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["value", "defaultValue", "onChange", "multiple"]);
  const value = solidJs.createMemo(() => {
    if (local.value != null) {
      return local.multiple ? local.value : [local.value];
    }
    return local.value;
  });
  const defaultValue = solidJs.createMemo(() => {
    if (local.defaultValue != null) {
      return local.multiple ? local.defaultValue : [local.defaultValue];
    }
    return local.defaultValue;
  });
  const onChange = value => {
    if (local.multiple) {
      local.onChange?.(value);
    } else {
      local.onChange?.(value[0] ?? null);
    }
  };
  return web.createComponent(SelectBase, web.mergeProps({
    get value() {
      return value();
    },
    get defaultValue() {
      return defaultValue();
    },
    onChange: onChange,
    get selectionMode() {
      return local.multiple ? "multiple" : "single";
    }
  }, others));
}

function SelectTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "disabled", "onPointerDown", "onClick", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const selectionManager = () => context.listState().selectionManager();
  const keyboardDelegate = () => context.keyboardDelegate();
  const isDisabled = () => local.disabled || context.isDisabled();
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const {
    typeSelectHandlers
  } = createTypeSelect({
    keyboardDelegate: keyboardDelegate,
    selectionManager: selectionManager,
    onTypeSelect: key => selectionManager().select(key)
  });
  const ariaLabelledBy = () => {
    return [context.listboxAriaLabelledBy(), context.valueId()].filter(Boolean).join(" ") || undefined;
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
      e.preventDefault();
      context.toggle(true);
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!isDisabled() && e.currentTarget.dataset.pointerType === "touch") {
      context.toggle(true);
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (isDisabled()) {
      return;
    }
    utils.callHandler(e, typeSelectHandlers.onKeyDown);
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowLeft":
        {
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyAbove?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
      case "ArrowRight":
        {
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyBelow?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (selectionManager().isFocused()) {
      return;
    }
    selectionManager().setFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    if (context.isOpen()) {
      return;
    }
    selectionManager().setFocused(false);
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(fieldProps.id())));
  solidJs.createEffect(() => {
    context.setListboxAriaLabelledBy([fieldProps.ariaLabelledBy(), fieldProps.ariaLabel() && !fieldProps.ariaLabelledBy() ? fieldProps.id() : null].filter(Boolean).join(" ") || undefined);
  });
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get disabled() {
      return isDisabled();
    },
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const _tmpl$$5 = /*#__PURE__*/web.template(`<span>`);
function SelectValue(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("value")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id", "children"]);
  const selectionManager = () => context.listState().selectionManager();
  const isSelectionEmpty = () => {
    const selectedKeys = selectionManager().selectedKeys();
    if (selectedKeys.size === 1 && selectedKeys.has("")) {
      return true;
    }
    return selectionManager().isEmpty();
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerValueId(local.id)));
  return (() => {
    const _el$ = _tmpl$$5();
    web.spread(_el$, web.mergeProps({
      get id() {
        return local.id;
      },
      get ["data-placeholder-shown"]() {
        return isSelectionEmpty() ? "" : undefined;
      }
    }, () => formControlContext.dataset(), others), false, true);
    web.insert(_el$, web.createComponent(solidJs.Show, {
      get when() {
        return !isSelectionEmpty();
      },
      get fallback() {
        return context.placeholder();
      },
      get children() {
        return web.createComponent(SelectValueChild, {
          state: {
            selectedOption: () => context.selectedOptions()[0],
            selectedOptions: () => context.selectedOptions(),
            remove: option => context.removeOptionFromSelection(option),
            clear: () => selectionManager().clearSelection()
          },
          get children() {
            return local.children;
          }
        });
      }
    }));
    return _el$;
  })();
}
function SelectValueChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

var index$8 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: SelectContent,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	HiddenSelect: SelectHiddenSelect,
	Icon: SelectIcon,
	Item: ListboxItem,
	ItemDescription: ListboxItemDescription,
	ItemIndicator: ListboxItemIndicator,
	ItemLabel: ListboxItemLabel,
	Label: SelectLabel,
	Listbox: SelectListbox,
	Portal: SelectPortal,
	Root: SelectRoot,
	Section: ListboxSection,
	Trigger: SelectTrigger,
	Value: SelectValue
});

function Skeleton(props) {
  const defaultId = `skeleton-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    visible: true,
    animate: true,
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["style", "ref", "radius", "animate", "height", "width", "visible", "circle"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    role: "group",
    get ["data-animate"]() {
      return local.animate;
    },
    get ["data-visible"]() {
      return local.visible;
    },
    get style() {
      return {
        "border-radius": local.circle ? "9999px" : local.radius ? `${local.radius}px` : undefined,
        width: local.circle ? `${local.height}px` : local.width ? `${local.width}px` : "100%",
        height: local.height ? `${local.height}px` : "auto",
        ...local.style
      };
    }
  }, others));
}

var index$7 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: Skeleton
});

const SliderContext = solidJs.createContext();
function useSliderContext() {
  const context = solidJs.useContext(SliderContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSliderContext` must be used within a `Slider.Root` component");
  }
  return context;
}

function SliderFill(props) {
  const context = useSliderContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  const percentages = () => {
    return context.state.values().map(value => context.state.getValuePercent(value) * 100);
  };
  const offsetStart = () => {
    return context.state.values().length > 1 ? Math.min(...percentages()) : 0;
  };
  const offsetEnd = () => {
    return 100 - Math.max(...percentages());
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get style() {
      return {
        [context.startEdge()]: `${offsetStart()}%`,
        [context.endEdge()]: `${offsetEnd()}%`,
        ...local.style
      };
    }
  }, () => context.dataset(), others));
}

function SliderThumb(props) {
  let ref;
  const context = useSliderContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId(`thumb-${solidJs.createUniqueId()}`)
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "style", "onKeyDown", "onPointerDown", "onPointerMove", "onPointerUp", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      disabled: context.state.isDisabled(),
      key: fieldProps.id(),
      textValue: "",
      type: "item"
    })
  });
  const index = () => ref ? context.thumbs().findIndex(v => v.ref() === ref) : -1;
  const value = () => context.state.getThumbValue(index());
  const position = () => {
    return context.state.getThumbPercent(index());
  };
  const transform = () => {
    return context.state.orientation() === "vertical" ? "translateY(50%)" : "translateX(-50%)";
  };
  let startPosition = 0;
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    context.onStepKeyDown(e, index());
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    const target = e.currentTarget;
    e.preventDefault();
    e.stopPropagation();
    target.setPointerCapture(e.pointerId);
    target.focus();
    startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    if (value() !== undefined) {
      context.onSlideStart?.(index(), value());
    }
  };
  const onPointerMove = e => {
    e.stopPropagation();
    utils.callHandler(e, local.onPointerMove);
    const target = e.currentTarget;
    if (target.hasPointerCapture(e.pointerId)) {
      const delta = {
        deltaX: e.clientX - startPosition,
        deltaY: e.clientY - startPosition
      };
      context.onSlideMove?.(delta);
      startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    }
  };
  const onPointerUp = e => {
    e.stopPropagation();
    utils.callHandler(e, local.onPointerUp);
    const target = e.currentTarget;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
      context.onSlideEnd?.();
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    context.state.setFocusedThumb(index());
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.state.setFocusedThumb(undefined);
  };
  solidJs.onMount(() => {
    context.state.setThumbEditable(index(), !context.state.isDisabled());
  });
  return web.createComponent(ThumbContext.Provider, {
    value: {
      index
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "span",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "slider",
        get id() {
          return fieldProps.id();
        },
        get tabIndex() {
          return context.state.isDisabled() ? undefined : 0;
        },
        get style() {
          return {
            display: value() === undefined ? "none" : undefined,
            position: "absolute",
            [context.startEdge()]: `calc(${position() * 100}%)`,
            transform: transform(),
            "touch-action": "none",
            ...local.style
          };
        },
        get ["aria-valuetext"]() {
          return context.state.getThumbValueLabel(index());
        },
        get ["aria-valuemin"]() {
          return context.minValue();
        },
        get ["aria-valuenow"]() {
          return value();
        },
        get ["aria-valuemax"]() {
          return context.maxValue();
        },
        get ["aria-orientation"]() {
          return context.state.orientation();
        },
        get ["aria-label"]() {
          return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"]() {
          return fieldProps.ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return fieldProps.ariaDescribedBy();
        },
        onKeyDown: onKeyDown,
        onPointerDown: onPointerDown,
        onPointerMove: onPointerMove,
        onPointerUp: onPointerUp,
        onFocus: onFocus,
        onBlur: onBlur
      }, () => context.dataset(), others));
    }
  });
}
const ThumbContext = solidJs.createContext();
function useThumbContext() {
  const context = solidJs.useContext(ThumbContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useThumbContext` must be used within a `Slider.Thumb` component");
  }
  return context;
}

const _tmpl$$4 = /*#__PURE__*/web.template(`<input type="range">`);
function SliderInput(props) {
  const formControlContext = useFormControlContext();
  const context = useSliderContext();
  const thumb = useThumbContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "style", "onChange"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const [valueText, setValueText] = solidJs.createSignal("");
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    const target = e.target;
    context.state.setThumbValue(thumb.index(), parseFloat(target.value));
    target.value = String(context.state.values()[thumb.index()]) ?? "";
  };
  solidJs.createEffect(() => {
    setValueText(thumb.index() === -1 ? "" : context.state.getThumbValueLabel(thumb.index()));
  });
  return (() => {
    const _el$ = _tmpl$$4();
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(el => el, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get tabIndex() {
        return context.state.isDisabled() ? undefined : -1;
      },
      get min() {
        return context.state.getThumbMinValue(thumb.index());
      },
      get max() {
        return context.state.getThumbMaxValue(thumb.index());
      },
      get step() {
        return context.state.step();
      },
      get value() {
        return context.state.values()[thumb.index()];
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-orientation"]() {
        return context.state.orientation();
      },
      get ["aria-valuetext"]() {
        return valueText();
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => context.dataset(), others), false, false);
    return _el$;
  })();
}

function getNextSortedValues(prevValues, nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map(value => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  const closestIndex = distances.indexOf(closestDistance);
  return nextValue < values[closestIndex] ? closestIndex : distances.lastIndexOf(closestDistance);
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return value => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function stopEventDefaultAndPropagation(event) {
  event.preventDefault();
  event.stopPropagation();
}

function createSliderState(props) {
  const mergedProps = utils.mergeDefaultProps({
    minValue: () => 0,
    maxValue: () => 100,
    step: () => 1,
    minStepsBetweenThumbs: () => 0,
    orientation: () => "horizontal",
    isDisabled: () => false
  }, props);
  const pageSize = solidJs.createMemo(() => {
    let calcPageSize = (mergedProps.maxValue() - mergedProps.minValue()) / 10;
    calcPageSize = utils.snapValueToStep(calcPageSize, 0, calcPageSize + mergedProps.step(), mergedProps.step());
    return Math.max(calcPageSize, mergedProps.step());
  });
  const defaultValue = solidJs.createMemo(() => {
    return mergedProps.defaultValue() ?? [mergedProps.minValue()];
  });
  const [values, setValues] = createControllableArraySignal({
    value: () => mergedProps.value(),
    defaultValue,
    onChange: values => mergedProps.onChange?.(values)
  });
  const [isDragging, setIsDragging] = solidJs.createSignal(new Array(values().length).fill(false));
  const [isEditables, setEditables] = solidJs.createSignal(new Array(values().length).fill(false));
  const [focusedIndex, setFocusedIndex] = solidJs.createSignal(undefined);
  const resetValues = () => {
    setValues(defaultValue());
  };
  const getValuePercent = value => {
    return (value - mergedProps.minValue()) / (mergedProps.maxValue() - mergedProps.minValue());
  };
  const getThumbMinValue = index => {
    return index === 0 ? props.minValue() : values()[index - 1] + props.minStepsBetweenThumbs() * props.step();
  };
  const getThumbMaxValue = index => {
    return index === values().length - 1 ? props.maxValue() : values()[index + 1] - props.minStepsBetweenThumbs() * props.step();
  };
  const isThumbEditable = index => {
    return isEditables()[index];
  };
  const setThumbEditable = index => {
    setEditables(p => {
      p[index] = true;
      return p;
    });
  };
  const updateValue = (index, value) => {
    if (mergedProps.isDisabled() || !isThumbEditable(index)) return;
    const snappedValue = utils.snapValueToStep(value, getThumbMinValue(index), getThumbMaxValue(index), mergedProps.step());
    const nextValues = getNextSortedValues(values(), snappedValue, index);
    if (!hasMinStepsBetweenValues(nextValues, mergedProps.minStepsBetweenThumbs() * mergedProps.step())) {
      return;
    }
    setValues(prev => [...replaceIndex(prev, index, snappedValue)]);
  };
  const updateDragging = (index, dragging) => {
    if (mergedProps.isDisabled() || !isThumbEditable(index)) return;
    const wasDragging = isDragging()[index];
    setIsDragging(p => [...replaceIndex(p, index, dragging)]);
    if (wasDragging && !isDragging().some(Boolean)) {
      mergedProps.onChangeEnd?.(values());
    }
  };
  const getFormattedValue = value => {
    return mergedProps.numberFormatter.format(value);
  };
  const setThumbPercent = (index, percent) => {
    updateValue(index, getPercentValue(percent));
  };
  const getRoundedValue = value => {
    return Math.round((value - mergedProps.minValue()) / mergedProps.step()) * mergedProps.step() + mergedProps.minValue();
  };
  const getPercentValue = percent => {
    const val = percent * (mergedProps.maxValue() - mergedProps.minValue()) + mergedProps.minValue();
    return utils.clamp(getRoundedValue(val), mergedProps.minValue(), mergedProps.maxValue());
  };
  const snapThumbValue = (index, value) => {
    const nextValue = values()[index] + value;
    const nextValues = getNextSortedValues(values(), nextValue, index);
    if (hasMinStepsBetweenValues(nextValues, mergedProps.minStepsBetweenThumbs() * mergedProps.step())) {
      updateValue(index, utils.snapValueToStep(nextValue, mergedProps.minValue(), mergedProps.maxValue(), mergedProps.step()));
    }
  };
  const incrementThumb = (index, stepSize = 1) => {
    snapThumbValue(index, Math.max(stepSize, props.step()));
  };
  const decrementThumb = (index, stepSize = 1) => {
    snapThumbValue(index, -Math.max(stepSize, props.step()));
  };
  return {
    values,
    getThumbValue: index => values()[index],
    setThumbValue: updateValue,
    setThumbPercent,
    isThumbDragging: index => isDragging()[index],
    setThumbDragging: updateDragging,
    focusedThumb: focusedIndex,
    setFocusedThumb: setFocusedIndex,
    getThumbPercent: index => getValuePercent(values()[index]),
    getValuePercent,
    getThumbValueLabel: index => getFormattedValue(values()[index]),
    getFormattedValue,
    getThumbMinValue,
    getThumbMaxValue,
    getPercentValue,
    isThumbEditable,
    setThumbEditable,
    incrementThumb,
    decrementThumb,
    step: mergedProps.step,
    pageSize,
    orientation: mergedProps.orientation,
    isDisabled: mergedProps.isDisabled,
    setValues,
    resetValues
  };
}
function replaceIndex(array, index, value) {
  if (array[index] === value) {
    return array;
  }
  return [...array.slice(0, index), value, ...array.slice(index + 1)];
}

function SliderRoot(props) {
  let ref;
  const defaultId = `slider-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    minValue: 0,
    maxValue: 100,
    step: 1,
    minStepsBetweenThumbs: 0,
    orientation: "horizontal",
    disabled: false,
    inverted: false,
    getValueLabel: params => params.values.join(", ")
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "onChangeEnd", "inverted", "minValue", "maxValue", "step", "minStepsBetweenThumbs", "getValueLabel", "orientation"], FORM_CONTROL_PROP_NAMES);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const defaultFormatter = createNumberFormatter(() => ({
    style: "decimal"
  }));
  const {
    direction
  } = useLocale();
  const state = createSliderState({
    value: () => local.value,
    defaultValue: () => local.defaultValue ?? [local.minValue],
    maxValue: () => local.maxValue,
    minValue: () => local.minValue,
    minStepsBetweenThumbs: () => local.minStepsBetweenThumbs,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    orientation: () => local.orientation,
    step: () => local.step,
    numberFormatter: defaultFormatter(),
    onChange: local.onChange,
    onChangeEnd: local.onChangeEnd
  });
  const [thumbs, setThumbs] = solidJs.createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items: thumbs,
    onItemsChange: setThumbs
  });
  createFormResetListener(() => ref, () => state.resetValues());
  const isLTR = () => direction() === "ltr";
  const isSlidingFromLeft = () => {
    return isLTR() && !local.inverted || !isLTR() && local.inverted;
  };
  const isSlidingFromBottom = () => !local.inverted;
  const isVertical = () => state.orientation() === "vertical";
  const dataset = solidJs.createMemo(() => {
    return {
      ...formControlContext.dataset(),
      "data-orientation": local.orientation
    };
  });
  const [trackRef, setTrackRef] = solidJs.createSignal();
  let currentPosition = null;
  const onSlideStart = (index, value) => {
    state.setFocusedThumb(index);
    state.setThumbDragging(index, true);
    state.setThumbValue(index, value);
    currentPosition = null;
  };
  const onSlideMove = ({
    deltaX,
    deltaY
  }) => {
    const active = state.focusedThumb();
    if (active === undefined) {
      return;
    }
    const {
      width,
      height
    } = trackRef().getBoundingClientRect();
    const size = isVertical() ? height : width;
    if (currentPosition === null) {
      currentPosition = state.getThumbPercent(state.focusedThumb()) * size;
    }
    let delta = isVertical() ? deltaY : deltaX;
    if (!isVertical() && local.inverted || isVertical() && isSlidingFromBottom()) {
      delta = -delta;
    }
    currentPosition += delta;
    const percent = utils.clamp(currentPosition / size, 0, 1);
    const nextValues = getNextSortedValues(state.values(), currentPosition, active);
    if (hasMinStepsBetweenValues(nextValues, local.minStepsBetweenThumbs * state.step())) {
      state.setThumbPercent(state.focusedThumb(), percent);
      local.onChange?.(state.values());
    }
  };
  const onSlideEnd = () => {
    const activeThumb = state.focusedThumb();
    if (activeThumb !== undefined) {
      state.setThumbDragging(activeThumb, false);
      thumbs()[activeThumb].ref().focus();
    }
  };
  const onHomeKeyDown = event => {
    const focusedThumb = state.focusedThumb();
    if (!formControlContext.isDisabled() && focusedThumb !== undefined) {
      stopEventDefaultAndPropagation(event);
      state.setThumbValue(focusedThumb, state.getThumbMinValue(focusedThumb));
    }
  };
  const onEndKeyDown = event => {
    const focusedThumb = state.focusedThumb();
    if (!formControlContext.isDisabled() && focusedThumb !== undefined) {
      stopEventDefaultAndPropagation(event);
      state.setThumbValue(focusedThumb, state.getThumbMaxValue(focusedThumb));
    }
  };
  const onStepKeyDown = (event, index) => {
    if (!formControlContext.isDisabled()) {
      switch (event.key) {
        case "Left":
        case "ArrowLeft":
        case "Down":
        case "ArrowDown":
          stopEventDefaultAndPropagation(event);
          if (!isLTR()) {
            state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          } else {
            state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          }
          break;
        case "Right":
        case "ArrowRight":
        case "Up":
        case "ArrowUp":
          stopEventDefaultAndPropagation(event);
          if (!isLTR()) {
            state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          } else {
            state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          }
          break;
        case "Home":
          onHomeKeyDown(event);
          break;
        case "End":
          onEndKeyDown(event);
          break;
        case "PageUp":
          stopEventDefaultAndPropagation(event);
          state.incrementThumb(index, state.pageSize());
          break;
        case "PageDown":
          stopEventDefaultAndPropagation(event);
          state.decrementThumb(index, state.pageSize());
          break;
      }
    }
  };
  const startEdge = solidJs.createMemo(() => {
    if (isVertical()) {
      return isSlidingFromBottom() ? "bottom" : "top";
    }
    return isSlidingFromLeft() ? "left" : "right";
  });
  const endEdge = solidJs.createMemo(() => {
    if (isVertical()) {
      return isSlidingFromBottom() ? "top" : "bottom";
    }
    return isSlidingFromLeft() ? "right" : "left";
  });
  const context = {
    dataset,
    state,
    thumbs,
    setThumbs,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onStepKeyDown,
    isSlidingFromLeft,
    isSlidingFromBottom,
    trackRef,
    minValue: () => local.minValue,
    maxValue: () => local.maxValue,
    inverted: () => local.inverted,
    startEdge,
    endEdge,
    registerTrack: ref => setTrackRef(ref),
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    getValueLabel: local.getValueLabel
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(FormControlContext.Provider, {
        value: formControlContext,
        get children() {
          return web.createComponent(SliderContext.Provider, {
            value: context,
            get children() {
              return web.createComponent(Polymorphic, web.mergeProps({
                as: "div",
                ref(r$) {
                  const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
                  typeof _ref$ === "function" && _ref$(r$);
                },
                role: "group",
                get id() {
                  return utils.access(formControlProps.id);
                }
              }, dataset, others));
            }
          });
        }
      });
    }
  });
}

function SliderTrack(props) {
  const context = useSliderContext();
  const [local, others] = solidJs.splitProps(props, ["onPointerDown", "onPointerMove", "onPointerUp"]);
  const [sRect, setRect] = solidJs.createSignal();
  function getValueFromPointer(pointerPosition) {
    const rect = sRect() || context.trackRef().getBoundingClientRect();
    const input = [0, context.state.orientation() === "vertical" ? rect.height : rect.width];
    let output = context.isSlidingFromLeft() ? [context.minValue(), context.maxValue()] : [context.maxValue(), context.minValue()];
    if (context.state.orientation() === "vertical") {
      output = context.isSlidingFromBottom() ? [context.maxValue(), context.minValue()] : [context.minValue(), context.maxValue()];
    }
    const value = linearScale(input, output);
    setRect(rect);
    return value(pointerPosition - (context.state.orientation() === "vertical" ? rect.top : rect.left));
  }
  let startPosition = 0;
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    const target = e.target;
    target.setPointerCapture(e.pointerId);
    e.preventDefault();
    const value = getValueFromPointer(context.state.orientation() === "horizontal" ? e.clientX : e.clientY);
    startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    const closestIndex = getClosestValueIndex(context.state.values(), value);
    context.onSlideStart?.(closestIndex, value);
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      context.onSlideMove?.({
        deltaX: e.clientX - startPosition,
        deltaY: e.clientY - startPosition
      });
      startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    }
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
      setRect(undefined);
      context.onSlideEnd?.();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.registerTrack, props.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    onPointerDown: onPointerDown,
    onPointerMove: onPointerMove,
    onPointerUp: onPointerUp
  }, () => context.dataset(), others));
}

function SliderValueLabel(props) {
  const context = useSliderContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), props, {
    get children() {
      return context.getValueLabel?.({
        values: context.state.values(),
        max: context.maxValue(),
        min: context.minValue()
      });
    }
  }));
}

var index$6 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Fill: SliderFill,
	Input: SliderInput,
	Label: FormControlLabel,
	Root: SliderRoot,
	Thumb: SliderThumb,
	Track: SliderTrack,
	ValueLabel: SliderValueLabel
});

const SwitchContext = solidJs.createContext();
function useSwitchContext() {
  const context = solidJs.useContext(SwitchContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSwitchContext` must be used within a `Switch` component");
  }
  return context;
}

function SwitchControl(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["onClick", "onKeyDown"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === utils.EventKey.Space) {
      context.toggle();
      context.inputRef()?.focus();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => formControlContext.dataset(), () => context.dataset(), others));
}

function SwitchDescription(props) {
  const context = useSwitchContext();
  return web.createComponent(FormControlDescription, web.mergeProps(() => context.dataset(), props));
}

function SwitchErrorMessage(props) {
  const context = useSwitchContext();
  return web.createComponent(FormControlErrorMessage, web.mergeProps(() => context.dataset(), props));
}

const _tmpl$$3 = /*#__PURE__*/web.template(`<input type="checkbox" role="switch">`);
function SwitchInput(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["ref", "style", "onChange", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    e.stopPropagation();
    const target = e.target;
    context.setIsChecked(target.checked);
    target.checked = context.checked();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    context.setIsFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.setIsFocused(false);
  };
  return (() => {
    const _el$ = _tmpl$$3();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(context.setInputRef, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.checked();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-checked"]() {
        return context.checked();
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => formControlContext.dataset(), () => context.dataset(), others), false, false);
    return _el$;
  })();
}

function SwitchLabel(props) {
  const context = useSwitchContext();
  return web.createComponent(FormControlLabel, web.mergeProps(() => context.dataset(), props));
}

function SwitchRoot(props) {
  let ref;
  const defaultId = `switch-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(mergedProps, ["ref", "children", "value", "checked", "defaultChecked", "onChange", "onPointerDown"], FORM_CONTROL_PROP_NAMES);
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [isFocused, setIsFocused] = solidJs.createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => formControlContext.isDisabled(),
    isReadOnly: () => formControlContext.isReadOnly()
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultChecked ?? false));
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-checked": state.isSelected() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    checked: () => state.isSelected(),
    inputRef,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    toggle: () => state.toggle(),
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setInputRef
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(SwitchContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            },
            onPointerDown: onPointerDown
          }, () => formControlContext.dataset(), dataset, others, {
            get children() {
              return web.createComponent(SwitchRootChild, {
                state: context,
                get children() {
                  return local.children;
                }
              });
            }
          }));
        }
      });
    }
  });
}
function SwitchRootChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

function SwitchThumb(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("thumb")
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => formControlContext.dataset(), () => context.dataset(), mergedProps));
}

var index$5 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Control: SwitchControl,
	Description: SwitchDescription,
	ErrorMessage: SwitchErrorMessage,
	Input: SwitchInput,
	Label: SwitchLabel,
	Root: SwitchRoot,
	Thumb: SwitchThumb
});

const TabsContext = solidJs.createContext();
function useTabsContext() {
  const context = solidJs.useContext(TabsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTabsContext` must be used within a `Tabs` component");
  }
  return context;
}

function TabsContent(props) {
  let ref;
  const context = useTabsContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "value", "forceMount"]);
  const [tabIndex, setTabIndex] = solidJs.createSignal(0);
  const id = () => local.id ?? context.generateContentId(local.value);
  const isSelected = () => context.listState().selectedKey() === local.value;
  const presence = createPresence(() => local.forceMount || isSelected());
  solidJs.createEffect(solidJs.on([() => ref, () => presence.isPresent()], ([ref, isPresent]) => {
    if (ref == null || !isPresent) {
      return;
    }
    const updateTabIndex = () => {
      const walker = utils.getFocusableTreeWalker(ref, {
        tabbable: true
      });
      setTabIndex(walker.nextNode() ? undefined : 0);
    };
    updateTabIndex();
    const observer = new MutationObserver(updateTabIndex);
    observer.observe(ref, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["tabindex", "disabled"]
    });
    solidJs.onCleanup(() => {
      observer.disconnect();
    });
  }));
  solidJs.createEffect(solidJs.on([() => local.value, id], ([value, id]) => {
    context.contentIdsMap().set(value, id);
  }));
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => {
            presence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return id();
        },
        role: "tabpanel",
        get tabIndex() {
          return tabIndex();
        },
        get ["aria-labelledby"]() {
          return context.triggerIdsMap().get(local.value);
        },
        get ["data-orientation"]() {
          return context.orientation();
        },
        get ["data-selected"]() {
          return isSelected() ? "" : undefined;
        }
      }, others));
    }
  });
}

function TabsIndicator(props) {
  const context = useTabsContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  const [style, setStyle] = solidJs.createSignal({
    width: undefined,
    height: undefined
  });
  const {
    direction
  } = useLocale();
  const computeStyle = () => {
    const selectedTab = context.selectedTab();
    if (selectedTab == null) {
      return;
    }
    const styleObj = {
      transform: undefined,
      width: undefined,
      height: undefined
    };
    const offset = direction() === "rtl" ? -1 * (selectedTab.offsetParent?.offsetWidth - selectedTab.offsetWidth - selectedTab.offsetLeft) : selectedTab.offsetLeft;
    styleObj.transform = context.orientation() === "vertical" ? `translateY(${selectedTab.offsetTop}px)` : `translateX(${offset}px)`;
    if (context.orientation() === "horizontal") {
      styleObj.width = `${selectedTab.offsetWidth}px`;
    } else {
      styleObj.height = `${selectedTab.offsetHeight}px`;
    }
    setStyle(styleObj);
  };
  solidJs.onMount(() => {
    queueMicrotask(() => {
      computeStyle();
    });
  });
  solidJs.createEffect(solidJs.on([context.selectedTab, context.orientation, direction], () => {
    computeStyle();
  }, {
    defer: true
  }));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    role: "presentation",
    get style() {
      return {
        ...style(),
        ...local.style
      };
    },
    get ["data-orientation"]() {
      return context.orientation();
    }
  }, others));
}

class TabsKeyboardDelegate {
  constructor(collection, direction, orientation) {
    this.collection = collection;
    this.direction = direction;
    this.orientation = orientation;
  }
  flipDirection() {
    return this.direction() === "rtl" && this.orientation() === "horizontal";
  }
  getKeyLeftOf(key) {
    if (this.flipDirection()) {
      return this.getNextKey(key);
    }
    if (this.orientation() === "horizontal") {
      return this.getPreviousKey(key);
    }
    return undefined;
  }
  getKeyRightOf(key) {
    if (this.flipDirection()) {
      return this.getPreviousKey(key);
    }
    if (this.orientation() === "horizontal") {
      return this.getNextKey(key);
    }
    return undefined;
  }
  getKeyAbove(key) {
    if (this.orientation() === "vertical") {
      return this.getPreviousKey(key);
    }
    return undefined;
  }
  getKeyBelow(key) {
    if (this.orientation() === "vertical") {
      return this.getNextKey(key);
    }
    return undefined;
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.disabled) {
      key = this.getNextKey(key);
    }
    return key;
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.disabled) {
      key = this.getPreviousKey(key);
    }
    return key;
  }
  getNextKey(key) {
    let nextKey = key;
    let nextItem;
    do {
      nextKey = this.collection().getKeyAfter(nextKey) ?? this.collection().getFirstKey();
      if (nextKey == null) {
        return;
      }
      nextItem = this.collection().getItem(nextKey);
      if (nextItem == null) {
        return;
      }
    } while (nextItem.disabled);
    return nextKey;
  }
  getPreviousKey(key) {
    let previousKey = key;
    let previousItem;
    do {
      previousKey = this.collection().getKeyBefore(previousKey) ?? this.collection().getLastKey();
      if (previousKey == null) {
        return;
      }
      previousItem = this.collection().getItem(previousKey);
      if (previousItem == null) {
        return;
      }
    } while (previousItem.disabled);
    return previousKey;
  }
}

function TabsList(props) {
  let ref;
  const context = useTabsContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const delegate = new TabsKeyboardDelegate(() => context.listState().collection(), direction, context.orientation);
  const selectableCollection = createSelectableCollection({
    selectionManager: () => context.listState().selectionManager(),
    keyboardDelegate: () => delegate,
    selectOnFocus: () => context.activationMode() === "automatic",
    shouldFocusWrap: false,
    disallowEmptySelection: true
  }, () => ref);
  solidJs.createEffect(() => {
    if (ref == null) {
      return;
    }
    const selectedTab = ref.querySelector(`[data-key="${context.listState().selectedKey()}"]`);
    if (selectedTab != null) {
      context.setSelectedTab(selectedTab);
    }
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "tablist",
    get ["aria-orientation"]() {
      return context.orientation();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get onKeyDown() {
      return utils.composeEventHandlers([local.onKeyDown, selectableCollection.onKeyDown]);
    },
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableCollection.onMouseDown]);
    },
    get onFocusIn() {
      return utils.composeEventHandlers([local.onFocusIn, selectableCollection.onFocusIn]);
    },
    get onFocusOut() {
      return utils.composeEventHandlers([local.onFocusOut, selectableCollection.onFocusOut]);
    }
  }, others));
}

function TabsRoot(props) {
  const defaultId = `tabs-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    orientation: "horizontal",
    activationMode: "automatic"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["value", "defaultValue", "onChange", "orientation", "activationMode", "disabled"]);
  const [items, setItems] = solidJs.createSignal([]);
  const [selectedTab, setSelectedTab] = solidJs.createSignal();
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createSingleSelectListState({
    selectedKey: () => local.value,
    defaultSelectedKey: () => local.defaultValue,
    onSelectionChange: key => local.onChange?.(String(key)),
    dataSource: items
  });
  let lastSelectedKey = listState.selectedKey();
  solidJs.createEffect(solidJs.on([() => listState.selectionManager(), () => listState.collection(), () => listState.selectedKey()], ([selectionManager, collection, currentSelectedKey]) => {
    let selectedKey = currentSelectedKey;
    if (selectionManager.isEmpty() || selectedKey == null || !collection.getItem(selectedKey)) {
      selectedKey = collection.getFirstKey();
      let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
      while (selectedItem?.disabled && selectedItem.key !== collection.getLastKey()) {
        selectedKey = collection.getKeyAfter(selectedItem.key);
        selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
      }
      if (selectedItem?.disabled && selectedKey === collection.getLastKey()) {
        selectedKey = collection.getFirstKey();
      }
      if (selectedKey != null) {
        selectionManager.setSelectedKeys([selectedKey]);
      }
    }
    if (selectionManager.focusedKey() == null || !selectionManager.isFocused() && selectedKey !== lastSelectedKey) {
      selectionManager.setFocusedKey(selectedKey);
    }
    lastSelectedKey = selectedKey;
  }));
  const triggerIdsMap = new Map();
  const contentIdsMap = new Map();
  const context = {
    isDisabled: () => local.disabled ?? false,
    orientation: () => local.orientation,
    activationMode: () => local.activationMode,
    triggerIdsMap: () => triggerIdsMap,
    contentIdsMap: () => contentIdsMap,
    listState: () => listState,
    selectedTab,
    setSelectedTab,
    generateTriggerId: value => `${others.id}-trigger-${value}`,
    generateContentId: value => `${others.id}-content-${value}`
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(TabsContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            get ["data-orientation"]() {
              return context.orientation();
            }
          }, others));
        }
      });
    }
  });
}

function TabsTrigger(props) {
  let ref;
  const context = useTabsContext();
  const mergedProps = utils.mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "id", "value", "disabled", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const id = () => local.id ?? context.generateTriggerId(local.value);
  const isHighlighted = () => context.listState().selectionManager().focusedKey() === local.value;
  const isDisabled = () => local.disabled || context.isDisabled();
  const contentId = () => context.contentIdsMap().get(local.value);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: local.value,
      textValue: "",
      disabled: isDisabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => local.value,
    selectionManager: () => context.listState().selectionManager(),
    disabled: isDisabled
  }, () => ref);
  const onClick = e => {
    if (utils.isWebKit()) {
      utils.focusWithoutScrolling(e.currentTarget);
    }
  };
  solidJs.createEffect(solidJs.on([() => local.value, id], ([value, id]) => {
    context.triggerIdsMap().set(value, id);
  }));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "button",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return id();
    },
    role: "tab",
    get tabIndex() {
      return web.memo(() => !!!isDisabled())() ? selectableItem.tabIndex() : undefined;
    },
    get disabled() {
      return isDisabled();
    },
    get ["aria-selected"]() {
      return selectableItem.isSelected();
    },
    get ["aria-disabled"]() {
      return isDisabled() || undefined;
    },
    get ["aria-controls"]() {
      return web.memo(() => !!selectableItem.isSelected())() ? contentId() : undefined;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get ["data-selected"]() {
      return selectableItem.isSelected() ? "" : undefined;
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return isDisabled() ? "" : undefined;
    },
    get onPointerDown() {
      return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return utils.composeEventHandlers([local.onClick, selectableItem.onClick, onClick]);
    },
    get onKeyDown() {
      return utils.composeEventHandlers([local.onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    }
  }, others));
}

var index$4 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Content: TabsContent,
	Indicator: TabsIndicator,
	List: TabsList,
	Root: TabsRoot,
	Trigger: TabsTrigger
});

const TextFieldContext = solidJs.createContext();
function useTextFieldContext() {
  const context = solidJs.useContext(TextFieldContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTextFieldContext` must be used within a `TextField` component");
  }
  return context;
}

function TextFieldInput(props) {
  return web.createComponent(TextFieldInputBase, web.mergeProps({
    type: "text"
  }, props));
}
function TextFieldInputBase(props) {
  const formControlContext = useFormControlContext();
  const context = useTextFieldContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(mergedProps, ["onInput"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "input",
    get id() {
      return fieldProps.id();
    },
    get name() {
      return formControlContext.name();
    },
    get value() {
      return context.value();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    get onInput() {
      return utils.composeEventHandlers([local.onInput, context.onInput]);
    }
  }, () => formControlContext.dataset(), others));
}

function TextFieldRoot(props) {
  let ref;
  const defaultId = `textfield-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange"], FORM_CONTROL_PROP_NAMES);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setValue(local.defaultValue ?? ""));
  const onInput = e => {
    if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
      return;
    }
    const target = e.target;
    setValue(target.value);
    target.value = value() ?? "";
  };
  const context = {
    value,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    onInput
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(TextFieldContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

function TextFieldTextArea(props) {
  let ref;
  const context = useTextFieldContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("textarea")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "autoResize", "submitOnEnter", "onKeyPress"]);
  solidJs.createEffect(solidJs.on([() => ref, () => local.autoResize, () => context.value()], ([ref, autoResize]) => {
    if (!ref || !autoResize) {
      return;
    }
    adjustHeight(ref);
  }));
  const onKeyPress = event => {
    if (ref && local.submitOnEnter && event.key === "Enter" && !event.shiftKey) {
      if (ref.form) {
        ref.form.requestSubmit();
        event.preventDefault();
      }
    }
  };
  return web.createComponent(TextFieldInputBase, web.mergeProps({
    as: "textarea",
    get ["aria-multiline"]() {
      return local.submitOnEnter ? "false" : undefined;
    },
    get onKeyPress() {
      return utils.composeEventHandlers([local.onKeyPress, onKeyPress]);
    },
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}
function adjustHeight(el) {
  const prevAlignment = el.style.alignSelf;
  const prevOverflow = el.style.overflow;
  const isFirefox = ("MozAppearance" in el.style);
  if (!isFirefox) {
    el.style.overflow = "hidden";
  }
  el.style.alignSelf = "start";
  el.style.height = "auto";
  el.style.height = `${el.scrollHeight + (el.offsetHeight - el.clientHeight)}px`;
  el.style.overflow = prevOverflow;
  el.style.alignSelf = prevAlignment;
}

var index$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Input: TextFieldInput,
	Label: FormControlLabel,
	Root: TextFieldRoot,
	TextArea: TextFieldTextArea
});

const ToastContext = solidJs.createContext();
function useToastContext() {
  const context = solidJs.useContext(ToastContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useToastContext` must be used within a `Toast.Root` component");
  }
  return context;
}

function ToastCloseButton(props) {
  const context = useToastContext();
  const [local, others] = solidJs.splitProps(props, ["aria-label", "onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.close();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-label"]() {
      return local["aria-label"] || context.translations().close;
    },
    onClick: onClick
  }, others));
}

function ToastDescription(props) {
  const context = useToastContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, others));
}

const ToastRegionContext = solidJs.createContext();
function useToastRegionContext() {
  const context = solidJs.useContext(ToastRegionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useToastRegionContext` must be used within a `Toast.Region` component");
  }
  return context;
}

const _tmpl$$2 = /*#__PURE__*/web.template(`<ol tabindex="-1">`);
function ToastList(props) {
  let ref;
  const context = useToastRegionContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onFocusIn", "onFocusOut", "onPointerMove", "onPointerLeave"]);
  const onFocusIn = e => {
    utils.callHandler(e, local.onFocusIn);
    if (context.pauseOnInteraction() && !context.isPaused()) {
      context.pauseAllTimer();
    }
  };
  const onFocusOut = e => {
    utils.callHandler(e, local.onFocusOut);
    if (!utils.contains(ref, e.relatedTarget)) {
      context.resumeAllTimer();
    }
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (context.pauseOnInteraction() && !context.isPaused()) {
      context.pauseAllTimer();
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (!utils.contains(ref, utils.getDocument(ref).activeElement)) {
      context.resumeAllTimer();
    }
  };
  solidJs.createEffect(solidJs.on([() => ref, () => context.hotkey()], ([ref, hotkey]) => {
    if (web.isServer) {
      return;
    }
    if (!ref) {
      return;
    }
    const doc = utils.getDocument(ref);
    const onKeyDown = event => {
      const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);
      if (isHotkeyPressed) {
        utils.focusWithoutScrolling(ref);
      }
    };
    doc.addEventListener("keydown", onKeyDown);
    solidJs.onCleanup(() => doc.removeEventListener("keydown", onKeyDown));
  }));
  solidJs.createEffect(() => {
    if (!context.pauseOnPageIdle()) {
      return;
    }
    const win = utils.getWindow(ref);
    win.addEventListener("blur", context.pauseAllTimer);
    win.addEventListener("focus", context.resumeAllTimer);
    solidJs.onCleanup(() => {
      win.removeEventListener("blur", context.pauseAllTimer);
      win.removeEventListener("focus", context.resumeAllTimer);
    });
  });
  return (() => {
    const _el$ = _tmpl$$2();
    _el$.addEventListener("pointerleave", onPointerLeave);
    _el$.$$pointermove = onPointerMove;
    _el$.$$focusout = onFocusOut;
    _el$.$$focusin = onFocusIn;
    const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, others, false, true);
    web.insert(_el$, web.createComponent(solidJs.For, {
      get each() {
        return context.toasts();
      },
      children: toast => toast.toastComponent({
        get toastId() {
          return toast.id;
        }
      })
    }));
    return _el$;
  })();
}
web.delegateEvents(["focusin", "focusout", "pointermove"]);

function ToastProgressFill(props) {
  const rootContext = useToastRegionContext();
  const context = useToastContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  const [lifeTime, setLifeTime] = solidJs.createSignal(100);
  let totalElapsedTime = 0;
  solidJs.createEffect(() => {
    if (rootContext.isPaused() || context.isPersistent()) {
      return;
    }
    const intervalId = setInterval(() => {
      const elapsedTime = new Date().getTime() - context.closeTimerStartTime() + totalElapsedTime;
      const life = Math.trunc(100 - elapsedTime / context.duration() * 100);
      setLifeTime(life < 0 ? 0 : life);
    });
    solidJs.onCleanup(() => {
      totalElapsedTime += new Date().getTime() - context.closeTimerStartTime();
      clearInterval(intervalId);
    });
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get style() {
      return {
        "--kb-toast-progress-fill-width": `${lifeTime()}%`,
        ...local.style
      };
    }
  }, others));
}

function ToastProgressTrack(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    "aria-hidden": "true",
    role: "presentation"
  }, props));
}

const TOAST_HOTKEY_PLACEHOLDER = "{hotkey}";
const TOAST_INTL_TRANSLATIONS = {
  close: "Close"
};
const TOAST_REGION_INTL_TRANSLATIONS = {
  notifications: hotkeyPlaceholder => `Notifications (${hotkeyPlaceholder})`
};

const _tmpl$$1 = /*#__PURE__*/web.template(`<div role="region" tabindex="-1">`);
function ToastRegion(props) {
  const defaultId = `toast-region-${solidJs.createUniqueId()}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    hotkey: ["altKey", "KeyT"],
    duration: 5000,
    limit: 3,
    swipeDirection: "right",
    swipeThreshold: 50,
    pauseOnInteraction: true,
    pauseOnPageIdle: true,
    topLayer: true,
    translations: TOAST_REGION_INTL_TRANSLATIONS
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["translations", "style", "hotkey", "duration", "limit", "swipeDirection", "swipeThreshold", "pauseOnInteraction", "pauseOnPageIdle", "topLayer", "aria-label", "regionId"]);
  const toasts = solidJs.createMemo(() => toastStore.toasts().filter(toast => toast.region === local.regionId).slice(0, local.limit));
  const [isPaused, setIsPaused] = solidJs.createSignal(false);
  const hasToasts = () => toasts().length > 0;
  const hotkeyLabel = () => {
    return local.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
  };
  const ariaLabel = () => {
    const label = local["aria-label"] || local.translations.notifications(TOAST_HOTKEY_PLACEHOLDER);
    return label.replace(TOAST_HOTKEY_PLACEHOLDER, hotkeyLabel());
  };
  const topLayerAttr = () => ({
    [DATA_TOP_LAYER_ATTR]: local.topLayer ? "" : undefined
  });
  const context = {
    isPaused,
    toasts,
    hotkey: () => local.hotkey,
    duration: () => local.duration,
    swipeDirection: () => local.swipeDirection,
    swipeThreshold: () => local.swipeThreshold,
    pauseOnInteraction: () => local.pauseOnInteraction,
    pauseOnPageIdle: () => local.pauseOnPageIdle,
    pauseAllTimer: () => setIsPaused(true),
    resumeAllTimer: () => setIsPaused(false),
    generateId: utils.createGenerateId(() => others.id)
  };
  return web.createComponent(ToastRegionContext.Provider, {
    value: context,
    get children() {
      const _el$ = _tmpl$$1();
      web.spread(_el$, web.mergeProps({
        get ["aria-label"]() {
          return ariaLabel();
        },
        get style() {
          return {
            "pointer-events": hasToasts() ? local.topLayer ? "auto" : undefined : "none",
            ...local.style
          };
        }
      }, topLayerAttr, others), false, false);
      return _el$;
    }
  });
}

const _tmpl$ = /*#__PURE__*/web.template(`<li role="status" tabindex="0" aria-atomic="true">`);
const TOAST_SWIPE_START_EVENT = "toast.swipeStart";
const TOAST_SWIPE_MOVE_EVENT = "toast.swipeMove";
const TOAST_SWIPE_CANCEL_EVENT = "toast.swipeCancel";
const TOAST_SWIPE_END_EVENT = "toast.swipeEnd";
function ToastRoot(props) {
  const defaultId = `toast-${solidJs.createUniqueId()}`;
  const rootContext = useToastRegionContext();
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    priority: "high",
    translations: TOAST_INTL_TRANSLATIONS
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "translations", "toastId", "style", "priority", "duration", "persistent", "onPause", "onResume", "onSwipeStart", "onSwipeMove", "onSwipeCancel", "onSwipeEnd", "onEscapeKeyDown", "onKeyDown", "onPointerDown", "onPointerMove", "onPointerUp"]);
  const [isOpen, setIsOpen] = solidJs.createSignal(true);
  const [titleId, setTitleId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [isAnimationEnabled, setIsAnimationEnabled] = solidJs.createSignal(true);
  const presence = createPresence(isOpen);
  const duration = solidJs.createMemo(() => local.duration || rootContext.duration());
  let closeTimerId;
  let closeTimerStartTime = 0;
  let closeTimerRemainingTime = duration();
  let pointerStart = null;
  let swipeDelta = null;
  const close = () => {
    setIsOpen(false);
    setIsAnimationEnabled(true);
  };
  const deleteToast = () => {
    toastStore.remove(local.toastId);
  };
  const startTimer = duration => {
    if (!duration || local.persistent) {
      return;
    }
    window.clearTimeout(closeTimerId);
    closeTimerStartTime = new Date().getTime();
    closeTimerId = window.setTimeout(close, duration);
  };
  const resumeTimer = () => {
    startTimer(closeTimerRemainingTime);
    local.onResume?.();
  };
  const pauseTimer = () => {
    const elapsedTime = new Date().getTime() - closeTimerStartTime;
    closeTimerRemainingTime = closeTimerRemainingTime - elapsedTime;
    window.clearTimeout(closeTimerId);
    local.onPause?.();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key !== "Escape") {
      return;
    }
    local.onEscapeKeyDown?.(e);
    if (!e.defaultPrevented) {
      close();
    }
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (e.button !== 0) {
      return;
    }
    pointerStart = {
      x: e.clientX,
      y: e.clientY
    };
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (!pointerStart) {
      return;
    }
    const x = e.clientX - pointerStart.x;
    const y = e.clientY - pointerStart.y;
    const hasSwipeMoveStarted = Boolean(swipeDelta);
    const isHorizontalSwipe = ["left", "right"].includes(rootContext.swipeDirection());
    const clamp = ["left", "up"].includes(rootContext.swipeDirection()) ? Math.min : Math.max;
    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
    const moveStartBuffer = e.pointerType === "touch" ? 10 : 2;
    const delta = {
      x: clampedX,
      y: clampedY
    };
    const eventDetail = {
      originalEvent: e,
      delta
    };
    if (hasSwipeMoveStarted) {
      swipeDelta = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE_EVENT, local.onSwipeMove, eventDetail);
      const {
        x,
        y
      } = delta;
      e.currentTarget.setAttribute("data-swipe", "move");
      e.currentTarget.style.setProperty("--kb-toast-swipe-move-x", `${x}px`);
      e.currentTarget.style.setProperty("--kb-toast-swipe-move-y", `${y}px`);
    } else if (isDeltaInDirection(delta, rootContext.swipeDirection(), moveStartBuffer)) {
      swipeDelta = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_START_EVENT, local.onSwipeStart, eventDetail);
      e.currentTarget.setAttribute("data-swipe", "start");
      e.target.setPointerCapture(e.pointerId);
    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
      pointerStart = null;
    }
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    const delta = swipeDelta;
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    swipeDelta = null;
    pointerStart = null;
    if (delta) {
      const toast = e.currentTarget;
      const eventDetail = {
        originalEvent: e,
        delta
      };
      if (isDeltaInDirection(delta, rootContext.swipeDirection(), rootContext.swipeThreshold())) {
        handleAndDispatchCustomEvent(TOAST_SWIPE_END_EVENT, local.onSwipeEnd, eventDetail);
        const {
          x,
          y
        } = delta;
        e.currentTarget.setAttribute("data-swipe", "end");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
        e.currentTarget.style.setProperty("--kb-toast-swipe-end-x", `${x}px`);
        e.currentTarget.style.setProperty("--kb-toast-swipe-end-y", `${y}px`);
        close();
      } else {
        handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL_EVENT, local.onSwipeCancel, eventDetail);
        e.currentTarget.setAttribute("data-swipe", "cancel");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-end-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-end-y");
      }
      toast.addEventListener("click", event => event.preventDefault(), {
        once: true
      });
    }
  };
  solidJs.onMount(() => {
    if (rootContext.toasts().find(toast => toast.id === local.toastId && toast.update)) {
      setIsAnimationEnabled(false);
    }
  });
  solidJs.createEffect(solidJs.on(() => rootContext.isPaused(), isPaused => {
    if (isPaused) {
      pauseTimer();
    } else {
      resumeTimer();
    }
  }, {
    defer: true
  }));
  solidJs.createEffect(solidJs.on([isOpen, duration], ([isOpen, duration]) => {
    if (isOpen && !rootContext.isPaused()) {
      startTimer(duration);
    }
  }));
  solidJs.createEffect(solidJs.on(() => toastStore.get(local.toastId)?.dismiss, dismiss => dismiss && close()));
  solidJs.createEffect(solidJs.on(() => presence.isPresent(), isPresent => !isPresent && deleteToast()));
  const context = {
    translations: () => local.translations,
    close,
    duration,
    isPersistent: () => local.persistent ?? false,
    closeTimerStartTime: () => closeTimerStartTime,
    generateId: utils.createGenerateId(() => others.id),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(ToastContext.Provider, {
        value: context,
        get children() {
          const _el$ = _tmpl$();
          _el$.$$pointerup = onPointerUp;
          _el$.$$pointermove = onPointerMove;
          _el$.$$pointerdown = onPointerDown;
          _el$.$$keydown = onKeyDown;
          const _ref$ = utils.mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && web.use(_ref$, _el$);
          web.spread(_el$, web.mergeProps({
            get style() {
              return {
                animation: isAnimationEnabled() ? undefined : "none",
                "user-select": "none",
                "touch-action": "none",
                ...local.style
              };
            },
            get ["aria-live"]() {
              return local.priority === "high" ? "assertive" : "polite";
            },
            get ["aria-labelledby"]() {
              return titleId();
            },
            get ["aria-describedby"]() {
              return descriptionId();
            },
            get ["data-opened"]() {
              return isOpen() ? "" : undefined;
            },
            get ["data-closed"]() {
              return !isOpen() ? "" : undefined;
            },
            get ["data-swipe-direction"]() {
              return rootContext.swipeDirection();
            }
          }, others), false, false);
          return _el$;
        }
      });
    }
  });
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  }
  return !isDeltaX && deltaY > threshold;
}
function handleAndDispatchCustomEvent(name, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, {
    bubbles: true,
    cancelable: true,
    detail
  });
  if (handler) {
    currentTarget.addEventListener(name, handler, {
      once: true
    });
  }
  currentTarget.dispatchEvent(event);
}
web.delegateEvents(["keydown", "pointerdown", "pointermove", "pointerup"]);

function ToastTitle(props) {
  const context = useToastContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTitleId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, others));
}

var index$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CloseButton: ToastCloseButton,
	Description: ToastDescription,
	List: ToastList,
	ProgressFill: ToastProgressFill,
	ProgressTrack: ToastProgressTrack,
	Region: ToastRegion,
	Root: ToastRoot,
	Title: ToastTitle
});

function ToggleButtonRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["children", "pressed", "defaultPressed", "onChange", "onClick"]);
  const state = createToggleState({
    isSelected: () => local.pressed,
    defaultIsSelected: () => local.defaultPressed,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => others.disabled
  });
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    state.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-pressed"]() {
      return state.isSelected();
    },
    get ["data-pressed"]() {
      return state.isSelected() ? "" : undefined;
    },
    onClick: onClick
  }, others, {
    get children() {
      return web.createComponent(ToggleButtonRootChild, {
        get state() {
          return {
            pressed: state.isSelected
          };
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
function ToggleButtonRootChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

var index$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: ToggleButtonRoot
});

const TooltipContext = solidJs.createContext();
function useTooltipContext() {
  const context = solidJs.useContext(TooltipContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTooltipContext` must be used within a `Tooltip` component");
  }
  return context;
}

function TooltipContent(props) {
  const context = useTooltipContext();
  const mergedProps = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["ref", "style"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "tooltip",
            disableOutsidePointerEvents: false,
            get style() {
              return {
                "--kb-tooltip-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            onDismiss: () => context.hideTooltip(true)
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function TooltipPortal(props) {
  const context = useTooltipContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

function getTooltipSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

const tooltips = {};
let tooltipsCounter = 0;
let globalWarmedUp = false;
let globalWarmUpTimeout;
let globalCoolDownTimeout;
function TooltipRoot(props) {
  const defaultId = `tooltip-${solidJs.createUniqueId()}`;
  const tooltipId = `${++tooltipsCounter}`;
  const mergedProps = utils.mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = solidJs.splitProps(mergedProps, ["id", "open", "defaultOpen", "onOpenChange", "disabled", "triggerOnFocusOnly", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let closeTimeoutId;
  const [contentId, setContentId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(others.placement);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const ensureTooltipEntry = () => {
    tooltips[tooltipId] = hideTooltip;
  };
  const closeOpenTooltips = () => {
    for (const hideTooltipId in tooltips) {
      if (hideTooltipId !== tooltipId) {
        tooltips[hideTooltipId](true);
        delete tooltips[hideTooltipId];
      }
    }
  };
  const hideTooltip = (immediate = false) => {
    if (web.isServer) {
      return;
    }
    if (immediate || local.closeDelay && local.closeDelay <= 0) {
      window.clearTimeout(closeTimeoutId);
      closeTimeoutId = undefined;
      disclosureState.close();
    } else if (!closeTimeoutId) {
      closeTimeoutId = window.setTimeout(() => {
        closeTimeoutId = undefined;
        disclosureState.close();
      }, local.closeDelay);
    }
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    if (globalWarmedUp) {
      window.clearTimeout(globalCoolDownTimeout);
      globalCoolDownTimeout = window.setTimeout(() => {
        delete tooltips[tooltipId];
        globalCoolDownTimeout = undefined;
        globalWarmedUp = false;
      }, local.closeDelay);
    }
  };
  const showTooltip = () => {
    if (web.isServer) {
      return;
    }
    clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
    closeOpenTooltips();
    ensureTooltipEntry();
    globalWarmedUp = true;
    disclosureState.open();
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    window.clearTimeout(globalCoolDownTimeout);
    globalCoolDownTimeout = undefined;
  };
  const warmupTooltip = () => {
    if (web.isServer) {
      return;
    }
    closeOpenTooltips();
    ensureTooltipEntry();
    if (!disclosureState.isOpen() && !globalWarmUpTimeout && !globalWarmedUp) {
      globalWarmUpTimeout = window.setTimeout(() => {
        globalWarmUpTimeout = undefined;
        globalWarmedUp = true;
        showTooltip();
      }, local.openDelay);
    } else if (!disclosureState.isOpen()) {
      showTooltip();
    }
  };
  const openTooltip = (immediate = false) => {
    if (web.isServer) {
      return;
    }
    if (!immediate && local.openDelay && local.openDelay > 0 && !closeTimeoutId) {
      warmupTooltip();
    } else {
      showTooltip();
    }
  };
  const cancelOpening = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    globalWarmedUp = false;
  };
  const cancelClosing = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnTooltip = target => {
    return utils.contains(triggerRef(), target) || utils.contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getTooltipSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;
    if (isTargetOnTooltip(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());
      if (polygon && utils.isPointInPolygon(utils.getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }
    if (closeTimeoutId) {
      return;
    }
    hideTooltip();
  };
  solidJs.createEffect(() => {
    if (web.isServer) {
      return;
    }
    if (!disclosureState.isOpen()) {
      return;
    }
    const doc = utils.getDocument();
    doc.addEventListener("pointermove", onHoverOutside, true);
    solidJs.onCleanup(() => {
      doc.removeEventListener("pointermove", onHoverOutside, true);
    });
  });
  solidJs.createEffect(() => {
    const trigger = triggerRef();
    if (!trigger || !disclosureState.isOpen()) {
      return;
    }
    const handleScroll = event => {
      const target = event.target;
      if (utils.contains(target, trigger)) {
        hideTooltip(true);
      }
    };
    const win = utils.getWindow();
    win.addEventListener("scroll", handleScroll, {
      capture: true
    });
    solidJs.onCleanup(() => {
      win.removeEventListener("scroll", handleScroll, {
        capture: true
      });
    });
  });
  solidJs.onCleanup(() => {
    clearTimeout(closeTimeoutId);
    const tooltip = tooltips[tooltipId];
    if (tooltip) {
      delete tooltips[tooltipId];
    }
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => local.disabled ?? false,
    triggerOnFocusOnly: () => local.triggerOnFocusOnly ?? false,
    contentId,
    contentPresence,
    openTooltip,
    hideTooltip,
    cancelOpening,
    generateId: utils.createGenerateId(() => mergedProps.id),
    registerContentId: createRegisterId(setContentId),
    isTargetOnTooltip,
    setTriggerRef,
    setContentRef
  };
  return web.createComponent(TooltipContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(PopperRoot, web.mergeProps({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
}

function TooltipTrigger(props) {
  let ref;
  const context = useTooltipContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onPointerDown", "onClick", "onFocus", "onBlur", "onTouchStart"]);
  let isPointerDown = false;
  let isHovered = false;
  let isFocused = false;
  const handlePointerUp = () => {
    isPointerDown = false;
  };
  const handleShow = () => {
    if (!context.isOpen() && (isHovered || isFocused)) {
      context.openTooltip(isFocused);
    }
  };
  const handleHide = immediate => {
    if (context.isOpen() && !isHovered && !isFocused) {
      context.hideTooltip(immediate);
    }
  };
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || context.triggerOnFocusOnly() || context.isDisabled() || e.defaultPrevented) {
      return;
    }
    isHovered = true;
    handleShow();
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }
    isHovered = false;
    isFocused = false;
    if (context.isOpen()) {
      handleHide();
    } else {
      context.cancelOpening();
    }
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    isPointerDown = true;
    utils.getDocument(ref).addEventListener("pointerup", handlePointerUp, {
      once: true
    });
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    isHovered = false;
    isFocused = false;
    handleHide(true);
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (context.isDisabled() || e.defaultPrevented || isPointerDown) {
      return;
    }
    isFocused = true;
    handleShow();
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnTooltip(relatedTarget)) {
      return;
    }
    isHovered = false;
    isFocused = false;
    handleHide(true);
  };
  solidJs.onCleanup(() => {
    if (web.isServer) {
      return;
    }
    utils.getDocument(ref).removeEventListener("pointerup", handlePointerUp);
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "button",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["aria-describedby"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onPointerDown: onPointerDown,
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), others));
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: TooltipContent,
	Portal: TooltipPortal,
	Root: TooltipRoot,
	Trigger: TooltipTrigger
});

exports.Accordion = index$u;
exports.Alert = index$t;
exports.AlertDialog = index$r;
exports.As = As;
exports.Breadcrumbs = index$p;
exports.Button = index$w;
exports.COLOR_MODE_STORAGE_KEY = COLOR_MODE_STORAGE_KEY;
exports.Calendar = index$o;
exports.Checkbox = index$n;
exports.Collapsible = index$v;
exports.ColorModeContext = ColorModeContext;
exports.ColorModeProvider = ColorModeProvider;
exports.ColorModeScript = ColorModeScript;
exports.Combobox = index$l;
exports.ContextMenu = index$j;
exports.DATA_LIVE_ANNOUNCER_ATTR = DATA_LIVE_ANNOUNCER_ATTR;
exports.DatePicker = index$i;
exports.Dialog = index$s;
exports.DropdownMenu = index$h;
exports.FORM_CONTROL_FIELD_PROP_NAMES = FORM_CONTROL_FIELD_PROP_NAMES;
exports.FORM_CONTROL_PROP_NAMES = FORM_CONTROL_PROP_NAMES;
exports.FormControlContext = FormControlContext;
exports.FormControlDescription = FormControlDescription;
exports.FormControlErrorMessage = FormControlErrorMessage;
exports.FormControlLabel = FormControlLabel;
exports.HoverCard = index$g;
exports.I18nProvider = I18nProvider;
exports.Image = index$f;
exports.Link = index$q;
exports.ListCollection = ListCollection;
exports.ListKeyboardDelegate = ListKeyboardDelegate;
exports.Listbox = index$m;
exports.Menubar = index$e;
exports.NumberField = index$d;
exports.Pagination = index$c;
exports.Polymorphic = Polymorphic;
exports.Popover = index$b;
exports.Progress = index$a;
exports.RTL_LANGS = RTL_LANGS;
exports.RadioGroup = index$9;
exports.Select = index$8;
exports.Selection = Selection;
exports.SelectionManager = SelectionManager;
exports.Separator = index$k;
exports.Skeleton = index$7;
exports.Slider = index$6;
exports.Switch = index$5;
exports.Tabs = index$4;
exports.TextField = index$3;
exports.Toast = index$2;
exports.ToggleButton = index$1;
exports.Tooltip = index;
exports.announce = announce;
exports.ariaHideOutside = ariaHideOutside;
exports.clearAnnouncer = clearAnnouncer;
exports.cookieStorageManager = cookieStorageManager;
exports.cookieStorageManagerSSR = cookieStorageManagerSSR;
exports.createCollator = createCollator;
exports.createCollection = createCollection;
exports.createControllableArraySignal = createControllableArraySignal;
exports.createControllableBooleanSignal = createControllableBooleanSignal;
exports.createControllableSetSignal = createControllableSetSignal;
exports.createControllableSignal = createControllableSignal;
exports.createCookieStorageManager = createCookieStorageManager;
exports.createDateFormatter = createDateFormatter;
exports.createDefaultLocale = createDefaultLocale;
exports.createDisclosureState = createDisclosureState;
exports.createEscapeKeyDown = createEscapeKeyDown;
exports.createFilter = createFilter;
exports.createFocusScope = createFocusScope;
exports.createFormControl = createFormControl;
exports.createFormControlField = createFormControlField;
exports.createFormResetListener = createFormResetListener;
exports.createHideOutside = createHideOutside;
exports.createInteractOutside = createInteractOutside;
exports.createListState = createListState;
exports.createLocalStorageManager = createLocalStorageManager;
exports.createMultipleSelectionState = createMultipleSelectionState;
exports.createNumberFormatter = createNumberFormatter;
exports.createPresence = createPresence;
exports.createRegisterId = createRegisterId;
exports.createSelectableCollection = createSelectableCollection;
exports.createSelectableItem = createSelectableItem;
exports.createSelectableList = createSelectableList;
exports.createSingleSelectListState = createSingleSelectListState;
exports.createTagName = createTagName;
exports.createToggleState = createToggleState;
exports.createTransition = createTransition;
exports.createTypeSelect = createTypeSelect;
exports.destroyAnnouncer = destroyAnnouncer;
exports.getDefaultLocale = getDefaultLocale;
exports.getItemCount = getItemCount;
exports.getReadingDirection = getReadingDirection;
exports.isRTL = isRTL;
exports.localStorageManager = localStorageManager;
exports.toaster = toaster;
exports.useColorMode = useColorMode;
exports.useColorModeValue = useColorModeValue;
exports.useFormControlContext = useFormControlContext;
exports.useLocale = useLocale;
//# sourceMappingURL=index.js.map
