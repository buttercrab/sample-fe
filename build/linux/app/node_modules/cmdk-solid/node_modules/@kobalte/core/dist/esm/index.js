/**
 * MIT License
 *
 * Copyright (c) 2022 Fabien Marie-Louise
 *
 * License can be found in LICENSE.md,
 * also available at https://github.com/kobaltedev/kobalte/blob/main/LICENSE.md
 *
 * This codebase contains modified portions of code from multiple sources.
 * Credits to their original authors.
 *
 * A list of all sources and licenses can be found in NOTICE.txt,
 * also available at https://github.com/kobaltedev/kobalte/blob/main/NOTICE.txt
 */

import { isString, isNumber, access, accessWith, getDocument, EventKey, getActiveElement, contains, focusWithoutScrolling, removeItemFromArray, visuallyHiddenStyles, isFocusable, getAllTabbableIn, noop, composeEventHandlers, isCtrlKey, createMediaQuery, mergeDefaultProps, createGenerateId, isArray, combineProps as combineProps$1, mergeRefs, isAppleDevice, isMac, createEventListener, scrollIntoView, callHandler, getFocusableTreeWalker, isFunction, addItemToArray, getWindow, isWebKit, Key, isPointInPolygon, scrollIntoViewport, createFocusManager, isIOS, getScrollParent, createGlobalListeners, getEventPoint, clamp, snapValueToStep } from '@kobalte/utils';
import { createStore } from 'solid-js/store';
import { isServer, createComponent, effect, setAttribute, template, Dynamic, mergeProps as mergeProps$1, memo, Portal, use, spread, insert, style, delegateEvents } from 'solid-js/web';
import { createContext, useContext, createMemo, createSignal, createEffect, onCleanup, mergeProps, on, untrack, createUniqueId, splitProps, children, For, Show, onMount, createComputed, createComponent as createComponent$1, Index, Switch, Match, batch } from 'solid-js';
import createPreventScroll from 'solid-prevent-scroll';
import { DateFormatter, maxDate, toCalendarDate, minDate, isSameDay, startOfMonth, endOfMonth, startOfYear, startOfWeek, endOfWeek, today, getWeeksInMonth, isToday, isWeekend, isSameMonth, toCalendar, getDayOfWeek, GregorianCalendar, now, toCalendarDateTime, Time, getMinimumDayInMonth, getMinimumMonthInYear, CalendarDate } from '@internationalized/date';
import { autoUpdate, offset, flip, shift, size, hide, arrow, computePosition, platform } from '@floating-ui/dom';
import { NumberFormatter, NumberParser } from '@internationalized/number';

const ColorModeContext = createContext();
function useColorMode() {
  const context = useContext(ColorModeContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useColorMode` must be used within a `ColorModeProvider`");
  }
  return context;
}
function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return createMemo(() => colorMode() === "dark" ? dark : light);
}

const COLOR_MODE_STORAGE_KEY = "kb-color-mode";
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get: fallback => {
      if (isServer) {
        return fallback;
      }
      let value;
      try {
        value = localStorage.getItem(key);
      } catch (_) {}
      return value ?? fallback;
    },
    set: value => {
      try {
        localStorage.setItem(key, value);
      } catch (e) {}
    }
  };
}
const localStorageManager = createLocalStorageManager(COLOR_MODE_STORAGE_KEY);
function parseCookie(cookie, key) {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match?.[2];
}
function createCookieStorageManager(key, cookie) {
  return {
    ssr: !!cookie,
    type: "cookie",
    get: fallback => {
      if (cookie) {
        return parseCookie(cookie, key) ?? fallback;
      }
      if (isServer) {
        return fallback;
      }
      return parseCookie(document.cookie, key) ?? fallback;
    },
    set: value => {
      document.cookie = `${key}=${value}; max-age=31536000; path=/`;
    }
  };
}
const cookieStorageManager = createCookieStorageManager(COLOR_MODE_STORAGE_KEY);
function cookieStorageManagerSSR(cookie) {
  return createCookieStorageManager(COLOR_MODE_STORAGE_KEY, cookie);
}

const FALLBACK_COLOR_MODE_VALUE = "system";
function query() {
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function preventTransition() {
  const css = document.createElement("style");
  css.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"));
  document.head.appendChild(css);
  return () => {
    (() => window.getComputedStyle(document.body))();
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css);
      });
    });
  };
}
function setColorModeDataset(value, shouldPreventTransition = true) {
  const cleanup = shouldPreventTransition ? preventTransition() : undefined;
  document.documentElement.dataset.kbTheme = value;
  document.documentElement.style.colorScheme = value;
  cleanup?.();
}
function getSystemColorMode(fallback) {
  const isDark = query().matches ?? fallback === "dark";
  return isDark ? "dark" : "light";
}
function getInitialColorMode(manager) {
  const fallback = "light";
  const initialColorMode = manager.get(fallback) ?? fallback;
  if (initialColorMode === "system") {
    return isServer ? fallback : getSystemColorMode();
  }
  return initialColorMode;
}
function addColorModeListener(fn) {
  const mql = query();
  const listener = e => {
    fn(e.matches ? "dark" : "light");
  };
  mql.addEventListener("change", listener);
  return () => {
    mql.removeEventListener("change", listener);
  };
}

function ColorModeProvider(props) {
  const fallbackColorMode = () => props.initialColorMode ?? FALLBACK_COLOR_MODE_VALUE;
  const colorModeManager = () => props.storageManager ?? localStorageManager;
  let colorModeListenerCleanupFn;
  const [colorMode, rawSetColorMode] = createSignal(getInitialColorMode(colorModeManager()));
  const applyColorMode = value => {
    rawSetColorMode(value);
    setColorModeDataset(value, props.disableTransitionOnChange);
  };
  const setColorMode = value => {
    if (colorModeListenerCleanupFn) {
      colorModeListenerCleanupFn();
      colorModeListenerCleanupFn = undefined;
    }
    const isSystem = value === "system";
    if (isSystem) {
      colorModeListenerCleanupFn = addColorModeListener(applyColorMode);
    }
    applyColorMode(isSystem ? getSystemColorMode() : value);
    colorModeManager().set(value);
  };
  const toggleColorMode = () => {
    setColorMode(colorMode() === "dark" ? "light" : "dark");
  };
  createEffect(() => {
    setColorMode(colorModeManager().get() ?? fallbackColorMode());
  });
  onCleanup(() => {
    colorModeListenerCleanupFn?.();
  });
  const context = {
    colorMode,
    setColorMode,
    toggleColorMode
  };
  return createComponent(ColorModeContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

const _tmpl$$i = /*#__PURE__*/template(`<script id="kb-color-mode-script">`);
const VALID_VALUES = new Set(["light", "dark", "system"]);
function normalize(initialColorMode) {
  if (!VALID_VALUES.has(initialColorMode)) {
    return FALLBACK_COLOR_MODE_VALUE;
  }
  return initialColorMode;
}
function ColorModeScript(props) {
  const mergedProps = mergeProps({
    initialColorMode: FALLBACK_COLOR_MODE_VALUE,
    storageType: "localStorage",
    storageKey: COLOR_MODE_STORAGE_KEY
  }, props);
  const scriptSrc = createMemo(() => {
    const init = normalize(mergedProps.initialColorMode);
    const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,s=e==="dark";return d.style.colorScheme=e,d.dataset.kbTheme=e,o},u=a,h="${init}",r="${mergedProps.storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();`;
    const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,i=r==="dark";return o.style.colorScheme=r,o.dataset.kbTheme=r,c},n=a,m="${init}",e="${mergedProps.storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();`;
    const fn = mergedProps.storageType === "cookie" ? cookieScript : localStorageScript;
    return `!${fn}`.trim();
  });
  return (() => {
    const _el$ = _tmpl$$i();
    effect(_p$ => {
      const _v$ = mergedProps.nonce,
        _v$2 = scriptSrc();
      _v$ !== _p$._v$ && setAttribute(_el$, "nonce", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && (_el$.innerHTML = _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });
    return _el$;
  })();
}

function buildNodes(params) {
  let index = params.startIndex ?? 0;
  const level = params.startLevel ?? 0;
  const nodes = [];
  const getKey = data => {
    if (data == null) {
      return "";
    }
    const _getKey = params.getKey ?? "key";
    const dataKey = isString(_getKey) ? data[_getKey] : _getKey(data);
    return dataKey != null ? String(dataKey) : "";
  };
  const getTextValue = data => {
    if (data == null) {
      return "";
    }
    const _getTextValue = params.getTextValue ?? "textValue";
    const dataTextValue = isString(_getTextValue) ? data[_getTextValue] : _getTextValue(data);
    return dataTextValue != null ? String(dataTextValue) : "";
  };
  const getDisabled = data => {
    if (data == null) {
      return false;
    }
    const _getDisabled = params.getDisabled ?? "disabled";
    return (isString(_getDisabled) ? data[_getDisabled] : _getDisabled(data)) ?? false;
  };
  const getSectionChildren = data => {
    if (data == null) {
      return undefined;
    }
    if (isString(params.getSectionChildren)) {
      return data[params.getSectionChildren];
    }
    return params.getSectionChildren?.(data);
  };
  for (const data of params.dataSource) {
    if (isString(data) || isNumber(data)) {
      nodes.push({
        type: "item",
        rawValue: data,
        key: String(data),
        textValue: String(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
      continue;
    }
    if (getSectionChildren(data) != null) {
      nodes.push({
        type: "section",
        rawValue: data,
        key: "",
        textValue: "",
        disabled: false,
        level: level,
        index: index
      });
      index++;
      const sectionChildren = getSectionChildren(data) ?? [];
      if (sectionChildren.length > 0) {
        const childNodes = buildNodes({
          dataSource: sectionChildren,
          getKey: params.getKey,
          getTextValue: params.getTextValue,
          getDisabled: params.getDisabled,
          getSectionChildren: params.getSectionChildren,
          startIndex: index,
          startLevel: level + 1
        });
        nodes.push(...childNodes);
        index += childNodes.length;
      }
    } else {
      nodes.push({
        type: "item",
        rawValue: data,
        key: getKey(data),
        textValue: getTextValue(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
    }
  }
  return nodes;
}

function createCollection(props, deps = []) {
  const initialNodes = buildNodes({
    dataSource: access(props.dataSource),
    getKey: access(props.getKey),
    getTextValue: access(props.getTextValue),
    getDisabled: access(props.getDisabled),
    getSectionChildren: access(props.getSectionChildren)
  });
  const [collection, setCollection] = createSignal(props.factory(initialNodes));
  createEffect(on([() => access(props.dataSource), () => access(props.getKey), () => access(props.getTextValue), () => access(props.getDisabled), () => access(props.getSectionChildren), () => props.factory, ...deps], ([dataSource, getKey, getTextValue, getDisabled, getSectionChildren, factory]) => {
    const nodes = buildNodes({
      dataSource,
      getKey,
      getTextValue,
      getDisabled,
      getSectionChildren
    });
    setCollection(() => factory(nodes));
  }, {
    defer: true
  }));
  return collection;
}

const cache$1 = new WeakMap();
function getItemCount(collection) {
  let count = cache$1.get(collection);
  if (count != null) {
    return count;
  }
  count = 0;
  for (const item of collection) {
    if (item.type === "item") {
      count++;
    }
  }
  cache$1.set(collection, count);
  return count;
}

function createControllableSignal(props) {
  const [_value, _setValue] = createSignal(props.defaultValue?.());
  const isControlled = createMemo(() => props.value?.() !== undefined);
  const value = createMemo(() => isControlled() ? props.value?.() : _value());
  const setValue = next => {
    untrack(() => {
      const nextValue = accessWith(next, value());
      if (!Object.is(nextValue, value())) {
        if (!isControlled()) {
          _setValue(nextValue);
        }
        props.onChange?.(nextValue);
      }
      return nextValue;
    });
  };
  return [value, setValue];
}
function createControllableBooleanSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? false;
  return [value, setValue];
}
function createControllableArraySignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? [];
  return [value, setValue];
}
function createControllableSetSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Set();
  return [value, setValue];
}

function createDisclosureState(props = {}) {
  const [isOpen, setIsOpen] = createControllableBooleanSignal({
    value: () => access(props.open),
    defaultValue: () => !!access(props.defaultOpen),
    onChange: value => props.onOpenChange?.(value)
  });
  const open = () => {
    setIsOpen(true);
  };
  const close = () => {
    setIsOpen(false);
  };
  const toggle = () => {
    isOpen() ? close() : open();
  };
  return {
    isOpen,
    setIsOpen,
    open,
    close,
    toggle
  };
}

function createEscapeKeyDown(props) {
  const handleKeyDown = event => {
    if (event.key === EventKey.Escape) {
      props.onEscapeKeyDown?.(event);
    }
  };
  createEffect(() => {
    if (isServer) {
      return;
    }
    if (access(props.isDisabled)) {
      return;
    }
    const document = props.ownerDocument?.() ?? getDocument();
    document.addEventListener("keydown", handleKeyDown);
    onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
  });
}

const DATA_TOP_LAYER_ATTR = "data-kb-top-layer";
let originalBodyPointerEvents;
let hasDisabledBodyPointerEvents = false;
const layers = [];
function indexOf(node) {
  return layers.findIndex(layer => layer.node === node);
}
function find(node) {
  return layers[indexOf(node)];
}
function isTopMostLayer(node) {
  return layers[layers.length - 1].node === node;
}
function getPointerBlockingLayers() {
  return layers.filter(layer => layer.isPointerBlocking);
}
function getTopMostPointerBlockingLayer() {
  return [...getPointerBlockingLayers()].slice(-1)[0];
}
function hasPointerBlockingLayer() {
  return getPointerBlockingLayers().length > 0;
}
function isBelowPointerBlockingLayer(node) {
  const highestBlockingIndex = indexOf(getTopMostPointerBlockingLayer()?.node);
  return indexOf(node) < highestBlockingIndex;
}
function addLayer(layer) {
  layers.push(layer);
}
function removeLayer(node) {
  const index = indexOf(node);
  if (index < 0) {
    return;
  }
  layers.splice(index, 1);
}
function assignPointerEventToLayers() {
  for (const {
    node
  } of layers) {
    node.style.pointerEvents = isBelowPointerBlockingLayer(node) ? "none" : "auto";
  }
}
function disableBodyPointerEvents(node) {
  if (hasPointerBlockingLayer() && !hasDisabledBodyPointerEvents) {
    const ownerDocument = getDocument(node);
    originalBodyPointerEvents = document.body.style.pointerEvents;
    ownerDocument.body.style.pointerEvents = "none";
    hasDisabledBodyPointerEvents = true;
  }
}
function restoreBodyPointerEvents(node) {
  if (hasPointerBlockingLayer()) {
    return;
  }
  const ownerDocument = getDocument(node);
  ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
  if (ownerDocument.body.style.length === 0) {
    ownerDocument.body.removeAttribute("style");
  }
  hasDisabledBodyPointerEvents = false;
}
const layerStack = {
  layers,
  isTopMostLayer,
  hasPointerBlockingLayer,
  isBelowPointerBlockingLayer,
  addLayer,
  removeLayer,
  indexOf,
  find,
  assignPointerEventToLayers,
  disableBodyPointerEvents,
  restoreBodyPointerEvents
};

const AUTOFOCUS_ON_MOUNT_EVENT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT_EVENT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const focusScopeStack = {
  stack: [],
  active() {
    return this.stack[0];
  },
  add(scope) {
    if (scope !== this.active()) {
      this.active()?.pause();
    }
    this.stack = removeItemFromArray(this.stack, scope);
    this.stack.unshift(scope);
  },
  remove(scope) {
    this.stack = removeItemFromArray(this.stack, scope);
    this.active()?.resume();
  }
};
function createFocusScope(props, ref) {
  const [isPaused, setIsPaused] = createSignal(false);
  const focusScope = {
    pause() {
      setIsPaused(true);
    },
    resume() {
      setIsPaused(false);
    }
  };
  let lastFocusedElement = null;
  const onMountAutoFocus = e => props.onMountAutoFocus?.(e);
  const onUnmountAutoFocus = e => props.onUnmountAutoFocus?.(e);
  const ownerDocument = () => getDocument(ref());
  const createSentinel = () => {
    const element = ownerDocument().createElement("span");
    element.setAttribute("data-focus-trap", "");
    element.tabIndex = 0;
    Object.assign(element.style, visuallyHiddenStyles);
    return element;
  };
  const tabbables = () => {
    const container = ref();
    if (!container) {
      return [];
    }
    return getAllTabbableIn(container, true).filter(el => !el.hasAttribute("data-focus-trap"));
  };
  const firstTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[0] : null;
  };
  const lastTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[items.length - 1] : null;
  };
  const shouldPreventUnmountAutoFocus = () => {
    const container = ref();
    if (!container) {
      return false;
    }
    const activeElement = getActiveElement(container);
    if (!activeElement) {
      return false;
    }
    if (contains(container, activeElement)) {
      return false;
    }
    return isFocusable(activeElement);
  };
  createEffect(() => {
    if (isServer) {
      return;
    }
    const container = ref();
    if (!container) {
      return;
    }
    focusScopeStack.add(focusScope);
    const previouslyFocusedElement = getActiveElement(container);
    const hasFocusedCandidate = contains(container, previouslyFocusedElement);
    if (!hasFocusedCandidate) {
      const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT_EVENT, EVENT_OPTIONS);
      container.addEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      container.dispatchEvent(mountEvent);
      if (!mountEvent.defaultPrevented) {
        setTimeout(() => {
          focusWithoutScrolling(firstTabbable());
          if (getActiveElement(container) === previouslyFocusedElement) {
            focusWithoutScrolling(container);
          }
        }, 0);
      }
    }
    onCleanup(() => {
      container.removeEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      setTimeout(() => {
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT_EVENT, EVENT_OPTIONS);
        if (shouldPreventUnmountAutoFocus()) {
          unmountEvent.preventDefault();
        }
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        if (!unmountEvent.defaultPrevented) {
          focusWithoutScrolling(previouslyFocusedElement ?? ownerDocument().body);
        }
        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        focusScopeStack.remove(focusScope);
      }, 0);
    });
  });
  createEffect(() => {
    if (isServer) {
      return;
    }
    const container = ref();
    if (!container || !access(props.trapFocus) || isPaused()) {
      return;
    }
    const onFocusIn = event => {
      const target = event.target;
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (contains(container, target)) {
        lastFocusedElement = target;
      } else {
        focusWithoutScrolling(lastFocusedElement);
      }
    };
    const onFocusOut = event => {
      const relatedTarget = event.relatedTarget;
      const target = relatedTarget ?? getActiveElement(container);
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (!contains(container, target)) {
        focusWithoutScrolling(lastFocusedElement);
      }
    };
    ownerDocument().addEventListener("focusin", onFocusIn);
    ownerDocument().addEventListener("focusout", onFocusOut);
    onCleanup(() => {
      ownerDocument().removeEventListener("focusin", onFocusIn);
      ownerDocument().removeEventListener("focusout", onFocusOut);
    });
  });
  createEffect(() => {
    if (isServer) {
      return;
    }
    const container = ref();
    if (!container || !access(props.trapFocus) || isPaused()) {
      return;
    }
    const startSentinel = createSentinel();
    container.insertAdjacentElement("afterbegin", startSentinel);
    const endSentinel = createSentinel();
    container.insertAdjacentElement("beforeend", endSentinel);
    function onFocus(event) {
      const first = firstTabbable();
      const last = lastTabbable();
      if (event.relatedTarget === first) {
        focusWithoutScrolling(last);
      } else {
        focusWithoutScrolling(first);
      }
    }
    startSentinel.addEventListener("focusin", onFocus);
    endSentinel.addEventListener("focusin", onFocus);
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.previousSibling === endSentinel) {
          endSentinel.remove();
          container.insertAdjacentElement("beforeend", endSentinel);
        }
        if (mutation.nextSibling === startSentinel) {
          startSentinel.remove();
          container.insertAdjacentElement("afterbegin", startSentinel);
        }
      }
    });
    observer.observe(container, {
      childList: true,
      subtree: false
    });
    onCleanup(() => {
      startSentinel.removeEventListener("focusin", onFocus);
      endSentinel.removeEventListener("focusin", onFocus);
      startSentinel.remove();
      endSentinel.remove();
      observer.disconnect();
    });
  });
}

function createFormResetListener(element, handler) {
  createEffect(on(element, element => {
    if (element == null) {
      return;
    }
    const form = getClosestForm(element);
    if (form == null) {
      return;
    }
    form.addEventListener("reset", handler, {
      passive: true
    });
    onCleanup(() => {
      form.removeEventListener("reset", handler);
    });
  }));
}
function getClosestForm(element) {
  return isFormElement(element) ? element.form : element.closest("form");
}
function isFormElement(element) {
  return element.matches("textarea, input, select, button");
}

const LIVEREGION_TIMEOUT_DELAY = 7000;
let liveAnnouncer = null;
const DATA_LIVE_ANNOUNCER_ATTR = "data-live-announcer";
function announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
  if (!liveAnnouncer) {
    liveAnnouncer = new LiveAnnouncer();
  }
  liveAnnouncer.announce(message, assertiveness, timeout);
}
function clearAnnouncer(assertiveness) {
  if (liveAnnouncer) {
    liveAnnouncer.clear(assertiveness);
  }
}
function destroyAnnouncer() {
  if (liveAnnouncer) {
    liveAnnouncer.destroy();
    liveAnnouncer = null;
  }
}
class LiveAnnouncer {
  constructor() {
    this.node = document.createElement("div");
    this.node.dataset.liveAnnouncer = "true";
    Object.assign(this.node.style, visuallyHiddenStyles);
    this.assertiveLog = this.createLog("assertive");
    this.node.appendChild(this.assertiveLog);
    this.politeLog = this.createLog("polite");
    this.node.appendChild(this.politeLog);
    document.body.prepend(this.node);
  }
  createLog(ariaLive) {
    const node = document.createElement("div");
    node.setAttribute("role", "log");
    node.setAttribute("aria-live", ariaLive);
    node.setAttribute("aria-relevant", "additions");
    return node;
  }
  destroy() {
    if (!this.node) {
      return;
    }
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
    if (!this.node) {
      return;
    }
    const node = document.createElement("div");
    node.textContent = message;
    if (assertiveness === "assertive") {
      this.assertiveLog.appendChild(node);
    } else {
      this.politeLog.appendChild(node);
    }
    if (message !== "") {
      setTimeout(() => {
        node.remove();
      }, timeout);
    }
  }
  clear(assertiveness) {
    if (!this.node) {
      return;
    }
    if (!assertiveness || assertiveness === "assertive") {
      this.assertiveLog.innerHTML = "";
    }
    if (!assertiveness || assertiveness === "polite") {
      this.politeLog.innerHTML = "";
    }
  }
}

function createHideOutside(props) {
  createEffect(() => {
    if (access(props.isDisabled)) {
      return;
    }
    onCleanup(ariaHideOutside(access(props.targets), access(props.root)));
  });
}
const refCountMap = new WeakMap();
const observerStack = [];
function ariaHideOutside(targets, root = document.body) {
  const visibleNodes = new Set(targets);
  const hiddenNodes = new Set();
  const walk = root => {
    for (const element of root.querySelectorAll(`[${DATA_LIVE_ANNOUNCER_ATTR}], [${DATA_TOP_LAYER_ATTR}]`)) {
      visibleNodes.add(element);
    }
    const acceptNode = node => {
      if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }
      for (const target of visibleNodes) {
        if (node.contains(target)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });
    const acceptRoot = acceptNode(root);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {
      hide(root);
    }
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node = walker.nextNode();
      while (node != null) {
        hide(node);
        node = walker.nextNode();
      }
    }
  };
  const hide = node => {
    const refCount = refCountMap.get(node) ?? 0;
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  walk(root);
  const observer = new MutationObserver(changes => {
    for (const change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }
      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {
        for (const node of change.removedNodes) {
          if (node instanceof Element) {
            visibleNodes.delete(node);
            hiddenNodes.delete(node);
          }
        }
        for (const node of change.addedNodes) {
          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === "true" || node.dataset.reactAriaTopLayer === "true")) {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            walk(node);
          }
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  const observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (const node of hiddenNodes) {
      const count = refCountMap.get(node);
      if (count == null) {
        return;
      }
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}

const POINTER_DOWN_OUTSIDE_EVENT = "interactOutside.pointerDownOutside";
const FOCUS_OUTSIDE_EVENT = "interactOutside.focusOutside";
function createInteractOutside(props, ref) {
  let pointerDownTimeoutId;
  let clickHandler = noop;
  const ownerDocument = () => getDocument(ref());
  const onPointerDownOutside = e => props.onPointerDownOutside?.(e);
  const onFocusOutside = e => props.onFocusOutside?.(e);
  const onInteractOutside = e => props.onInteractOutside?.(e);
  const isEventOutside = e => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) {
      return false;
    }
    if (target.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
      return false;
    }
    if (!contains(ownerDocument(), target)) {
      return false;
    }
    if (contains(ref(), target)) {
      return false;
    }
    return !props.shouldExcludeElement?.(target);
  };
  const onPointerDown = e => {
    function handler() {
      const container = ref();
      const target = e.target;
      if (!container || !target || !isEventOutside(e)) {
        return;
      }
      const handler = composeEventHandlers([onPointerDownOutside, onInteractOutside]);
      target.addEventListener(POINTER_DOWN_OUTSIDE_EVENT, handler, {
        once: true
      });
      const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: e,
          isContextMenu: e.button === 2 || isCtrlKey(e) && e.button === 0
        }
      });
      target.dispatchEvent(pointerDownOutsideEvent);
    }
    if (e.pointerType === "touch") {
      ownerDocument().removeEventListener("click", handler);
      clickHandler = handler;
      ownerDocument().addEventListener("click", handler, {
        once: true
      });
    } else {
      handler();
    }
  };
  const onFocusIn = e => {
    const container = ref();
    const target = e.target;
    if (!container || !target || !isEventOutside(e)) {
      return;
    }
    const handler = composeEventHandlers([onFocusOutside, onInteractOutside]);
    target.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
      once: true
    });
    const focusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: e,
        isContextMenu: false
      }
    });
    target.dispatchEvent(focusOutsideEvent);
  };
  createEffect(() => {
    if (isServer) {
      return;
    }
    if (access(props.isDisabled)) {
      return;
    }
    pointerDownTimeoutId = window.setTimeout(() => {
      ownerDocument().addEventListener("pointerdown", onPointerDown, true);
    }, 0);
    ownerDocument().addEventListener("focusin", onFocusIn, true);
    onCleanup(() => {
      window.clearTimeout(pointerDownTimeoutId);
      ownerDocument().removeEventListener("click", clickHandler);
      ownerDocument().removeEventListener("pointerdown", onPointerDown, true);
      ownerDocument().removeEventListener("focusin", onFocusIn, true);
    });
  });
}

function createPresence(present) {
  const [node, setNode] = createSignal();
  let styles = {};
  let prevPresent = present();
  let prevAnimationName = "none";
  const [state, send] = createStateMachine(present() ? "mounted" : "unmounted", {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  createEffect(on(state, state => {
    const currentAnimationName = getAnimationName(styles);
    prevAnimationName = state === "mounted" ? currentAnimationName : "none";
  }));
  createEffect(on(present, present => {
    if (prevPresent === present) {
      return;
    }
    const currentAnimationName = getAnimationName(styles);
    if (present) {
      send("MOUNT");
    } else if (styles?.display === "none") {
      send("UNMOUNT");
    } else {
      const isAnimating = prevAnimationName !== currentAnimationName;
      if (prevPresent && isAnimating) {
        send("ANIMATION_OUT");
      } else {
        send("UNMOUNT");
      }
    }
    prevPresent = present;
  }));
  createEffect(on(node, node => {
    if (node) {
      const handleAnimationEnd = event => {
        const currentAnimationName = getAnimationName(styles);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
        }
      };
      const handleAnimationStart = event => {
        if (event.target === node) {
          prevAnimationName = getAnimationName(styles);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      onCleanup(() => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      });
    } else {
      send("ANIMATION_END");
    }
  }));
  return {
    isPresent: () => ["mounted", "unmountSuspended"].includes(state()),
    setRef: el => {
      if (el) {
        styles = getComputedStyle(el);
      }
      setNode(el);
    }
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function createStateMachine(initialState, machine) {
  const reduce = (state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  };
  const [state, setState] = createSignal(initialState);
  const send = event => {
    setState(prev => reduce(prev, event));
  };
  return [state, send];
}

function createRegisterId(setter) {
  return id => {
    setter(id);
    return () => setter(undefined);
  };
}

function createTagName(ref, fallback) {
  const [tagName, setTagName] = createSignal(stringOrUndefined(fallback?.()));
  createEffect(() => {
    setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));
  });
  return tagName;
}
function stringOrUndefined(value) {
  return isString(value) ? value : undefined;
}

function createToggleState(props = {}) {
  const [isSelected, _setIsSelected] = createControllableBooleanSignal({
    value: () => access(props.isSelected),
    defaultValue: () => !!access(props.defaultIsSelected),
    onChange: value => props.onSelectedChange?.(value)
  });
  const setIsSelected = value => {
    if (!access(props.isReadOnly) && !access(props.isDisabled)) {
      _setIsSelected(value);
    }
  };
  const toggle = () => {
    if (!access(props.isReadOnly) && !access(props.isDisabled)) {
      _setIsSelected(!isSelected());
    }
  };
  return {
    isSelected,
    setIsSelected,
    toggle
  };
}

const TRANSITION_PHASES_MAP = {
  beforeEnter: "out",
  enter: "in",
  afterEnter: "in",
  beforeExit: "in",
  exit: "out",
  afterExit: "out"
};
function getTransitionStyles(params) {
  const shared = {
    "transition-duration": `${params.duration}ms`,
    "transition-timing-function": params.easing
  };
  return {
    "transition-property": getTransitionProperty(params.transition),
    ...shared,
    ...params.transition.common,
    ...params.transition[TRANSITION_PHASES_MAP[params.phase]]
  };
}
function getTransitionProperty(transitionStyles) {
  return [...new Set([...Object.keys(transitionStyles.in), ...Object.keys(transitionStyles.out)])].join(", ");
}

const DEFAULT_DURATION = 250;
const DEFAULT_DELAY = 10;
const DEFAULT_EASING = "ease";
function createTransition(shouldMount, options) {
  const mergedOptions = mergeProps({
    duration: DEFAULT_DURATION,
    delay: DEFAULT_DELAY,
    easing: DEFAULT_EASING,
    get exitDuration() {
      return access(options).duration || DEFAULT_DURATION;
    },
    get exitDelay() {
      return access(options).delay || DEFAULT_DELAY;
    },
    get exitEasing() {
      return access(options).easing || DEFAULT_EASING;
    }
  }, options);
  const reduceMotion = createMediaQuery("(prefers-reduced-motion: reduce)");
  const [duration, setDuration] = createSignal(reduceMotion() ? 0 : access(mergedOptions).duration);
  const [phase, setPhase] = createSignal(access(shouldMount) ? "afterEnter" : "afterExit");
  const [easing, setEasing] = createSignal(access(mergedOptions).easing);
  let timeoutId = -1;
  const handleStateChange = shouldMount => {
    const preHandler = shouldMount ? access(mergedOptions).onBeforeEnter : access(mergedOptions).onBeforeExit;
    const postHandler = shouldMount ? access(mergedOptions).onAfterEnter : access(mergedOptions).onAfterExit;
    setPhase(shouldMount ? "beforeEnter" : "beforeExit");
    window.clearTimeout(timeoutId);
    const newDuration = setDuration(reduceMotion() ? 0 : shouldMount ? access(mergedOptions).duration : access(mergedOptions).exitDuration);
    setEasing(shouldMount ? access(mergedOptions).easing : access(mergedOptions).exitEasing);
    if (newDuration === 0) {
      preHandler?.();
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
      return;
    }
    const delay = reduceMotion() ? 0 : shouldMount ? access(mergedOptions).delay : access(mergedOptions).exitDelay;
    const preStateTimeoutId = window.setTimeout(() => {
      preHandler?.();
      setPhase(shouldMount ? "enter" : "exit");
    }, delay);
    timeoutId = window.setTimeout(() => {
      window.clearTimeout(preStateTimeoutId);
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
    }, delay + newDuration);
  };
  const style = createMemo(() => getTransitionStyles({
    transition: access(mergedOptions).transition,
    duration: duration(),
    phase: phase(),
    easing: easing()
  }));
  const keepMounted = createMemo(() => phase() !== "afterExit");
  createEffect(on(() => access(shouldMount), shouldMount => handleStateChange(shouldMount), {
    defer: true
  }));
  onCleanup(() => {
    if (isServer) {
      return;
    }
    window.clearTimeout(timeoutId);
  });
  return {
    keepMounted,
    style
  };
}

const FORM_CONTROL_PROP_NAMES = ["id", "name", "validationState", "required", "disabled", "readOnly"];
function createFormControl(props) {
  const defaultId = `form-control-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [labelId, setLabelId] = createSignal();
  const [fieldId, setFieldId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [errorMessageId, setErrorMessageId] = createSignal();
  const getAriaLabelledBy = (fieldId, fieldAriaLabel, fieldAriaLabelledBy) => {
    const hasAriaLabelledBy = fieldAriaLabelledBy != null || labelId() != null;
    return [fieldAriaLabelledBy, labelId(), hasAriaLabelledBy && fieldAriaLabel != null ? fieldId : undefined].filter(Boolean).join(" ") || undefined;
  };
  const getAriaDescribedBy = fieldAriaDescribedBy => {
    return [descriptionId(), errorMessageId(), fieldAriaDescribedBy].filter(Boolean).join(" ") || undefined;
  };
  const dataset = createMemo(() => ({
    "data-valid": access(mergedProps.validationState) === "valid" ? "" : undefined,
    "data-invalid": access(mergedProps.validationState) === "invalid" ? "" : undefined,
    "data-required": access(mergedProps.required) ? "" : undefined,
    "data-disabled": access(mergedProps.disabled) ? "" : undefined,
    "data-readonly": access(mergedProps.readOnly) ? "" : undefined
  }));
  const formControlContext = {
    name: () => access(mergedProps.name) ?? access(mergedProps.id),
    dataset,
    validationState: () => access(mergedProps.validationState),
    isRequired: () => access(mergedProps.required),
    isDisabled: () => access(mergedProps.disabled),
    isReadOnly: () => access(mergedProps.readOnly),
    labelId,
    fieldId,
    descriptionId,
    errorMessageId,
    getAriaLabelledBy,
    getAriaDescribedBy,
    generateId: createGenerateId(() => access(mergedProps.id)),
    registerLabel: createRegisterId(setLabelId),
    registerField: createRegisterId(setFieldId),
    registerDescription: createRegisterId(setDescriptionId),
    registerErrorMessage: createRegisterId(setErrorMessageId)
  };
  return {
    formControlContext
  };
}

const FormControlContext = createContext();
function useFormControlContext() {
  const context = useContext(FormControlContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useFormControlContext` must be used within a `FormControlContext.Provider` component");
  }
  return context;
}

const FORM_CONTROL_FIELD_PROP_NAMES = ["id", "aria-label", "aria-labelledby", "aria-describedby"];
function createFormControlField(props) {
  const context = useFormControlContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("field")
  }, props);
  createEffect(() => onCleanup(context.registerField(access(mergedProps.id))));
  return {
    fieldProps: {
      id: () => access(mergedProps.id),
      ariaLabel: () => access(mergedProps["aria-label"]),
      ariaLabelledBy: () => context.getAriaLabelledBy(access(mergedProps.id), access(mergedProps["aria-label"]), access(mergedProps["aria-labelledby"])),
      ariaDescribedBy: () => context.getAriaDescribedBy(access(mergedProps["aria-describedby"]))
    }
  };
}

function Polymorphic(props) {
  const [local, others] = splitProps(props, ["asChild", "as", "children"]);
  if (!local.asChild) {
    return createComponent(Dynamic, mergeProps$1({
      get component() {
        return local.as;
      }
    }, others, {
      get children() {
        return local.children;
      }
    }));
  }
  const resolvedChildren = children(() => local.children);
  if (isAs(resolvedChildren())) {
    const combinedProps = combineProps(others, resolvedChildren()?.props ?? {});
    return createComponent(Dynamic, combinedProps);
  }
  if (isArray(resolvedChildren())) {
    const newElement = resolvedChildren().find(isAs);
    if (newElement) {
      const newChildren = () => createComponent(For, {
        get each() {
          return resolvedChildren();
        },
        children: child => createComponent(Show, {
          when: child === newElement,
          fallback: child,
          get children() {
            return newElement.props.children;
          }
        })
      });
      const combinedProps = combineProps(others, newElement?.props ?? {});
      return createComponent(Dynamic, mergeProps$1(combinedProps, {
        children: newChildren
      }));
    }
  }
  throw new Error("[kobalte]: Component is expected to render `asChild` but no children `As` component was found.");
}
const AS_COMPONENT_SYMBOL = Symbol("$$KobalteAsComponent");
function As(props) {
  return {
    [AS_COMPONENT_SYMBOL]: true,
    props
  };
}
function isAs(component) {
  return component?.[AS_COMPONENT_SYMBOL] === true;
}
function combineProps(baseProps, overrideProps) {
  return combineProps$1([baseProps, overrideProps], {
    reverseEventHandlers: true
  });
}

function FormControlDescription(props) {
  const context = useFormControlContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  createEffect(() => onCleanup(context.registerDescription(mergedProps.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div"
  }, () => context.dataset(), mergedProps));
}

function FormControlErrorMessage(props) {
  const context = useFormControlContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("error-message")
  }, props);
  const [local, others] = splitProps(mergedProps, ["forceMount"]);
  const isInvalid = () => context.validationState() === "invalid";
  createEffect(() => {
    if (!isInvalid()) {
      return;
    }
    onCleanup(context.registerErrorMessage(others.id));
  });
  return createComponent(Show, {
    get when() {
      return local.forceMount || isInvalid();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}

function FormControlLabel(props) {
  let ref;
  const context = useFormControlContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref"]);
  const tagName = createTagName(() => ref, () => "label");
  createEffect(() => onCleanup(context.registerLabel(others.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "label",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["for"]() {
      return memo(() => tagName() === "label")() ? context.fieldId() : undefined;
    }
  }, () => context.dataset(), others));
}

const RTL_SCRIPTS = new Set(["Avst", "Arab", "Armi", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]);
const RTL_LANGS = new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}
function getReadingDirection(locale) {
  return isRTL(locale) ? "rtl" : "ltr";
}

function getDefaultLocale() {
  let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([locale]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: getReadingDirection(locale)
  };
}
let currentLocale = getDefaultLocale();
const listeners = new Set();
function updateLocale() {
  currentLocale = getDefaultLocale();
  for (const listener of listeners) {
    listener(currentLocale);
  }
}
function createDefaultLocale() {
  const defaultSSRLocale = {
    locale: "en-US",
    direction: "ltr"
  };
  const [defaultClientLocale, setDefaultClientLocale] = createSignal(currentLocale);
  const defaultLocale = createMemo(() => isServer ? defaultSSRLocale : defaultClientLocale());
  onMount(() => {
    if (listeners.size === 0) {
      window.addEventListener("languagechange", updateLocale);
    }
    listeners.add(setDefaultClientLocale);
    onCleanup(() => {
      listeners.delete(setDefaultClientLocale);
      if (listeners.size === 0) {
        window.removeEventListener("languagechange", updateLocale);
      }
    });
  });
  return {
    locale: () => defaultLocale().locale,
    direction: () => defaultLocale().direction
  };
}

const I18nContext = createContext();
function I18nProvider(props) {
  const defaultLocale = createDefaultLocale();
  const context = {
    locale: () => props.locale ?? defaultLocale.locale(),
    direction: () => props.locale ? getReadingDirection(props.locale) : defaultLocale.direction()
  };
  return createComponent(I18nContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}
function useLocale() {
  const defaultLocale = createDefaultLocale();
  const context = useContext(I18nContext);
  return context || defaultLocale;
}

const cache = new Map();
function createCollator(options) {
  const {
    locale
  } = useLocale();
  const cacheKey = createMemo(() => {
    return locale() + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  });
  return createMemo(() => {
    const key = cacheKey();
    let collator;
    if (cache.has(key)) {
      collator = cache.get(key);
    }
    if (!collator) {
      collator = new Intl.Collator(locale(), options);
      cache.set(key, collator);
    }
    return collator;
  });
}

function createDateFormatter(options) {
  const {
    locale
  } = useLocale();
  return createMemo(() => new DateFormatter(locale(), access(options)));
}

function createFilter(options) {
  const collator = createCollator({
    usage: "search",
    ...options
  });
  const startsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    const normalizedStr = str.normalize("NFC");
    const normalizedSubstr = substr.normalize("NFC");
    return collator().compare(normalizedStr.slice(0, normalizedSubstr.length), normalizedSubstr) === 0;
  };
  const endsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    const normalizedStr = str.normalize("NFC");
    const normalizedSubstr = substr.normalize("NFC");
    return collator().compare(normalizedStr.slice(-normalizedSubstr.length), normalizedSubstr) === 0;
  };
  const contains = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    const normalizedStr = str.normalize("NFC");
    const normalizedSubstr = substr.normalize("NFC");
    let scan = 0;
    const sliceLen = substr.length;
    for (; scan + sliceLen <= normalizedStr.length; scan++) {
      const slice = normalizedStr.slice(scan, scan + sliceLen);
      if (collator().compare(normalizedSubstr, slice) === 0) {
        return true;
      }
    }
    return false;
  };
  return {
    startsWith,
    endsWith,
    contains
  };
}

function createNumberFormatter(options) {
  const {
    locale
  } = useLocale();
  return createMemo(() => new NumberFormatter(locale(), access(options)));
}

class Selection extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
}

function createControllableSelectionSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Selection();
  return [value, setValue];
}

function isNonContiguousSelectionModifier(e) {
  return isAppleDevice() ? e.altKey : e.ctrlKey;
}
function isCtrlKeyPressed(e) {
  if (isMac()) {
    return e.metaKey;
  }
  return e.ctrlKey;
}
function convertSelection(selection) {
  return new Selection(selection);
}
function isSameSelection(setA, setB) {
  if (setA.size !== setB.size) {
    return false;
  }
  for (const item of setA) {
    if (!setB.has(item)) {
      return false;
    }
  }
  return true;
}

function createMultipleSelectionState(props) {
  const mergedProps = mergeDefaultProps({
    selectionMode: "none",
    selectionBehavior: "toggle"
  }, props);
  const [isFocused, setFocused] = createSignal(false);
  const [focusedKey, setFocusedKey] = createSignal();
  const selectedKeysProp = createMemo(() => {
    const selection = access(mergedProps.selectedKeys);
    if (selection != null) {
      return convertSelection(selection);
    }
    return selection;
  });
  const defaultSelectedKeys = createMemo(() => {
    const defaultSelection = access(mergedProps.defaultSelectedKeys);
    if (defaultSelection != null) {
      return convertSelection(defaultSelection);
    }
    return new Selection();
  });
  const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({
    value: selectedKeysProp,
    defaultValue: defaultSelectedKeys,
    onChange: value => mergedProps.onSelectionChange?.(value)
  });
  const [selectionBehavior, setSelectionBehavior] = createSignal(access(mergedProps.selectionBehavior));
  const selectionMode = () => access(mergedProps.selectionMode);
  const disallowEmptySelection = () => access(mergedProps.disallowEmptySelection) ?? false;
  const setSelectedKeys = keys => {
    if (access(mergedProps.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) {
      _setSelectedKeys(keys);
    }
  };
  createEffect(() => {
    const selection = selectedKeys();
    if (access(mergedProps.selectionBehavior) === "replace" && selectionBehavior() === "toggle" && typeof selection === "object" && selection.size === 0) {
      setSelectionBehavior("replace");
    }
  });
  createEffect(() => {
    setSelectionBehavior(access(mergedProps.selectionBehavior) ?? "toggle");
  });
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    isFocused,
    setFocused,
    focusedKey,
    setFocusedKey,
    selectedKeys,
    setSelectedKeys
  };
}

function createTypeSelect(props) {
  const [search, setSearch] = createSignal("");
  const [timeoutId, setTimeoutId] = createSignal(-1);
  const onKeyDown = e => {
    if (access(props.isDisabled)) {
      return;
    }
    const delegate = access(props.keyboardDelegate);
    const manager = access(props.selectionManager);
    if (!delegate.getKeyForSearch) {
      return;
    }
    const character = getStringForKey(e.key);
    if (!character || e.ctrlKey || e.metaKey) {
      return;
    }
    if (character === " " && search().trim().length > 0) {
      e.preventDefault();
      e.stopPropagation();
    }
    let newSearch = setSearch(prev => prev + character);
    let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    if (key == null && isAllSameLetter(newSearch)) {
      newSearch = newSearch[0];
      key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    }
    if (key != null) {
      manager.setFocusedKey(key);
      props.onTypeSelect?.(key);
    }
    clearTimeout(timeoutId());
    setTimeoutId(window.setTimeout(() => setSearch(""), 500));
  };
  return {
    typeSelectHandlers: {
      onKeyDown
    }
  };
}
function getStringForKey(key) {
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }
  return "";
}
function isAllSameLetter(search) {
  return search.split("").every(letter => letter === search[0]);
}

function createSelectableCollection(props, ref, scrollRef) {
  const defaultProps = {
    selectOnFocus: () => access(props.selectionManager).selectionBehavior() === "replace"
  };
  const mergedProps = mergeProps(defaultProps, props);
  const finalScrollRef = () => scrollRef?.() ?? ref();
  const {
    direction
  } = useLocale();
  let scrollPos = {
    top: 0,
    left: 0
  };
  createEventListener(() => !access(mergedProps.isVirtualized) ? finalScrollRef() : undefined, "scroll", () => {
    const scrollEl = finalScrollRef();
    if (!scrollEl) {
      return;
    }
    scrollPos = {
      top: scrollEl.scrollTop,
      left: scrollEl.scrollLeft
    };
  });
  const {
    typeSelectHandlers
  } = createTypeSelect({
    isDisabled: () => access(mergedProps.disallowTypeAhead),
    keyboardDelegate: () => access(mergedProps.keyboardDelegate),
    selectionManager: () => access(mergedProps.selectionManager)
  });
  const onKeyDown = e => {
    callHandler(e, typeSelectHandlers.onKeyDown);
    if (e.altKey && e.key === "Tab") {
      e.preventDefault();
    }
    const refEl = ref();
    if (!refEl?.contains(e.target)) {
      return;
    }
    const manager = access(mergedProps.selectionManager);
    const selectOnFocus = access(mergedProps.selectOnFocus);
    const navigateToKey = key => {
      if (key != null) {
        manager.setFocusedKey(key);
        if (e.shiftKey && manager.selectionMode() === "multiple") {
          manager.extendSelection(key);
        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {
          manager.replaceSelection(key);
        }
      }
    };
    const delegate = access(mergedProps.keyboardDelegate);
    const shouldFocusWrap = access(mergedProps.shouldFocusWrap);
    const focusedKey = manager.focusedKey();
    switch (e.key) {
      case "ArrowDown":
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyBelow(focusedKey);
            } else {
              nextKey = delegate.getFirstKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowUp":
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyAbove(focusedKey);
            } else {
              nextKey = delegate.getLastKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowLeft":
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyLeftOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowRight":
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyRightOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getLastKey?.() : delegate.getFirstKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "Home":
        if (delegate.getFirstKey) {
          e.preventDefault();
          const firstKey = delegate.getFirstKey(focusedKey, isCtrlKeyPressed(e));
          if (firstKey != null) {
            manager.setFocusedKey(firstKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(firstKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(firstKey);
            }
          }
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e.preventDefault();
          const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));
          if (lastKey != null) {
            manager.setFocusedKey(lastKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(lastKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(lastKey);
            }
          }
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageBelow(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageAbove(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if (isCtrlKeyPressed(e) && manager.selectionMode() === "multiple" && access(mergedProps.disallowSelectAll) !== true) {
          e.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        if (!e.defaultPrevented) {
          e.preventDefault();
          if (!access(mergedProps.disallowEmptySelection)) {
            manager.clearSelection();
          }
        }
        break;
      case "Tab":
        {
          if (!access(mergedProps.allowsTabNavigation)) {
            if (e.shiftKey) {
              refEl.focus();
            } else {
              const walker = getFocusableTreeWalker(refEl, {
                tabbable: true
              });
              let next;
              let last;
              do {
                last = walker.lastChild();
                if (last) {
                  next = last;
                }
              } while (last);
              if (next && !next.contains(document.activeElement)) {
                focusWithoutScrolling(next);
              }
            }
            break;
          }
        }
    }
  };
  const onFocusIn = e => {
    const manager = access(mergedProps.selectionManager);
    const delegate = access(mergedProps.keyboardDelegate);
    const selectOnFocus = access(mergedProps.selectOnFocus);
    if (manager.isFocused()) {
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }
      return;
    }
    if (!e.currentTarget.contains(e.target)) {
      return;
    }
    manager.setFocused(true);
    if (manager.focusedKey() == null) {
      const navigateToFirstKey = key => {
        if (key == null) {
          return;
        }
        manager.setFocusedKey(key);
        if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      };
      const relatedTarget = e.relatedTarget;
      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        navigateToFirstKey(manager.lastSelectedKey() ?? delegate.getLastKey?.());
      } else {
        navigateToFirstKey(manager.firstSelectedKey() ?? delegate.getFirstKey?.());
      }
    } else if (!access(mergedProps.isVirtualized)) {
      const scrollEl = finalScrollRef();
      if (scrollEl) {
        scrollEl.scrollTop = scrollPos.top;
        scrollEl.scrollLeft = scrollPos.left;
        const element = scrollEl.querySelector(`[data-key="${manager.focusedKey()}"]`);
        if (element) {
          focusWithoutScrolling(element);
          scrollIntoView(scrollEl, element);
        }
      }
    }
  };
  const onFocusOut = e => {
    const manager = access(mergedProps.selectionManager);
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };
  const onMouseDown = e => {
    if (finalScrollRef() === e.target) {
      e.preventDefault();
    }
  };
  const tryAutoFocus = () => {
    const autoFocus = access(mergedProps.autoFocus);
    if (!autoFocus) {
      return;
    }
    const manager = access(mergedProps.selectionManager);
    const delegate = access(mergedProps.keyboardDelegate);
    let focusedKey;
    if (autoFocus === "first") {
      focusedKey = delegate.getFirstKey?.();
    }
    if (autoFocus === "last") {
      focusedKey = delegate.getLastKey?.();
    }
    const selectedKeys = manager.selectedKeys();
    if (selectedKeys.size) {
      focusedKey = selectedKeys.values().next().value;
    }
    manager.setFocused(true);
    manager.setFocusedKey(focusedKey);
    const refEl = ref();
    if (refEl && focusedKey == null && !access(mergedProps.shouldUseVirtualFocus)) {
      focusWithoutScrolling(refEl);
    }
  };
  onMount(() => {
    if (mergedProps.deferAutoFocus) {
      setTimeout(tryAutoFocus, 0);
    } else {
      tryAutoFocus();
    }
  });
  createEffect(on([finalScrollRef, () => access(mergedProps.isVirtualized), () => access(mergedProps.selectionManager).focusedKey()], newValue => {
    const [scrollEl, isVirtualized, focusedKey] = newValue;
    if (isVirtualized) {
      focusedKey && mergedProps.scrollToKey?.(focusedKey);
    } else {
      if (focusedKey && scrollEl) {
        const element = scrollEl.querySelector(`[data-key="${focusedKey}"]`);
        if (element) {
          scrollIntoView(scrollEl, element);
        }
      }
    }
  }));
  const tabIndex = createMemo(() => {
    if (access(mergedProps.shouldUseVirtualFocus)) {
      return undefined;
    }
    return access(mergedProps.selectionManager).focusedKey() == null ? 0 : -1;
  });
  return {
    tabIndex,
    onKeyDown,
    onMouseDown,
    onFocusIn,
    onFocusOut
  };
}

function createSelectableItem(props, ref) {
  const manager = () => access(props.selectionManager);
  const key = () => access(props.key);
  const shouldUseVirtualFocus = () => access(props.shouldUseVirtualFocus);
  const onSelect = e => {
    if (manager().selectionMode() === "none") {
      return;
    }
    if (manager().selectionMode() === "single") {
      if (manager().isSelected(key()) && !manager().disallowEmptySelection()) {
        manager().toggleSelection(key());
      } else {
        manager().replaceSelection(key());
      }
    } else if (e?.shiftKey) {
      manager().extendSelection(key());
    } else if (manager().selectionBehavior() === "toggle" || isCtrlKeyPressed(e) || "pointerType" in e && e.pointerType === "touch") {
      manager().toggleSelection(key());
    } else {
      manager().replaceSelection(key());
    }
  };
  const isSelected = () => manager().isSelected(key());
  const isDisabled = () => access(props.disabled) || manager().isDisabled(key());
  const allowsSelection = () => !isDisabled() && manager().canSelectItem(key());
  let pointerDownType = null;
  const onPointerDown = e => {
    if (!allowsSelection()) {
      return;
    }
    pointerDownType = e.pointerType;
    if (e.pointerType === "mouse" && e.button === 0 && !access(props.shouldSelectOnPressUp)) {
      onSelect(e);
    }
  };
  const onPointerUp = e => {
    if (!allowsSelection()) {
      return;
    }
    if (e.pointerType === "mouse" && e.button === 0 && access(props.shouldSelectOnPressUp) && access(props.allowsDifferentPressOrigin)) {
      onSelect(e);
    }
  };
  const onClick = e => {
    if (!allowsSelection()) {
      return;
    }
    if (access(props.shouldSelectOnPressUp) && !access(props.allowsDifferentPressOrigin) || pointerDownType !== "mouse") {
      onSelect(e);
    }
  };
  const onKeyDown = e => {
    if (!allowsSelection() || !["Enter", " "].includes(e.key)) {
      return;
    }
    if (isNonContiguousSelectionModifier(e)) {
      manager().toggleSelection(key());
    } else {
      onSelect(e);
    }
  };
  const onMouseDown = e => {
    if (isDisabled()) {
      e.preventDefault();
    }
  };
  const onFocus = e => {
    const refEl = ref();
    if (shouldUseVirtualFocus() || isDisabled() || !refEl) {
      return;
    }
    if (e.target === refEl) {
      manager().setFocusedKey(key());
    }
  };
  const tabIndex = createMemo(() => {
    if (shouldUseVirtualFocus() || isDisabled()) {
      return undefined;
    }
    return key() === manager().focusedKey() ? 0 : -1;
  });
  const dataKey = createMemo(() => {
    return access(props.virtualized) ? undefined : key();
  });
  createEffect(on([ref, key, shouldUseVirtualFocus, () => manager().focusedKey(), () => manager().isFocused()], ([refEl, key, shouldUseVirtualFocus, focusedKey, isFocused]) => {
    if (refEl && key === focusedKey && isFocused && !shouldUseVirtualFocus && document.activeElement !== refEl) {
      if (props.focus) {
        props.focus();
      } else {
        focusWithoutScrolling(refEl);
      }
    }
  }));
  return {
    isSelected,
    isDisabled,
    allowsSelection,
    tabIndex,
    dataKey,
    onPointerDown,
    onPointerUp,
    onClick,
    onKeyDown,
    onMouseDown,
    onFocus
  };
}

class SelectionManager {
  constructor(collection, state) {
    this.collection = collection;
    this.state = state;
  }
  selectionMode() {
    return this.state.selectionMode();
  }
  disallowEmptySelection() {
    return this.state.disallowEmptySelection();
  }
  selectionBehavior() {
    return this.state.selectionBehavior();
  }
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  isFocused() {
    return this.state.isFocused();
  }
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  focusedKey() {
    return this.state.focusedKey();
  }
  setFocusedKey(key) {
    if (key == null || this.collection().getItem(key)) {
      this.state.setFocusedKey(key);
    }
  }
  selectedKeys() {
    return this.state.selectedKeys();
  }
  isSelected(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return false;
    }
    return this.state.selectedKeys().has(retrievedKey);
  }
  isEmpty() {
    return this.state.selectedKeys().size === 0;
  }
  isSelectAll() {
    if (this.isEmpty()) {
      return false;
    }
    const selectedKeys = this.state.selectedKeys();
    return this.getAllSelectableKeys().every(k => selectedKeys.has(k));
  }
  firstSelectedKey() {
    let first;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;
      if (!first || isItemBeforeFirst) {
        first = item;
      }
    }
    return first?.key;
  }
  lastSelectedKey() {
    let last;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;
      if (!last || isItemAfterLast) {
        last = item;
      }
    }
    return last?.key;
  }
  extendSelection(toKey) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      this.replaceSelection(toKey);
      return;
    }
    const retrievedToKey = this.getKey(toKey);
    if (retrievedToKey == null) {
      return;
    }
    const selectedKeys = this.state.selectedKeys();
    const anchorKey = selectedKeys.anchorKey || retrievedToKey;
    const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);
    for (const key of this.getKeyRange(anchorKey, selectedKeys.currentKey || retrievedToKey)) {
      selection.delete(key);
    }
    for (const key of this.getKeyRange(retrievedToKey, anchorKey)) {
      if (this.canSelectItem(key)) {
        selection.add(key);
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    const fromItem = this.collection().getItem(from);
    const toItem = this.collection().getItem(to);
    if (fromItem && toItem) {
      if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) {
        return this.getKeyRangeInternal(from, to);
      }
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    const keys = [];
    let key = from;
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item") {
        keys.push(key);
      }
      if (key === to) {
        return keys;
      }
      key = this.collection().getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    const item = this.collection().getItem(key);
    if (!item) {
      return key;
    }
    if (!item || item.type !== "item") {
      return null;
    }
    return item.key;
  }
  toggleSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const keys = new Selection(this.state.selectedKeys());
    if (keys.has(retrievedKey)) {
      keys.delete(retrievedKey);
    } else if (this.canSelectItem(retrievedKey)) {
      keys.add(retrievedKey);
      keys.anchorKey = retrievedKey;
      keys.currentKey = retrievedKey;
    }
    if (this.disallowEmptySelection() && keys.size === 0) {
      return;
    }
    this.state.setSelectedKeys(keys);
  }
  replaceSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const selection = this.canSelectItem(retrievedKey) ? new Selection([retrievedKey], retrievedKey, retrievedKey) : new Selection();
    this.state.setSelectedKeys(selection);
  }
  setSelectedKeys(keys) {
    if (this.selectionMode() === "none") {
      return;
    }
    const selection = new Selection();
    for (const key of keys) {
      const retrievedKey = this.getKey(key);
      if (retrievedKey != null) {
        selection.add(retrievedKey);
        if (this.selectionMode() === "single") {
          break;
        }
      }
    }
    this.state.setSelectedKeys(selection);
  }
  selectAll() {
    if (this.selectionMode() === "multiple") {
      this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));
    }
  }
  clearSelection() {
    const selectedKeys = this.state.selectedKeys();
    if (!this.disallowEmptySelection() && selectedKeys.size > 0) {
      this.state.setSelectedKeys(new Selection());
    }
  }
  toggleSelectAll() {
    if (this.isSelectAll()) {
      this.clearSelection();
    } else {
      this.selectAll();
    }
  }
  select(key, e) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection()) {
        this.toggleSelection(key);
      } else {
        this.replaceSelection(key);
      }
    } else if (this.selectionBehavior() === "toggle" || e && e.pointerType === "touch") {
      this.toggleSelection(key);
    } else {
      this.replaceSelection(key);
    }
  }
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys()) {
      return true;
    }
    const selectedKeys = this.selectedKeys();
    if (selection.size !== selectedKeys.size) {
      return false;
    }
    for (const key of selection) {
      if (!selectedKeys.has(key)) {
        return false;
      }
    }
    for (const key of selectedKeys) {
      if (!selection.has(key)) {
        return false;
      }
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const item = this.collection().getItem(key);
    return item != null && !item.disabled;
  }
  isDisabled(key) {
    const item = this.collection().getItem(key);
    return !item || item.disabled;
  }
  getAllSelectableKeys() {
    const keys = [];
    const addKeys = key => {
      while (key != null) {
        if (this.canSelectItem(key)) {
          const item = this.collection().getItem(key);
          if (!item) {
            continue;
          }
          if (item.type === "item") {
            keys.push(key);
          }
        }
        key = this.collection().getKeyAfter(key);
      }
    };
    addKeys(this.collection().getFirstKey());
    return keys;
  }
}

class ListCollection {
  keyMap = new Map();
  constructor(nodes) {
    this.iterable = nodes;
    for (const node of nodes) {
      this.keyMap.set(node.key, node);
    }
    if (this.keyMap.size === 0) {
      return;
    }
    let last;
    let index = 0;
    for (const [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = undefined;
      }
      if (node.type === "item") {
        node.index = index++;
      }
      last = node;
      last.nextKey = undefined;
    }
    this.lastKey = last.key;
  }
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  getSize() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    return this.keyMap.get(key)?.prevKey;
  }
  getKeyAfter(key) {
    return this.keyMap.get(key)?.nextKey;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }
}

function createListState(props) {
  const selectionState = createMultipleSelectionState(props);
  const factory = nodes => {
    return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);
  };
  const collection = createCollection({
    dataSource: () => access(props.dataSource),
    getKey: () => access(props.getKey),
    getTextValue: () => access(props.getTextValue),
    getDisabled: () => access(props.getDisabled),
    getSectionChildren: () => access(props.getSectionChildren),
    factory
  }, [() => props.filter]);
  const selectionManager = new SelectionManager(collection, selectionState);
  createComputed(() => {
    const focusedKey = selectionState.focusedKey();
    if (focusedKey != null && !collection().getItem(focusedKey)) {
      selectionState.setFocusedKey(undefined);
    }
  });
  return {
    collection,
    selectionManager: () => selectionManager
  };
}

class ListKeyboardDelegate {
  constructor(collection, ref, collator) {
    this.collection = collection;
    this.ref = ref;
    this.collator = collator;
  }
  getKeyBelow(key) {
    let keyAfter = this.collection().getKeyAfter(key);
    while (keyAfter != null) {
      const item = this.collection().getItem(keyAfter);
      if (item && item.type === "item" && !item.disabled) {
        return keyAfter;
      }
      keyAfter = this.collection().getKeyAfter(keyAfter);
    }
  }
  getKeyAbove(key) {
    let keyBefore = this.collection().getKeyBefore(key);
    while (keyBefore != null) {
      const item = this.collection().getItem(keyBefore);
      if (item && item.type === "item" && !item.disabled) {
        return keyBefore;
      }
      keyBefore = this.collection().getKeyBefore(keyBefore);
    }
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyAfter(key);
    }
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyBefore(key);
    }
  }
  getItem(key) {
    return this.ref?.()?.querySelector(`[data-key="${key}"]`) ?? null;
  }
  getKeyPageAbove(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);
    let keyAbove = key;
    while (keyAbove && item && item.offsetTop > pageY) {
      keyAbove = this.getKeyAbove(keyAbove);
      item = keyAbove != null ? this.getItem(keyAbove) : null;
    }
    return keyAbove;
  }
  getKeyPageBelow(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);
    let keyBelow = key;
    while (keyBelow && item && item.offsetTop < pageY) {
      keyBelow = this.getKeyBelow(keyBelow);
      item = keyBelow != null ? this.getItem(keyBelow) : null;
    }
    return keyBelow;
  }
  getKeyForSearch(search, fromKey) {
    const collator = this.collator?.();
    if (!collator) {
      return;
    }
    let key = fromKey != null ? this.getKeyBelow(fromKey) : this.getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item) {
        const substring = item.textValue.slice(0, search.length);
        if (item.textValue && collator.compare(substring, search) === 0) {
          return key;
        }
      }
      key = this.getKeyBelow(key);
    }
  }
}

function createSelectableList(props, ref, scrollRef) {
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });
  const delegate = createMemo(() => {
    const keyboardDelegate = access(props.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(props.collection, ref, collator);
  });
  return createSelectableCollection({
    selectionManager: () => access(props.selectionManager),
    keyboardDelegate: delegate,
    autoFocus: () => access(props.autoFocus),
    deferAutoFocus: () => access(props.deferAutoFocus),
    shouldFocusWrap: () => access(props.shouldFocusWrap),
    disallowEmptySelection: () => access(props.disallowEmptySelection),
    selectOnFocus: () => access(props.selectOnFocus),
    disallowTypeAhead: () => access(props.disallowTypeAhead),
    shouldUseVirtualFocus: () => access(props.shouldUseVirtualFocus),
    allowsTabNavigation: () => access(props.allowsTabNavigation),
    isVirtualized: () => access(props.isVirtualized),
    scrollToKey: key => access(props.scrollToKey)?.(key)
  }, ref, scrollRef);
}

function createSingleSelectListState(props) {
  const [selectedKey, setSelectedKey] = createControllableSignal({
    value: () => access(props.selectedKey),
    defaultValue: () => access(props.defaultSelectedKey),
    onChange: value => props.onSelectionChange?.(value)
  });
  const selectedKeys = createMemo(() => {
    const selection = selectedKey();
    return selection != null ? [selection] : [];
  });
  const [, defaultCreateListStateProps] = splitProps(props, ["onSelectionChange"]);
  const createListStateProps = mergeProps(defaultCreateListStateProps, {
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: keys => {
      const key = keys.values().next().value;
      if (key === selectedKey()) {
        props.onSelectionChange?.(key);
      }
      setSelectedKey(key);
    }
  });
  const {
    collection,
    selectionManager
  } = createListState(createListStateProps);
  const selectedItem = createMemo(() => {
    const selection = selectedKey();
    return selection != null ? collection().getItem(selection) : undefined;
  });
  return {
    collection,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

const [state, setState] = createStore({
  toasts: []
});
function add(toast) {
  setState("toasts", prev => [...prev, toast]);
}
function get(id) {
  return state.toasts.find(toast => toast.id === id);
}
function update$1(id, toast) {
  const index = state.toasts.findIndex(toast => toast.id === id);
  if (index !== -1) {
    setState("toasts", prev => [...prev.slice(0, index), toast, ...prev.slice(index + 1)]);
  }
}
function dismiss$1(id) {
  setState("toasts", toast => toast.id === id, "dismiss", true);
}
function remove(id) {
  setState("toasts", prev => prev.filter(toast => toast.id !== id));
}
function clear$1() {
  setState("toasts", []);
}
const toastStore = {
  toasts: () => state.toasts,
  add,
  get,
  update: update$1,
  dismiss: dismiss$1,
  remove,
  clear: clear$1
};

let toastsCounter = 0;
function show(toastComponent, options) {
  const id = toastsCounter++;
  toastStore.add({
    id,
    toastComponent,
    dismiss: false,
    update: false,
    region: options?.region
  });
  return id;
}
function update(id, toastComponent) {
  toastStore.update(id, {
    id,
    toastComponent,
    dismiss: false,
    update: true
  });
}
function promise(promise, toastComponent, options) {
  const id = show(props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "pending"
    });
  }, options);
  (isFunction(promise) ? promise() : promise).then(data => update(id, props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "fulfilled",
      data
    });
  })).catch(error => update(id, props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "rejected",
      error
    });
  }));
  return id;
}
function dismiss(id) {
  toastStore.dismiss(id);
  return id;
}
function clear() {
  toastStore.clear();
}
const toaster = {
  show,
  update,
  promise,
  dismiss,
  clear
};

const CollapsibleContext = createContext();
function useCollapsibleContext() {
  const context = useContext(CollapsibleContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCollapsibleContext` must be used within a `Collapsible.Root` component");
  }
  return context;
}

function CollapsibleContent(props) {
  let ref;
  const context = useCollapsibleContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "style"]);
  const presence = createPresence(() => context.shouldMount());
  const [height, setHeight] = createSignal(0);
  const [width, setWidth] = createSignal(0);
  const isOpen = () => context.isOpen() || presence.isPresent();
  let isMountAnimationPrevented = isOpen();
  let originalStyles;
  onMount(() => {
    const raf = requestAnimationFrame(() => {
      isMountAnimationPrevented = false;
    });
    onCleanup(() => {
      cancelAnimationFrame(raf);
    });
  });
  createEffect(on([() => presence.isPresent()], () => {
    if (!ref) {
      return;
    }
    originalStyles = originalStyles || {
      transitionDuration: ref.style.transitionDuration,
      animationName: ref.style.animationName
    };
    ref.style.transitionDuration = "0s";
    ref.style.animationName = "none";
    const rect = ref.getBoundingClientRect();
    setHeight(rect.height);
    setWidth(rect.width);
    if (!isMountAnimationPrevented) {
      ref.style.transitionDuration = originalStyles.transitionDuration;
      ref.style.animationName = originalStyles.animationName;
    }
  }));
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  return createComponent(Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(el => {
            presence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return local.id;
        },
        get style() {
          return {
            "--kb-collapsible-content-height": height() ? `${height()}px` : undefined,
            "--kb-collapsible-content-width": width() ? `${width()}px` : undefined,
            ...local.style
          };
        }
      }, () => context.dataset(), others));
    }
  });
}

function CollapsibleRoot(props) {
  const defaultId = `collapsible-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["open", "defaultOpen", "onOpenChange", "disabled", "forceMount"]);
  const [contentId, setContentId] = createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined,
    "data-disabled": local.disabled ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    disabled: () => local.disabled ?? false,
    shouldMount: () => local.forceMount || disclosureState.isOpen(),
    contentId,
    toggle: disclosureState.toggle,
    generateId: createGenerateId(() => others.id),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(CollapsibleContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div"
      }, dataset, others));
    }
  });
}

const BUTTON_INPUT_TYPES = ["button", "color", "file", "image", "reset", "submit"];
function isButton(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName === "button") {
    return true;
  }
  if (tagName === "input" && element.type) {
    return BUTTON_INPUT_TYPES.indexOf(element.type) !== -1;
  }
  return false;
}

function ButtonRoot(props) {
  let ref;
  const mergedProps = mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "type", "disabled"]);
  const tagName = createTagName(() => ref, () => "button");
  const isNativeButton = createMemo(() => {
    const elementTagName = tagName();
    if (elementTagName == null) {
      return false;
    }
    return isButton({
      tagName: elementTagName,
      type: local.type
    });
  });
  const isNativeInput = createMemo(() => {
    return tagName() === "input";
  });
  const isNativeLink = createMemo(() => {
    return tagName() === "a" && ref?.getAttribute("href") != null;
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "button",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get type() {
      return isNativeButton() || isNativeInput() ? local.type : undefined;
    },
    get role() {
      return !isNativeButton() && !isNativeLink() ? "button" : undefined;
    },
    get tabIndex() {
      return !isNativeButton() && !isNativeLink() && !local.disabled ? 0 : undefined;
    },
    get disabled() {
      return isNativeButton() || isNativeInput() ? local.disabled : undefined;
    },
    get ["aria-disabled"]() {
      return !isNativeButton() && !isNativeInput() && local.disabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    }
  }, others));
}

var index$w = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: ButtonRoot
});

function CollapsibleTrigger(props) {
  const context = useCollapsibleContext();
  const [local, others] = splitProps(props, ["onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get disabled() {
      return context.disabled();
    },
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$v = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Content: CollapsibleContent,
	Root: CollapsibleRoot,
	Trigger: CollapsibleTrigger
});

const AccordionItemContext = createContext();
function useAccordionItemContext() {
  const context = useContext(AccordionItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionItemContext` must be used within a `Accordion.Item` component");
  }
  return context;
}

function AccordionContent(props) {
  const itemContext = useAccordionItemContext();
  const defaultId = itemContext.generateId("content");
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["style"]);
  createEffect(() => onCleanup(itemContext.registerContentId(others.id)));
  return createComponent(CollapsibleContent, mergeProps$1({
    role: "region",
    get ["aria-labelledby"]() {
      return itemContext.triggerId();
    },
    get style() {
      return {
        "--kb-accordion-content-height": "var(--kb-collapsible-content-height)",
        "--kb-accordion-content-width": "var(--kb-collapsible-content-width)",
        ...local.style
      };
    }
  }, others));
}

function AccordionHeader(props) {
  const context = useCollapsibleContext();
  return createComponent(Polymorphic, mergeProps$1({
    as: "h3"
  }, () => context.dataset(), props));
}

const AccordionContext = createContext();
function useAccordionContext() {
  const context = useContext(AccordionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionContext` must be used within a `Accordion.Root` component");
  }
  return context;
}

function AccordionItem(props) {
  const accordionContext = useAccordionContext();
  const defaultId = `${accordionContext.generateId("item")}-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "disabled"]);
  const [triggerId, setTriggerId] = createSignal();
  const [contentId, setContentId] = createSignal();
  const selectionManager = () => accordionContext.listState().selectionManager();
  const isExpanded = () => {
    return selectionManager().isSelected(local.value);
  };
  const context = {
    value: () => local.value,
    triggerId,
    contentId,
    generateId: createGenerateId(() => others.id),
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(AccordionItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(CollapsibleRoot, mergeProps$1({
        get open() {
          return isExpanded();
        },
        get disabled() {
          return local.disabled;
        }
      }, others));
    }
  });
}

const DomCollectionContext = createContext();
function useOptionalDomCollectionContext() {
  return useContext(DomCollectionContext);
}
function useDomCollectionContext() {
  const context = useOptionalDomCollectionContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useDomCollectionContext` must be used within a `DomCollectionProvider` component");
  }
  return context;
}

function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
  const itemEl = item.ref();
  if (!itemEl) {
    return -1;
  }
  let length = items.length;
  if (!length) {
    return -1;
  }
  while (length--) {
    const currentItemEl = items[length]?.ref();
    if (!currentItemEl) {
      continue;
    }
    if (isElementPreceding(currentItemEl, itemEl)) {
      return length + 1;
    }
  }
  return 0;
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.ref();
    const elementB = b.ref();
    if (elementA === elementB) {
      return 0;
    }
    if (!elementA || !elementB) {
      return 0;
    }
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
  const sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
function getCommonParent(items) {
  const firstItem = items[0];
  const lastItemEl = items[items.length - 1]?.ref();
  let parentEl = firstItem?.ref()?.parentElement;
  while (parentEl) {
    if (lastItemEl && parentEl.contains(lastItemEl)) {
      return parentEl;
    }
    parentEl = parentEl.parentElement;
  }
  return getDocument(parentEl).body;
}
function createTimeoutObserver(items, setItems) {
  createEffect(() => {
    const timeout = setTimeout(() => {
      setItemsBasedOnDOMPosition(items(), setItems);
    });
    onCleanup(() => clearTimeout(timeout));
  });
}
function createSortBasedOnDOMPosition(items, setItems) {
  if (typeof IntersectionObserver !== "function") {
    createTimeoutObserver(items, setItems);
    return;
  }
  let previousItems = [];
  createEffect(() => {
    const callback = () => {
      const hasPreviousItems = !!previousItems.length;
      previousItems = items();
      if (!hasPreviousItems) {
        return;
      }
      setItemsBasedOnDOMPosition(items(), setItems);
    };
    const root = getCommonParent(items());
    const observer = new IntersectionObserver(callback, {
      root
    });
    for (const item of items()) {
      const itemEl = item.ref();
      if (itemEl) {
        observer.observe(itemEl);
      }
    }
    onCleanup(() => observer.disconnect());
  });
}

function createDomCollection(props = {}) {
  const [items, setItems] = createControllableArraySignal({
    value: () => access(props.items),
    onChange: value => props.onItemsChange?.(value)
  });
  createSortBasedOnDOMPosition(items, setItems);
  const registerItem = item => {
    setItems(prevItems => {
      const index = findDOMIndex(prevItems, item);
      return addItemToArray(prevItems, item, index);
    });
    return () => {
      setItems(prevItems => {
        const nextItems = prevItems.filter(prevItem => prevItem.ref() !== item.ref());
        if (prevItems.length === nextItems.length) {
          return prevItems;
        }
        return nextItems;
      });
    };
  };
  const DomCollectionProvider = props => {
    return createComponent$1(DomCollectionContext.Provider, {
      value: {
        registerItem
      },
      get children() {
        return props.children;
      }
    });
  };
  return {
    DomCollectionProvider
  };
}

function createDomCollectionItem(props) {
  const context = useDomCollectionContext();
  const mergedProps = mergeDefaultProps({
    shouldRegisterItem: true
  }, props);
  createEffect(() => {
    if (!mergedProps.shouldRegisterItem) {
      return;
    }
    const unregister = context.registerItem(mergedProps.getItem());
    onCleanup(unregister);
  });
}

function AccordionRoot(props) {
  let ref;
  const defaultId = `accordion-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    multiple: false,
    collapsible: false,
    shouldFocusWrap: true
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "multiple", "collapsible", "shouldFocusWrap", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const [items, setItems] = createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createListState({
    selectedKeys: () => local.value,
    defaultSelectedKeys: () => local.defaultValue,
    onSelectionChange: value => local.onChange?.(Array.from(value)),
    disallowEmptySelection: () => !local.multiple && !local.collapsible,
    selectionMode: () => local.multiple ? "multiple" : "single",
    dataSource: items
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState.selectionManager(),
    collection: () => listState.collection(),
    disallowEmptySelection: () => listState.selectionManager().disallowEmptySelection(),
    shouldFocusWrap: () => local.shouldFocusWrap,
    disallowTypeAhead: true,
    allowsTabNavigation: true
  }, () => ref);
  const context = {
    listState: () => listState,
    generateId: createGenerateId(() => others.id)
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(AccordionContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get onKeyDown() {
              return composeEventHandlers([local.onKeyDown, selectableList.onKeyDown]);
            },
            get onMouseDown() {
              return composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
            },
            get onFocusIn() {
              return composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
            },
            get onFocusOut() {
              return composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
            }
          }, others));
        }
      });
    }
  });
}

function AccordionTrigger(props) {
  let ref;
  const accordionContext = useAccordionContext();
  const itemContext = useAccordionItemContext();
  const collapsibleContext = useCollapsibleContext();
  const defaultId = itemContext.generateId("trigger");
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: itemContext.value(),
      textValue: "",
      disabled: collapsibleContext.disabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => itemContext.value(),
    selectionManager: () => accordionContext.listState().selectionManager(),
    disabled: () => collapsibleContext.disabled(),
    shouldSelectOnPressUp: true
  }, () => ref);
  const onKeyDown = e => {
    if (["Enter", " "].includes(e.key)) {
      e.preventDefault();
    }
    callHandler(e, local.onKeyDown);
    callHandler(e, selectableItem.onKeyDown);
  };
  createEffect(() => onCleanup(itemContext.registerTriggerId(others.id)));
  return createComponent(CollapsibleTrigger, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get onPointerDown() {
      return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return composeEventHandlers([local.onClick, selectableItem.onClick]);
    },
    onKeyDown: onKeyDown,
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    }
  }, others));
}

var index$u = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Content: AccordionContent,
	Header: AccordionHeader,
	Item: AccordionItem,
	Root: AccordionRoot,
	Trigger: AccordionTrigger
});

function AlertRoot(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    role: "alert"
  }, props));
}

var index$t = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: AlertRoot
});

const DialogContext = createContext();
function useDialogContext() {
  const context = useContext(DialogContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDialogContext` must be used within a `Dialog` component");
  }
  return context;
}

function DialogCloseButton(props) {
  const context = useDialogContext();
  const [local, others] = splitProps(props, ["aria-label", "onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.close();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-label"]() {
      return local["aria-label"] || context.translations().dismiss;
    },
    onClick: onClick
  }, others));
}

const DismissableLayerContext = createContext();
function useOptionalDismissableLayerContext() {
  return useContext(DismissableLayerContext);
}

function DismissableLayer(props) {
  let ref;
  const parentContext = useOptionalDismissableLayerContext();
  const [local, others] = splitProps(props, ["ref", "disableOutsidePointerEvents", "excludedElements", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "bypassTopMostLayerCheck"]);
  const nestedLayers = new Set([]);
  const registerNestedLayer = element => {
    nestedLayers.add(element);
    const parentUnregister = parentContext?.registerNestedLayer(element);
    return () => {
      nestedLayers.delete(element);
      parentUnregister?.();
    };
  };
  const shouldExcludeElement = element => {
    if (!ref) {
      return false;
    }
    return local.excludedElements?.some(node => contains(node(), element)) || [...nestedLayers].some(layer => contains(layer, element));
  };
  const onPointerDownOutside = e => {
    if (!ref || layerStack.isBelowPointerBlockingLayer(ref)) {
      return;
    }
    if (!local.bypassTopMostLayerCheck && !layerStack.isTopMostLayer(ref)) {
      return;
    }
    local.onPointerDownOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  createInteractOutside({
    shouldExcludeElement,
    onPointerDownOutside,
    onFocusOutside
  }, () => ref);
  createEscapeKeyDown({
    ownerDocument: () => getDocument(ref),
    onEscapeKeyDown: e => {
      if (!ref || !layerStack.isTopMostLayer(ref)) {
        return;
      }
      local.onEscapeKeyDown?.(e);
      if (!e.defaultPrevented && local.onDismiss) {
        e.preventDefault();
        local.onDismiss();
      }
    }
  });
  onMount(() => {
    if (!ref) {
      return;
    }
    layerStack.addLayer({
      node: ref,
      isPointerBlocking: local.disableOutsidePointerEvents,
      dismiss: local.onDismiss
    });
    const unregisterFromParentLayer = parentContext?.registerNestedLayer(ref);
    layerStack.assignPointerEventToLayers();
    layerStack.disableBodyPointerEvents(ref);
    onCleanup(() => {
      if (!ref) {
        return;
      }
      layerStack.removeLayer(ref);
      unregisterFromParentLayer?.();
      layerStack.assignPointerEventToLayers();
      layerStack.restoreBodyPointerEvents(ref);
    });
  });
  createEffect(on([() => ref, () => local.disableOutsidePointerEvents], ([ref, disableOutsidePointerEvents]) => {
    if (!ref) {
      return;
    }
    const layer = layerStack.find(ref);
    if (layer && layer.isPointerBlocking !== disableOutsidePointerEvents) {
      layer.isPointerBlocking = disableOutsidePointerEvents;
      layerStack.assignPointerEventToLayers();
    }
    if (disableOutsidePointerEvents) {
      layerStack.disableBodyPointerEvents(ref);
    }
    onCleanup(() => {
      layerStack.restoreBodyPointerEvents(ref);
    });
  }, {
    defer: true
  }));
  const context = {
    registerNestedLayer
  };
  return createComponent(DismissableLayerContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others));
    }
  });
}

function DialogContent(props) {
  let ref;
  const context = useDialogContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.modal() && e.detail.isContextMenu) {
      e.preventDefault();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.modal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.modal()) {
      return;
    }
    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }
    if (contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.modal()) {
      e.preventDefault();
      focusWithoutScrolling(context.triggerRef());
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          focusWithoutScrolling(context.triggerRef());
        }
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.modal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.modal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  createEffect(() => onCleanup(context.registerContentId(others.id)));
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(DismissableLayer, mergeProps$1({
        ref(r$) {
          const _ref$ = mergeRefs(el => {
            context.contentPresence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "dialog",
        tabIndex: -1,
        get disableOutsidePointerEvents() {
          return memo(() => !!context.modal())() && context.isOpen();
        },
        get excludedElements() {
          return [context.triggerRef];
        },
        get ["aria-labelledby"]() {
          return context.titleId();
        },
        get ["aria-describedby"]() {
          return context.descriptionId();
        },
        get ["data-expanded"]() {
          return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"]() {
          return !context.isOpen() ? "" : undefined;
        },
        onPointerDownOutside: onPointerDownOutside,
        onFocusOutside: onFocusOutside,
        onInteractOutside: onInteractOutside,
        get onDismiss() {
          return context.close;
        }
      }, others));
    }
  });
}

function DialogDescription(props) {
  const context = useDialogContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "p",
    get id() {
      return local.id;
    }
  }, others));
}

function DialogOverlay(props) {
  const context = useDialogContext();
  const [local, others] = splitProps(props, ["ref", "style", "onPointerDown"]);
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };
  return createComponent(Show, {
    get when() {
      return context.overlayPresence.isPresent();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(context.overlayPresence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get style() {
          return {
            "pointer-events": "auto",
            ...local.style
          };
        },
        get ["data-expanded"]() {
          return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"]() {
          return !context.isOpen() ? "" : undefined;
        },
        onPointerDown: onPointerDown
      }, others));
    }
  });
}

function DialogPortal(props) {
  const context = useDialogContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent() || context.overlayPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

const DIALOG_INTL_TRANSLATIONS = {
  dismiss: "Dismiss"
};

function DialogRoot(props) {
  const defaultId = `dialog-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    modal: true,
    translations: DIALOG_INTL_TRANSLATIONS
  }, props);
  const [contentId, setContentId] = createSignal();
  const [titleId, setTitleId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const disclosureState = createDisclosureState({
    open: () => mergedProps.open,
    defaultOpen: () => mergedProps.defaultOpen,
    onOpenChange: isOpen => mergedProps.onOpenChange?.(isOpen)
  });
  const shouldMount = () => mergedProps.forceMount || disclosureState.isOpen();
  const overlayPresence = createPresence(shouldMount);
  const contentPresence = createPresence(shouldMount);
  const context = {
    translations: () => mergedProps.translations ?? DIALOG_INTL_TRANSLATIONS,
    isOpen: disclosureState.isOpen,
    modal: () => mergedProps.modal ?? true,
    preventScroll: () => mergedProps.preventScroll ?? context.modal(),
    contentId,
    titleId,
    descriptionId,
    triggerRef,
    overlayPresence,
    contentPresence,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    setTriggerRef,
    generateId: createGenerateId(() => mergedProps.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(DialogContext.Provider, {
    value: context,
    get children() {
      return mergedProps.children;
    }
  });
}

function DialogTitle(props) {
  const context = useDialogContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerTitleId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "h2",
    get id() {
      return local.id;
    }
  }, others));
}

function DialogTrigger(props) {
  const context = useDialogContext();
  const [local, others] = splitProps(props, ["ref", "onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    get ["data-closed"]() {
      return !context.isOpen() ? "" : undefined;
    },
    onClick: onClick
  }, others));
}

var index$s = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CloseButton: DialogCloseButton,
	Content: DialogContent,
	Description: DialogDescription,
	Overlay: DialogOverlay,
	Portal: DialogPortal,
	Root: DialogRoot,
	Title: DialogTitle,
	Trigger: DialogTrigger
});

function AlertDialogContent(props) {
  return createComponent(DialogContent, mergeProps$1({
    role: "alertdialog"
  }, props));
}

var index$r = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CloseButton: DialogCloseButton,
	Content: AlertDialogContent,
	Description: DialogDescription,
	Overlay: DialogOverlay,
	Portal: DialogPortal,
	Root: DialogRoot,
	Title: DialogTitle,
	Trigger: DialogTrigger
});

function LinkRoot(props) {
  let ref;
  const [local, others] = splitProps(props, ["ref", "type", "href", "disabled"]);
  const tagName = createTagName(() => ref, () => "a");
  return createComponent(Polymorphic, mergeProps$1({
    as: "a",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "a" || local.disabled ? "link" : undefined;
    },
    get tabIndex() {
      return tagName() !== "a" && !local.disabled ? 0 : undefined;
    },
    get href() {
      return !local.disabled ? local.href : undefined;
    },
    get ["aria-disabled"]() {
      return local.disabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    }
  }, others));
}

var index$q = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: LinkRoot
});

function BreadcrumbsLink(props) {
  const [local, others] = splitProps(props, ["current", "disabled", "aria-current"]);
  const ariaCurrent = () => {
    if (!local.current) {
      return undefined;
    }
    return local["aria-current"] || "page";
  };
  return createComponent(LinkRoot, mergeProps$1({
    get disabled() {
      return local.disabled || local.current;
    },
    get ["aria-current"]() {
      return ariaCurrent();
    },
    get ["data-current"]() {
      return local.current ? "" : undefined;
    }
  }, others));
}

const BreadcrumbsContext = createContext();
function useBreadcrumbsContext() {
  const context = useContext(BreadcrumbsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useBreadcrumbsContext` must be used within a `Breadcrumbs.Root` component");
  }
  return context;
}

const BREADCRUMBS_INTL_TRANSLATIONS = {
  breadcrumbs: "Breadcrumbs"
};

function BreadcrumbsRoot(props) {
  const mergedProps = mergeDefaultProps({
    separator: "/",
    translations: BREADCRUMBS_INTL_TRANSLATIONS
  }, props);
  const [local, others] = splitProps(mergedProps, ["separator", "translations"]);
  const context = {
    separator: () => local.separator
  };
  return createComponent(BreadcrumbsContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "nav",
        get ["aria-label"]() {
          return local.translations?.breadcrumbs;
        }
      }, others));
    }
  });
}

function BreadcrumbsSeparator(props) {
  const context = useBreadcrumbsContext();
  return createComponent(Polymorphic, mergeProps$1({
    as: "span",
    get children() {
      return context.separator();
    },
    "aria-hidden": "true"
  }, props));
}

var index$p = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Link: BreadcrumbsLink,
	Root: BreadcrumbsRoot,
	Separator: BreadcrumbsSeparator
});

function CalendarBody(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "div"
  }, props));
}

const CalendarContext = createContext();
function useCalendarContext() {
  const context = useContext(CalendarContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarContext` must be used within a `Calendar` component");
  }
  return context;
}

const CalendarGridContext = createContext();
function useCalendarGridContext() {
  const context = useContext(CalendarGridContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarGridContext` must be used within a `Calendar.Grid` component");
  }
  return context;
}

function constrainStart(date, aligned, duration, locale, min, max) {
  let computedDate = aligned;
  if (min && date.compare(min) >= 0) {
    computedDate = maxDate(computedDate, alignStart(toCalendarDate(min), duration, locale));
  }
  if (max && date.compare(max) <= 0) {
    computedDate = minDate(computedDate, alignEnd(toCalendarDate(max), duration, locale));
  }
  return computedDate;
}
function constrainValue(date, min, max) {
  let computedDate = date;
  if (min) {
    computedDate = maxDate(computedDate, toCalendarDate(min));
  }
  if (max) {
    computedDate = minDate(computedDate, toCalendarDate(max));
  }
  return computedDate;
}
function alignStart(date, duration, locale, min, max) {
  let aligned = date;
  if (duration.years) {
    aligned = startOfYear(date);
  } else if (duration.months) {
    aligned = startOfMonth(date);
  } else if (duration.weeks) {
    aligned = startOfWeek(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignCenter(date, duration, locale, min, max) {
  const halfDuration = {};
  for (const key in duration) {
    halfDuration[key] = Math.floor(duration[key] / 2);
    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignEnd(date, duration, locale, min, max) {
  const d = {
    ...duration
  };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  const aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignDate(date, alignment, duration, locale, min, max) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min, max);
    case "end":
      return alignEnd(date, duration, locale, min, max);
    default:
      return alignCenter(date, duration, locale, min, max);
  }
}
function isDateInvalid(date, minValue, maxValue) {
  return date != null && (minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0);
}
function isPreviousVisibleRangeInvalid(startDate, min, max) {
  const prevDate = startDate.subtract({
    days: 1
  });
  return isSameDay(prevDate, startDate) || isDateInvalid(prevDate, min, max);
}
function isNextVisibleRangeInvalid(endDate, min, max) {
  const nextDate = endDate.add({
    days: 1
  });
  return isSameDay(nextDate, endDate) || isDateInvalid(nextDate, min, max);
}
function getEndDate(startDate, duration) {
  const d = {
    ...duration
  };
  if (d.days) {
    d.days--;
  } else {
    d.days = -1;
  }
  return startDate.add(d);
}
function getAdjustedDateFn(visibleDuration, locale, min, max) {
  return function getDate(options) {
    const {
      startDate,
      focusedDate
    } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, min, max)) {
      return {
        startDate,
        endDate,
        focusedDate: constrainValue(focusedDate, min, max)
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, min, max),
        endDate,
        focusedDate: constrainValue(focusedDate, min, max)
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, min, max),
        endDate,
        focusedDate: constrainValue(focusedDate, min, max)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, min, max)
    };
  };
}
function getUnitDuration(duration) {
  const unit = {
    ...duration
  };
  for (const key in unit) {
    unit[key] = 1;
  }
  return unit;
}
function getNextUnavailableDate(anchorDate, start, end, isDateUnavailableFn, dir) {
  let nextDate = anchorDate.add({
    days: dir
  });
  while ((dir < 0 ? nextDate.compare(start) >= 0 : nextDate.compare(end) <= 0) && !isDateUnavailableFn(nextDate)) {
    nextDate = nextDate.add({
      days: dir
    });
  }
  if (isDateUnavailableFn(nextDate)) {
    return nextDate.add({
      days: -dir
    });
  }
  return undefined;
}
function getPreviousAvailableDate(date, min, isDateUnavailable) {
  if (!isDateUnavailable) {
    return date;
  }
  while (date.compare(min) >= 0 && isDateUnavailable(date)) {
    date = date.subtract({
      days: 1
    });
  }
  if (date.compare(min) >= 0) {
    return date;
  }
}
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : undefined;
}
function getFirstValueOfSelection(selectionMode, value) {
  let firstValue;
  if (selectionMode === "single") {
    firstValue = asSingleValue(value);
  } else if (selectionMode === "multiple") {
    firstValue = asArrayValue(value)?.[0];
  } else if (selectionMode === "range") {
    const {
      start
    } = asRangeValue(value) ?? {};
    firstValue = start;
  }
  return firstValue;
}
function getArrayValueOfSelection(selectionMode, value) {
  let values = [];
  if (selectionMode === "single") {
    values = [asSingleValue(value)];
  } else if (selectionMode === "multiple") {
    values = asArrayValue(value) ?? [];
  } else if (selectionMode === "range") {
    const {
      start,
      end
    } = asRangeValue(value) ?? {};
    values = [start, end];
  }
  return values.filter(Boolean);
}
function formatRange(dateFormatter, translations, start, end, timeZone) {
  const parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let startValue = "";
  let endValue = "";
  for (let i = 0; i < parts.length; i++) {
    if (i < separatorIndex) {
      startValue += parts[i].value;
    } else if (i > separatorIndex) {
      endValue += parts[i].value;
    }
  }
  return translations.dateRange(startValue, endValue);
}
function getSelectedDateDescription(translations, value, timeZone) {
  const dateFormatter = createDateFormatter(() => ({
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(value),
    timeZone: timeZone
  }));
  return translations.selectedDateDescription(dateFormatter().format(value.toDate(timeZone)));
}
function getSelectedDateRangeDescription(translations, highlightedRange, anchorDate, timeZone) {
  const start = highlightedRange.start;
  const end = highlightedRange.end;
  if (!anchorDate && start && end) {
    const dateFormatter = createDateFormatter(() => ({
      weekday: "long",
      month: "long",
      year: "numeric",
      day: "numeric",
      era: getEraFormat(start) || getEraFormat(end),
      timeZone: timeZone
    }));
    if (isSameDay(start, end)) {
      const date = dateFormatter().format(start.toDate(timeZone));
      return translations.selectedDateDescription(date);
    }
    const dateRange = formatRange(dateFormatter(), translations, start, end, timeZone);
    return translations.selectedRangeDescription(dateRange);
  }
  return "";
}
function getVisibleRangeDescription(translations, startDate, endDate, timeZone, isAria) {
  const era = getEraFormat(startDate) || getEraFormat(endDate);
  const monthFormatter = createDateFormatter(() => ({
    month: "long",
    year: "numeric",
    era,
    calendar: startDate.calendar.identifier,
    timeZone
  }));
  const dateFormatter = createDateFormatter(() => ({
    month: "long",
    year: "numeric",
    day: "numeric",
    era,
    calendar: startDate.calendar.identifier,
    timeZone
  }));
  if (isSameDay(startDate, startOfMonth(startDate))) {
    if (isSameDay(endDate, endOfMonth(startDate))) {
      return monthFormatter().format(startDate.toDate(timeZone));
    }
    if (isSameDay(endDate, endOfMonth(endDate))) {
      if (isAria) {
        return formatRange(monthFormatter(), translations, startDate, endDate, timeZone);
      }
      return monthFormatter().formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));
    }
  }
  if (isAria) {
    return formatRange(dateFormatter(), translations, startDate, endDate, timeZone);
  }
  return dateFormatter().formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(constrainStart(focusedDate, start, visibleDuration, locale, min, max), visibleDuration, locale)
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  const start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(constrainStart(focusedDate, start, visibleDuration, locale, min, max), visibleDuration, locale)
  });
}
function getNextRow(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({
        weeks: 1
      }),
      startDate
    });
  }
}
function getPreviousRow(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({
        weeks: 1
      }),
      startDate
    });
  }
}
function getSectionStart(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: startDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: startOfWeek(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: startOfMonth(focusedDate),
      startDate
    });
  }
}
function getSectionEnd(focusedDate, startDate, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  const endDate = getEndDate(startDate, visibleDuration);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: endDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: endOfWeek(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: endOfMonth(focusedDate),
      startDate
    });
  }
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({
        months: 1
      }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({
        years: 1
      }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, min, max) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, min, max);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, min, max);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({
        months: 1
      }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({
        years: 1
      }),
      startDate
    });
  }
}
function asSingleValue(value) {
  return value;
}
function asArrayValue(value) {
  return value;
}
function asRangeValue(value) {
  return value;
}
function sortDates(values) {
  return values.sort((a, b) => a.compare(b));
}
function makeCalendarDateRange(start, end) {
  if (!start || !end) {
    return undefined;
  }
  if (end.compare(start) < 0) {
    [start, end] = [end, start];
  }
  return {
    start: toCalendarDate(start),
    end: toCalendarDate(end)
  };
}

function CalendarGrid(props) {
  const rootContext = useCalendarContext();
  const mergedProps = mergeDefaultProps({
    weekDayFormat: "short"
  }, props);
  const [local, others] = splitProps(mergedProps, ["offset", "weekDayFormat", "onKeyDown", "onFocusIn", "onFocusOut", "aria-label"]);
  const startDate = createMemo(() => {
    if (local.offset) {
      return rootContext.startDate().add(local.offset);
    }
    return rootContext.startDate();
  });
  const endDate = createMemo(() => endOfMonth(startDate()));
  const dayFormatter = createDateFormatter(() => ({
    weekday: local.weekDayFormat,
    timeZone: rootContext.timeZone()
  }));
  const weekDays = createMemo(() => {
    const firstDayOfWeek = startOfWeek(today(rootContext.timeZone()), rootContext.locale());
    return [...new Array(7).keys()].map(index => {
      const date = firstDayOfWeek.add({
        days: index
      });
      return dayFormatter().format(date.toDate(rootContext.timeZone()));
    });
  });
  const visibleRangeDescription = createMemo(() => {
    return getVisibleRangeDescription(rootContext.translations(), startDate(), endDate(), rootContext.timeZone(), true);
  });
  const ariaLabel = () => {
    return [local["aria-label"], visibleRangeDescription()].filter(Boolean).join(", ");
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    switch (e.key) {
      case "Enter":
      case " ":
        e.preventDefault();
        rootContext.selectFocusedDate();
        break;
      case "PageUp":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusPreviousSection(e.shiftKey);
        break;
      case "PageDown":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusNextSection(e.shiftKey);
        break;
      case "End":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusSectionEnd();
        break;
      case "Home":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusSectionStart();
        break;
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        if (rootContext.direction() === "rtl") {
          rootContext.focusNextDay();
        } else {
          rootContext.focusPreviousDay();
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusPreviousRow();
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        if (rootContext.direction() === "rtl") {
          rootContext.focusPreviousDay();
        } else {
          rootContext.focusNextDay();
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        e.stopPropagation();
        rootContext.focusNextRow();
        break;
      case "Escape":
        if (rootContext.selectionMode() === "range") {
          e.preventDefault();
          rootContext.setAnchorDate(undefined);
        }
        break;
    }
  };
  const onFocusIn = e => {
    callHandler(e, local.onFocusIn);
    rootContext.setIsFocused(true);
  };
  const onFocusOut = e => {
    callHandler(e, local.onFocusOut);
    rootContext.setIsFocused(false);
  };
  const context = {
    startDate,
    weekDays
  };
  return createComponent(CalendarGridContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "table",
        role: "grid",
        get ["aria-readonly"]() {
          return rootContext.isReadOnly() || undefined;
        },
        get ["aria-disabled"]() {
          return rootContext.isDisabled() || undefined;
        },
        get ["aria-multiselectable"]() {
          return rootContext.selectionMode() !== "single";
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        onKeyDown: onKeyDown,
        onFocusIn: onFocusIn,
        onFocusOut: onFocusOut
      }, others));
    }
  });
}

function CalendarGridBody(props) {
  const rootContext = useCalendarContext();
  const context = useCalendarGridContext();
  const [local, others] = splitProps(props, ["children"]);
  const weekIndexes = createMemo(() => {
    const weeksInMonth = getWeeksInMonth(context.startDate(), rootContext.locale());
    return [...new Array(weeksInMonth).keys()];
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "tbody"
  }, others, {
    get children() {
      return createComponent(Index, {
        get each() {
          return weekIndexes();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}

const CalendarGridBodyCellContext = createContext();
function useCalendarGriBodyCellContext() {
  const context = useContext(CalendarGridBodyCellContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarGriBodyCellContext` must be used within a `Calendar.GridBodyCell` component");
  }
  return context;
}

function CalendarGridBodyCell(props) {
  const rootContext = useCalendarContext();
  const [local, others] = splitProps(props, ["date", "disabled"]);
  const isSelected = createMemo(() => {
    return rootContext.isCellSelected(local.date);
  });
  const isFocused = createMemo(() => {
    return rootContext.isCellFocused(local.date);
  });
  const isDisabled = createMemo(() => {
    return local.disabled || rootContext.isCellDisabled(local.date);
  });
  const isUnavailable = createMemo(() => {
    return rootContext.isCellUnavailable(local.date);
  });
  const isSelectable = () => {
    return !rootContext.isReadOnly() && !isDisabled() && !isUnavailable();
  };
  const isInvalid = createMemo(() => {
    return rootContext.validationState() === "invalid" && isSelected();
  });
  const isDateToday = () => isToday(local.date, rootContext.timeZone());
  const context = {
    date: () => local.date,
    isSelected,
    isFocused,
    isUnavailable,
    isSelectable,
    isDisabled,
    isInvalid,
    isDateToday
  };
  return createComponent(CalendarGridBodyCellContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "td",
        role: "gridcell",
        get ["aria-disabled"]() {
          return !isSelectable() || undefined;
        },
        get ["aria-selected"]() {
          return isSelected() || undefined;
        },
        get ["aria-invalid"]() {
          return isInvalid() || undefined;
        },
        get ["aria-current"]() {
          return isDateToday() ? "date" : undefined;
        },
        get ["data-value"]() {
          return local.date.toString();
        }
      }, others));
    }
  });
}

function CalendarGridBodyCellTrigger(props) {
  let ref;
  const rootContext = useCalendarContext();
  const gridContext = useCalendarGridContext();
  const context = useCalendarGriBodyCellContext();
  const [local, others] = splitProps(props, ["ref", "disabled", "onPointerEnter", "onPointerDown", "onPointerUp", "onPointerLeave", "onClick", "onKeyDown"]);
  const isDisabled = () => local.disabled || context.isDisabled();
  const isDateWeekend = () => {
    return isWeekend(context.date(), rootContext.locale());
  };
  const isOutsideVisibleRange = () => {
    return context.date().compare(rootContext.startDate()) < 0 || context.date().compare(rootContext.endDate()) > 0;
  };
  const isOutsideMonth = () => {
    return !isSameMonth(gridContext.startDate(), context.date());
  };
  const isSelectionStart = () => {
    if (rootContext.selectionMode() !== "range") {
      return false;
    }
    const start = rootContext.highlightedRange()?.start;
    return start != null && isSameDay(context.date(), start);
  };
  const isSelectionEnd = () => {
    if (rootContext.selectionMode() !== "range") {
      return false;
    }
    const end = rootContext.highlightedRange()?.end;
    return end != null && isSameDay(context.date(), end);
  };
  const tabIndex = createMemo(() => {
    if (!isDisabled()) {
      return isSameDay(context.date(), rootContext.focusedDate()) ? 0 : -1;
    }
    return undefined;
  });
  const labelDateFormatter = createDateFormatter(() => ({
    weekday: "long",
    day: "numeric",
    month: "long",
    year: "numeric",
    era: getEraFormat(context.date()),
    timeZone: rootContext.timeZone()
  }));
  const cellDateFormatter = createDateFormatter(() => ({
    day: "numeric",
    timeZone: rootContext.timeZone(),
    calendar: context.date().calendar.identifier
  }));
  const nativeDate = createMemo(() => {
    return context.date().toDate(rootContext.timeZone());
  });
  const formattedDate = createMemo(() => {
    return cellDateFormatter().formatToParts(nativeDate()).find(part => part.type === "day")?.value;
  });
  const ariaLabel = createMemo(() => {
    let label = "";
    if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
      const {
        start,
        end
      } = asRangeValue(rootContext.value()) ?? {};
      if (start && end && (isSameDay(context.date(), start) || isSameDay(context.date(), end))) {
        label = `${getSelectedDateDescription(rootContext.translations(), context.date(), rootContext.timeZone())}, `;
      }
    }
    label += labelDateFormatter().format(nativeDate());
    if (context.isDateToday()) {
      label = rootContext.translations().todayDate(label, context.isSelected());
    } else if (context.isSelected()) {
      label = rootContext.translations().dateSelected(label);
    }
    const min = rootContext.min();
    const max = rootContext.max();
    if (min && isSameDay(context.date(), min)) {
      label += `, ${rootContext.translations().minimumDate}`;
    } else if (max && isSameDay(context.date(), max)) {
      label += `, ${rootContext.translations().maximumDate}`;
    }
    return label;
  });
  let isPointerDown = false;
  let isAnchorPressed = false;
  let isRangeBoundaryPressed = false;
  let touchDragTimerRef;
  const onPressEnd = () => {
    isRangeBoundaryPressed = false;
    isAnchorPressed = false;
    if (touchDragTimerRef != null) {
      getWindow(ref).clearTimeout(touchDragTimerRef);
      touchDragTimerRef = undefined;
    }
  };
  const onPointerEnter = e => {
    callHandler(e, local.onPointerEnter);
    if (rootContext.selectionMode() === "range" && (e.pointerType !== "touch" || rootContext.isDragging()) && context.isSelectable()) {
      rootContext.highlightDate(context.date());
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (isPointerDown) {
      onPressEnd();
    }
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    isPointerDown = true;
    if ("releasePointerCapture" in e.target) {
      e.target.releasePointerCapture(e.pointerId);
    }
    if (rootContext.isReadOnly()) {
      rootContext.focusCell(context.date());
      return;
    }
    if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
      const highlightedRange = rootContext.highlightedRange();
      if (highlightedRange && !context.isInvalid()) {
        if (isSameDay(context.date(), highlightedRange.start)) {
          rootContext.setAnchorDate(highlightedRange.end);
          rootContext.focusCell(context.date());
          rootContext.setIsDragging(true);
          isRangeBoundaryPressed = true;
          return;
        }
        if (isSameDay(context.date(), highlightedRange.end)) {
          rootContext.setAnchorDate(highlightedRange.start);
          rootContext.focusCell(context.date());
          rootContext.setIsDragging(true);
          isRangeBoundaryPressed = true;
          return;
        }
      }
      const startDragging = () => {
        rootContext.setIsDragging(true);
        touchDragTimerRef = undefined;
        rootContext.selectDate(context.date());
        rootContext.focusCell(context.date());
        isAnchorPressed = true;
      };
      if (e.pointerType === "touch") {
        touchDragTimerRef = getWindow(ref).setTimeout(startDragging, 200);
      } else {
        startDragging();
      }
    }
  };
  const onPointerUp = e => {
    callHandler(e, local.onPointerUp);
    isPointerDown = false;
    if (rootContext.isReadOnly() || rootContext.selectionMode() !== "range") {
      onPressEnd();
      return;
    }
    if (touchDragTimerRef != null) {
      rootContext.selectDate(context.date());
      rootContext.focusCell(context.date());
    }
    if (isRangeBoundaryPressed) {
      rootContext.setAnchorDate(context.date());
    } else if (rootContext.anchorDate() && !isAnchorPressed) {
      rootContext.selectDate(context.date());
      rootContext.focusCell(context.date());
    }
    onPressEnd();
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    if (rootContext.selectionMode() !== "range" && context.isSelectable()) {
      rootContext.selectDate(context.date());
      rootContext.focusCell(context.date());
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (!["Enter", " "].includes(e.key)) {
      return;
    }
    if (rootContext.isReadOnly()) {
      rootContext.focusCell(context.date());
      return;
    }
    if (rootContext.selectionMode() === "range" && !rootContext.anchorDate()) {
      e.stopPropagation();
      rootContext.selectDate(context.date());
      let nextDay = context.date().add({
        days: 1
      });
      if (rootContext.isCellInvalid(nextDay)) {
        nextDay = context.date().subtract({
          days: 1
        });
      }
      if (!rootContext.isCellInvalid(nextDay)) {
        rootContext.focusCell(nextDay);
      }
    }
  };
  createEffect(() => {
    if (ref && context.isFocused()) {
      focusWithoutScrolling(ref);
    }
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "button",
    get tabIndex() {
      return tabIndex();
    },
    get disabled() {
      return isDisabled();
    },
    get ["aria-disabled"]() {
      return !context.isSelectable() || undefined;
    },
    get ["aria-invalid"]() {
      return context.isInvalid() || undefined;
    },
    get ["aria-label"]() {
      return ariaLabel();
    },
    get ["data-disabled"]() {
      return isDisabled() || undefined;
    },
    get ["data-invalid"]() {
      return context.isInvalid() || undefined;
    },
    get ["data-selected"]() {
      return context.isSelected() || undefined;
    },
    get ["data-value"]() {
      return context.date().toString();
    },
    "data-type": "day",
    get ["data-today"]() {
      return context.isDateToday() || undefined;
    },
    get ["data-weekend"]() {
      return isDateWeekend() || undefined;
    },
    get ["data-highlighted"]() {
      return context.isFocused() || undefined;
    },
    get ["data-unavailable"]() {
      return context.isUnavailable() || undefined;
    },
    get ["data-selection-start"]() {
      return isSelectionStart() || undefined;
    },
    get ["data-selection-end"]() {
      return isSelectionEnd() || undefined;
    },
    get ["data-outside-visible-range"]() {
      return isOutsideVisibleRange() || undefined;
    },
    get ["data-outside-month"]() {
      return isOutsideMonth() || undefined;
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onPointerDown: onPointerDown,
    onPointerUp: onPointerUp,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onContextMenu: e => {
      e.preventDefault();
    }
  }, others, {
    get children() {
      return formattedDate();
    }
  }));
}

function CalendarGridBodyRow(props) {
  const rootContext = useCalendarContext();
  const context = useCalendarGridContext();
  const [local, others] = splitProps(props, ["weekIndex", "children"]);
  const datesInWeek = createMemo(() => {
    return rootContext.getDatesInWeek(local.weekIndex, context.startDate());
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "tr"
  }, others, {
    get children() {
      return createComponent(Index, {
        get each() {
          return datesInWeek();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}

function CalendarGridHeader(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "thead",
    "aria-hidden": "true"
  }, props));
}

function CalendarGridHeaderCell(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "th"
  }, props));
}

function CalendarGridHeaderRow(props) {
  const [local, others] = splitProps(props, ["children"]);
  const context = useCalendarGridContext();
  return createComponent(Polymorphic, mergeProps$1({
    as: "tr"
  }, others, {
    get children() {
      return createComponent(Index, {
        get each() {
          return context.weekDays();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}

function CalendarHeader(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "header"
  }, props));
}

function CalendarHeading(props) {
  const rootContext = useCalendarContext();
  const title = createMemo(() => {
    return getVisibleRangeDescription(rootContext.translations(), rootContext.startDate(), rootContext.endDate(), rootContext.timeZone(), false);
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "h2"
  }, props, {
    get children() {
      return title();
    }
  }));
}

function CalendarNextTrigger(props) {
  const context = useCalendarContext();
  const [local, others] = splitProps(props, ["disabled", "onClick", "onFocus", "onBlur"]);
  let nextTriggerFocused = false;
  const nextTriggerDisabled = createMemo(() => {
    return local.disabled || context.isDisabled() || isNextVisibleRangeInvalid(context.endDate(), context.min(), context.max());
  });
  const onClick = e => {
    callHandler(e, local.onClick);
    context.focusNextPage();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    nextTriggerFocused = true;
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    nextTriggerFocused = false;
  };
  createEffect(() => {
    if (nextTriggerDisabled() && nextTriggerFocused) {
      nextTriggerFocused = false;
      context.setIsFocused(true);
    }
  });
  return createComponent(ButtonRoot, mergeProps$1({
    get disabled() {
      return nextTriggerDisabled();
    },
    get ["aria-label"]() {
      return context.translations().next;
    },
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
}

function CalendarPrevTrigger(props) {
  const context = useCalendarContext();
  const [local, others] = splitProps(props, ["disabled", "onClick", "onFocus", "onBlur"]);
  let prevTriggerFocused = false;
  const prevTriggerDisabled = createMemo(() => {
    return local.disabled || context.isDisabled() || isPreviousVisibleRangeInvalid(context.startDate(), context.min(), context.max());
  });
  const onClick = e => {
    callHandler(e, local.onClick);
    context.focusPreviousPage();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    prevTriggerFocused = true;
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    prevTriggerFocused = false;
  };
  createEffect(() => {
    if (prevTriggerDisabled() && prevTriggerFocused) {
      prevTriggerFocused = false;
      context.setIsFocused(true);
    }
  });
  return createComponent(ButtonRoot, mergeProps$1({
    get disabled() {
      return prevTriggerDisabled();
    },
    get ["aria-label"]() {
      return context.translations().previous;
    },
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
}

const CALENDAR_INTL_MESSAGES = {
  previous: "Previous",
  next: "Next",
  selectedDateDescription: date => `Selected Date: ${date}`,
  selectedRangeDescription: dateRange => `Selected Range: ${dateRange}`,
  todayDate: (date, isSelected) => `Today, ${date} ${isSelected ? " selected" : ""}`,
  dateSelected: date => `${date} selected`,
  startRangeSelectionPrompt: "Click to start selecting date range",
  finishRangeSelectionPrompt: "Click to finish selecting date range",
  minimumDate: "First available date",
  maximumDate: "Last available date",
  dateRange: (startDate, endDate) => `${startDate} to ${endDate}`
};

function CalendarRoot(props) {
  let ref;
  const mergedProps = mergeDefaultProps({
    visibleDuration: {
      months: 1
    },
    selectionMode: "single",
    translations: CALENDAR_INTL_MESSAGES
  }, props);
  const [local, others] = splitProps(mergedProps, ["translations", "ref", "locale", "createCalendar", "visibleDuration", "selectionAlignment", "selectionMode", "value", "defaultValue", "onChange", "minValue", "maxValue", "isDateUnavailable", "allowsNonContiguousRanges", "autoFocus", "focusedValue", "defaultFocusedValue", "onFocusChange", "validationState", "disabled", "readOnly", "aria-label"]);
  const locale = createMemo(() => {
    return local.locale ?? useLocale().locale();
  });
  const resolvedOptions = createMemo(() => {
    return new DateFormatter(locale()).resolvedOptions();
  });
  const direction = createMemo(() => {
    return getReadingDirection(locale());
  });
  const calendar = createMemo(() => {
    return local.createCalendar(resolvedOptions().calendar);
  });
  const [value, setControlledValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const [availableRange, setAvailableRange] = createSignal();
  const selectionAlignment = createMemo(() => {
    if (local.selectionMode === "range") {
      const valueRange = asRangeValue(value());
      if (valueRange?.start && valueRange.end) {
        const start = alignCenter(toCalendarDate(valueRange.start), local.visibleDuration, locale(), local.minValue, local.maxValue);
        const end = start.add(local.visibleDuration).subtract({
          days: 1
        });
        if (valueRange.end.compare(end) > 0) {
          return "start";
        }
      }
      return "center";
    }
    return local.selectionAlignment ?? "center";
  });
  const min = createMemo(() => {
    const startRange = availableRange()?.start;
    if (local.selectionMode === "range" && local.minValue && startRange) {
      return maxDate(local.minValue, startRange);
    }
    return local.minValue;
  });
  const max = createMemo(() => {
    const endRange = availableRange()?.end;
    if (local.selectionMode === "range" && local.maxValue && endRange) {
      return minDate(local.maxValue, endRange);
    }
    return local.maxValue;
  });
  const calendarDateValue = createMemo(() => {
    return getArrayValueOfSelection(local.selectionMode, value()).map(date => toCalendar(toCalendarDate(date), calendar()));
  });
  const timeZone = createMemo(() => {
    const firstValue = getFirstValueOfSelection(local.selectionMode, value());
    if (firstValue && "timeZone" in firstValue) {
      return firstValue.timeZone;
    }
    return resolvedOptions().timeZone;
  });
  const focusedCalendarDate = createMemo(() => {
    if (local.focusedValue) {
      return constrainValue(toCalendar(toCalendarDate(local.focusedValue), calendar()), min(), max());
    }
    return undefined;
  });
  const defaultFocusedCalendarDate = createMemo(() => {
    return constrainValue(local.defaultFocusedValue ? toCalendar(toCalendarDate(local.defaultFocusedValue), calendar()) : calendarDateValue()[0] || toCalendar(today(timeZone()), calendar()), min(), max());
  });
  const [focusedDate, setFocusedDate] = createControllableSignal({
    value: focusedCalendarDate,
    defaultValue: defaultFocusedCalendarDate,
    onChange: value => local.onFocusChange?.(value)
  });
  const [startDate, setStartDate] = createSignal(alignDate(focusedDate(), selectionAlignment(), local.visibleDuration, locale(), min(), max()));
  const endDate = createMemo(() => {
    return getEndDate(startDate(), local.visibleDuration);
  });
  const [isFocused, setIsFocused] = createSignal(local.autoFocus || false);
  const [isDragging, setIsDragging] = createSignal(false);
  const visibleRangeDescription = createMemo(() => {
    return getVisibleRangeDescription(local.translations, startDate(), endDate(), timeZone(), true);
  });
  const ariaLabel = () => {
    return [local["aria-label"], visibleRangeDescription()].filter(Boolean).join(", ");
  };
  const isCellDisabled = date => {
    return local.disabled || date.compare(startDate()) < 0 || date.compare(endDate()) > 0 || isDateInvalid(date, min(), max());
  };
  const isCellUnavailable = date => {
    return local.isDateUnavailable?.(date) ?? false;
  };
  const updateAvailableRange = date => {
    if (date && local.isDateUnavailable && !local.allowsNonContiguousRanges) {
      setAvailableRange({
        start: getNextUnavailableDate(date, startDate(), endDate(), isCellUnavailable, -1),
        end: getNextUnavailableDate(date, startDate(), endDate(), isCellUnavailable, 1)
      });
    } else {
      setAvailableRange(undefined);
    }
  };
  const [anchorDate, setAnchorDate] = createControllableSignal({
    onChange: value => updateAvailableRange(value)
  });
  const highlightedRange = createMemo(() => {
    if (local.selectionMode !== "range") {
      return undefined;
    }
    const resolvedAnchorDate = anchorDate();
    if (resolvedAnchorDate) {
      return makeCalendarDateRange(resolvedAnchorDate, focusedDate());
    }
    const {
      start,
      end
    } = asRangeValue(value()) ?? {};
    return makeCalendarDateRange(start, end);
  });
  const validationState = createMemo(() => {
    if (local.validationState) {
      return local.validationState;
    }
    if (calendarDateValue().length <= 0) {
      return null;
    }
    if (local.selectionMode === "range" && anchorDate()) {
      return null;
    }
    const isSomeDateInvalid = calendarDateValue().some(date => {
      return local.isDateUnavailable?.(date) || isDateInvalid(date, min(), max());
    });
    return isSomeDateInvalid ? "invalid" : null;
  });
  const isCellSelected = cellDate => {
    const isAvailable = !isCellDisabled(cellDate) && !isCellUnavailable(cellDate);
    if (local.selectionMode === "range") {
      const {
        start,
        end
      } = highlightedRange() ?? {};
      const isInRange = start != null && cellDate.compare(start) >= 0 && end != null && cellDate.compare(end) <= 0;
      return isInRange && isAvailable;
    }
    return calendarDateValue().some(date => isSameDay(cellDate, date)) && isAvailable;
  };
  const isCellFocused = date => {
    const resolvedFocusedDate = focusedDate();
    return isFocused() && resolvedFocusedDate != null && isSameDay(date, resolvedFocusedDate);
  };
  const isCellInvalid = date => {
    if (local.selectionMode === "range") {
      return isDateInvalid(date, min(), max()) || isDateInvalid(date, availableRange()?.start, availableRange()?.end);
    }
    return isDateInvalid(date, min(), max());
  };
  const selectDate = date => {
    if (local.readOnly || local.disabled) {
      return;
    }
    let newValue = getPreviousAvailableDate(constrainValue(date, min(), max()), startDate(), local.isDateUnavailable);
    if (!newValue) {
      return;
    }
    if (local.selectionMode === "single") {
      setControlledValue(prev => {
        const prevValue = asSingleValue(prev);
        if (!newValue) {
          return prevValue;
        }
        return convertValue$1(newValue, prevValue);
      });
    } else if (local.selectionMode === "multiple") {
      setControlledValue(prev => {
        const prevValue = asArrayValue(prev) ?? [];
        if (!newValue) {
          return prevValue;
        }
        newValue = convertValue$1(newValue, prevValue[0]);
        const index = prevValue.findIndex(date => newValue != null && isSameDay(date, newValue));
        if (index !== -1) {
          const nextValues = [...prevValue];
          nextValues.splice(index, 1);
          return sortDates(nextValues);
        }
        return sortDates([...prevValue, newValue]);
      });
    } else if (local.selectionMode === "range") {
      if (!anchorDate()) {
        setAnchorDate(newValue);
      } else {
        setControlledValue(prev => {
          const prevRange = asRangeValue(prev);
          const range = makeCalendarDateRange(anchorDate(), newValue);
          if (!range) {
            return prevRange;
          }
          return {
            start: convertValue$1(range.start, prevRange?.start),
            end: convertValue$1(range.end, prevRange?.end)
          };
        });
        setAnchorDate(undefined);
      }
    }
  };
  const selectFocusedDate = () => {
    selectDate(focusedDate());
  };
  const focusCell = date => {
    setFocusedDate(constrainValue(date, min(), max()));
    if (!isFocused()) {
      setIsFocused(true);
    }
  };
  const highlightDate = date => {
    if (anchorDate()) {
      focusCell(date);
    }
  };
  const focusNextDay = () => {
    focusCell(focusedDate().add({
      days: 1
    }));
  };
  const focusPreviousDay = () => {
    focusCell(focusedDate().subtract({
      days: 1
    }));
  };
  const focusNextRow = () => {
    const row = getNextRow(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (row) {
      setStartDate(row.startDate);
      focusCell(row.focusedDate);
    }
  };
  const focusPreviousRow = () => {
    const row = getPreviousRow(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (row) {
      setStartDate(row.startDate);
      focusCell(row.focusedDate);
    }
  };
  const focusNextPage = () => {
    const page = getNextPage(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    setFocusedDate(constrainValue(page.focusedDate, min(), max()));
    setStartDate(page.startDate);
  };
  const focusPreviousPage = () => {
    const page = getPreviousPage(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    setFocusedDate(constrainValue(page.focusedDate, min(), max()));
    setStartDate(page.startDate);
  };
  const focusSectionStart = () => {
    const section = getSectionStart(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const focusSectionEnd = () => {
    const section = getSectionEnd(focusedDate(), startDate(), local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const focusNextSection = larger => {
    const section = getNextSection(focusedDate(), startDate(), larger, local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const focusPreviousSection = larger => {
    const section = getPreviousSection(focusedDate(), startDate(), larger, local.visibleDuration, locale(), min(), max());
    if (section) {
      setStartDate(section.startDate);
      focusCell(section.focusedDate);
    }
  };
  const getDatesInWeek = (weekIndex, from) => {
    let date = from.add({
      weeks: weekIndex
    });
    const dates = [];
    date = startOfWeek(date, locale());
    const dayOfWeek = getDayOfWeek(date, locale());
    for (let i = 0; i < dayOfWeek; i++) {
      dates.push(null);
    }
    while (dates.length < 7) {
      dates.push(date);
      const nextDate = date.add({
        days: 1
      });
      if (isSameDay(date, nextDate)) {
        break;
      }
      date = nextDate;
    }
    while (dates.length < 7) {
      dates.push(null);
    }
    return dates;
  };
  createInteractOutside({
    onInteractOutside: e => {
      if (local.selectionMode === "range" && anchorDate()) {
        selectFocusedDate();
      }
    }
  }, () => ref);
  let lastCalendarIdentifier = calendar().identifier;
  createEffect(on(calendar, calendar => {
    if (calendar.identifier !== lastCalendarIdentifier) {
      const newFocusedDate = toCalendar(focusedDate(), calendar);
      setStartDate(alignCenter(newFocusedDate, local.visibleDuration, locale(), min(), max()));
      setFocusedDate(newFocusedDate);
      lastCalendarIdentifier = calendar.identifier;
    }
  }));
  createEffect(() => {
    const adjust = getAdjustedDateFn(local.visibleDuration, locale(), min(), max());
    const adjustment = adjust({
      startDate: startDate(),
      focusedDate: focusedDate()
    });
    setStartDate(adjustment.startDate);
    setFocusedDate(adjustment.focusedDate);
  });
  createEffect(() => {
    if (!isFocused()) {
      announce(visibleRangeDescription());
    }
  });
  createEffect(() => {
    let description;
    if (local.selectionMode === "single") {
      const date = asSingleValue(value());
      description = date && getSelectedDateDescription(local.translations, date, timeZone());
    } else if (local.selectionMode === "multiple") {
      const dates = asArrayValue(value());
      description = dates?.map(date => getSelectedDateDescription(local.translations, date, timeZone())).join(", ");
    } else if (local.selectionMode === "range") {
      const dateRange = asRangeValue(value()) ?? {};
      description = getSelectedDateRangeDescription(local.translations, dateRange, anchorDate(), timeZone());
    }
    if (description) {
      announce(description, "polite", 4000);
    }
  });
  createEffect(on([startDate, endDate], () => {
    if (local.selectionMode === "range") {
      updateAvailableRange(anchorDate());
    }
  }));
  let isVirtualClick = false;
  createEffect(() => {
    if (isServer) {
      return;
    }
    if (local.selectionMode !== "range" || !ref) {
      return;
    }
    const win = getWindow(ref);
    const doc = getDocument(ref);
    const onWindowPointerDown = e => {
      isVirtualClick = e.width === 0 && e.height === 0;
    };
    const endDragging = e => {
      if (isVirtualClick) {
        isVirtualClick = false;
        return;
      }
      setIsDragging(false);
      if (!anchorDate()) {
        return;
      }
      const target = e.target;
      if (contains(ref, doc.activeElement) && (!contains(ref, target) || !target.closest('button, [role="button"]'))) {
        selectFocusedDate();
      }
    };
    const onTouchMove = e => {
      if (isDragging()) {
        e.preventDefault();
      }
    };
    win.addEventListener("pointerdown", onWindowPointerDown);
    win.addEventListener("pointerup", endDragging);
    win.addEventListener("pointercancel", endDragging);
    ref.addEventListener("touchmove", onTouchMove, {
      passive: false,
      capture: true
    });
    onCleanup(() => {
      win.removeEventListener("pointerdown", onWindowPointerDown);
      win.removeEventListener("pointerup", endDragging);
      win.removeEventListener("pointercancel", endDragging);
      ref?.removeEventListener("touchmove", onTouchMove, {
        capture: true
      });
    });
  });
  const dataset = createMemo(() => ({}));
  const context = {
    dataset,
    value,
    isDisabled: () => local.disabled ?? false,
    isReadOnly: () => local.readOnly ?? false,
    isDragging,
    isCellUnavailable,
    isCellDisabled,
    isCellSelected,
    isCellFocused,
    isCellInvalid,
    validationState,
    startDate,
    endDate,
    anchorDate,
    focusedDate: () => focusedDate(),
    visibleDuration: () => local.visibleDuration,
    selectionMode: () => local.selectionMode,
    locale,
    highlightedRange,
    direction,
    min,
    max,
    timeZone,
    translations: () => local.translations,
    setStartDate,
    setAnchorDate,
    setIsFocused,
    setIsDragging,
    selectFocusedDate,
    selectDate,
    highlightDate,
    focusCell,
    focusNextDay,
    focusPreviousDay,
    focusNextPage,
    focusPreviousPage,
    focusNextRow,
    focusPreviousRow,
    focusSectionStart,
    focusSectionEnd,
    focusNextSection,
    focusPreviousSection,
    getDatesInWeek
  };
  return createComponent(CalendarContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        as: "div",
        role: "group",
        get ["aria-label"]() {
          return ariaLabel();
        }
      }, others));
    }
  });
}
function convertValue$1(newValue, oldValue) {
  newValue = toCalendar(newValue, oldValue?.calendar || new GregorianCalendar());
  if (oldValue && "hour" in oldValue) {
    return oldValue.set(newValue);
  }
  return newValue;
}

var index$o = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Body: CalendarBody,
	Grid: CalendarGrid,
	GridBody: CalendarGridBody,
	GridBodyCell: CalendarGridBodyCell,
	GridBodyCellTrigger: CalendarGridBodyCellTrigger,
	GridBodyRow: CalendarGridBodyRow,
	GridHeader: CalendarGridHeader,
	GridHeaderCell: CalendarGridHeaderCell,
	GridHeaderRow: CalendarGridHeaderRow,
	Header: CalendarHeader,
	Heading: CalendarHeading,
	NextTrigger: CalendarNextTrigger,
	PrevTrigger: CalendarPrevTrigger,
	Root: CalendarRoot
});

const CheckboxContext = createContext();
function useCheckboxContext() {
  const context = useContext(CheckboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCheckboxContext` must be used within a `Checkbox` component");
  }
  return context;
}

function CheckboxControl(props) {
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(mergedProps, ["onClick", "onKeyDown"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.toggle();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.key === EventKey.Space) {
      context.toggle();
      context.inputRef()?.focus();
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => formControlContext.dataset(), () => context.dataset(), others));
}

function CheckboxDescription(props) {
  const context = useCheckboxContext();
  return createComponent(FormControlDescription, mergeProps$1(() => context.dataset(), props));
}

function CheckboxErrorMessage(props) {
  const context = useCheckboxContext();
  return createComponent(FormControlErrorMessage, mergeProps$1(() => context.dataset(), props));
}

function CheckboxIndicator(props) {
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "forceMount"]);
  const presence = createPresence(() => local.forceMount || context.indeterminate() || context.checked());
  return createComponent(Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, () => formControlContext.dataset(), () => context.dataset(), others));
    }
  });
}

const _tmpl$$h = /*#__PURE__*/template(`<input type="checkbox">`);
function CheckboxInput(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "style", "onChange", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const [isInternalChangeEvent, setIsInternalChangeEvent] = createSignal(false);
  const onChange = e => {
    callHandler(e, local.onChange);
    e.stopPropagation();
    if (!isInternalChangeEvent()) {
      const target = e.target;
      context.setIsChecked(target.checked);
      target.checked = context.checked();
    }
    setIsInternalChangeEvent(false);
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    context.setIsFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.setIsFocused(false);
  };
  createEffect(on([() => context.checked(), () => context.value()], () => {
    setIsInternalChangeEvent(true);
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));
  createEffect(on([() => ref, () => context.indeterminate(), () => context.checked()], ([ref, indeterminate]) => {
    if (ref) {
      ref.indeterminate = indeterminate;
    }
  }));
  return (() => {
    const _el$ = _tmpl$$h();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = mergeRefs(el => {
      context.setInputRef(el);
      ref = el;
    }, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$);
    spread(_el$, mergeProps$1({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.checked();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => formControlContext.dataset(), () => context.dataset(), others), false, false);
    return _el$;
  })();
}

function CheckboxLabel(props) {
  const context = useCheckboxContext();
  return createComponent(FormControlLabel, mergeProps$1(() => context.dataset(), props));
}

function CheckboxRoot(props) {
  let ref;
  const defaultId = `checkbox-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = splitProps(mergedProps, ["ref", "children", "value", "checked", "defaultChecked", "indeterminate", "onChange", "onPointerDown"], FORM_CONTROL_PROP_NAMES);
  const [inputRef, setInputRef] = createSignal();
  const [isFocused, setIsFocused] = createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => formControlContext.isDisabled(),
    isReadOnly: () => formControlContext.isReadOnly()
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultChecked ?? false));
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = createMemo(() => ({
    "data-checked": state.isSelected() ? "" : undefined,
    "data-indeterminate": local.indeterminate ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    checked: () => state.isSelected(),
    indeterminate: () => local.indeterminate ?? false,
    inputRef,
    generateId: createGenerateId(() => access(formControlProps.id)),
    toggle: () => state.toggle(),
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setInputRef
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(CheckboxContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return access(formControlProps.id);
            },
            onPointerDown: onPointerDown
          }, () => formControlContext.dataset(), dataset, others, {
            get children() {
              return createComponent(CheckboxRootChild, {
                state: context,
                get children() {
                  return local.children;
                }
              });
            }
          }));
        }
      });
    }
  });
}
function CheckboxRootChild(props) {
  const resolvedChildren = children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
  return memo(resolvedChildren);
}

var index$n = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Control: CheckboxControl,
	Description: CheckboxDescription,
	ErrorMessage: CheckboxErrorMessage,
	Indicator: CheckboxIndicator,
	Input: CheckboxInput,
	Label: CheckboxLabel,
	Root: CheckboxRoot
});

const PopperContext = createContext();
function usePopperContext() {
  const context = useContext(PopperContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopperContext` must be used within a `Popper` component");
  }
  return context;
}

const _tmpl$$g = /*#__PURE__*/template(`<svg display="block" viewBox="0 0 30 30"><g><path fill="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"></path><path stroke="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z">`);
const DEFAULT_SIZE = 30;
const HALF_DEFAULT_SIZE = DEFAULT_SIZE / 2;
const ROTATION_DEG = {
  top: 180,
  right: -90,
  bottom: 0,
  left: 90
};
function PopperArrow(props) {
  const context = usePopperContext();
  const mergedProps = mergeDefaultProps({
    size: DEFAULT_SIZE
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style", "children", "size"]);
  const dir = () => context.currentPlacement().split("-")[0];
  const contentStyle = createComputedStyle(context.contentRef);
  const fill = () => contentStyle()?.getPropertyValue("background-color") || "none";
  const stroke = () => contentStyle()?.getPropertyValue(`border-${dir()}-color`) || "none";
  const borderWidth = () => contentStyle()?.getPropertyValue(`border-${dir()}-width`) || "0px";
  const strokeWidth = () => {
    return parseInt(borderWidth()) * 2 * (DEFAULT_SIZE / local.size);
  };
  const rotate = () => {
    return `rotate(${ROTATION_DEG[dir()]} ${HALF_DEFAULT_SIZE} ${HALF_DEFAULT_SIZE})`;
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(context.setArrowRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-hidden": "true",
    get style() {
      return {
        position: "absolute",
        "font-size": `${local.size}px`,
        width: "1em",
        height: "1em",
        "pointer-events": "none",
        fill: fill(),
        stroke: stroke(),
        "stroke-width": strokeWidth(),
        ...local.style
      };
    }
  }, others, {
    get children() {
      const _el$ = _tmpl$$g(),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.firstChild;
        _el$3.nextSibling;
      effect(() => setAttribute(_el$2, "transform", rotate()));
      return _el$;
    }
  }));
}
function createComputedStyle(element) {
  const [style, setStyle] = createSignal();
  createEffect(() => {
    const el = element();
    el && setStyle(getWindow(el).getComputedStyle(el));
  });
  return style;
}

function PopperPositioner(props) {
  const context = usePopperContext();
  const [local, others] = splitProps(props, ["ref", "style"]);
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(context.setPositionerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "data-popper-positioner": "",
    get style() {
      return {
        position: "absolute",
        top: 0,
        left: 0,
        "min-width": "max-content",
        ...local.style
      };
    }
  }, others));
}

function createDOMRect(anchorRect) {
  const {
    x = 0,
    y = 0,
    width = 0,
    height = 0
  } = anchorRect ?? {};
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return {
    ...rect,
    toJSON: () => rect
  };
}
function getAnchorElement(anchor, getAnchorRect) {
  const contextElement = anchor;
  return {
    contextElement,
    getBoundingClientRect: () => {
      const anchorRect = getAnchorRect(anchor);
      if (anchorRect) {
        return createDOMRect(anchorRect);
      }
      if (anchor) {
        return anchor.getBoundingClientRect();
      }
      return createDOMRect();
    }
  };
}
function isValidPlacement(flip) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip);
}
const REVERSE_BASE_PLACEMENT = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function getTransformOrigin(placement, readingDirection) {
  const [basePlacement, alignment] = placement.split("-");
  const reversePlacement = REVERSE_BASE_PLACEMENT[basePlacement];
  if (!alignment) {
    return `${reversePlacement} center`;
  }
  if (basePlacement === "left" || basePlacement === "right") {
    return `${reversePlacement} ${alignment === "start" ? "top" : "bottom"}`;
  }
  if (alignment === "start") {
    return `${reversePlacement} ${readingDirection === "rtl" ? "right" : "left"}`;
  }
  return `${reversePlacement} ${readingDirection === "rtl" ? "left" : "right"}`;
}

function PopperRoot(props) {
  const mergedProps = mergeDefaultProps({
    getAnchorRect: anchor => anchor?.getBoundingClientRect(),
    placement: "bottom",
    gutter: 0,
    shift: 0,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    hideWhenDetached: false,
    detachedPadding: 0,
    arrowPadding: 4,
    overflowPadding: 8
  }, props);
  const [positionerRef, setPositionerRef] = createSignal();
  const [arrowRef, setArrowRef] = createSignal();
  const [currentPlacement, setCurrentPlacement] = createSignal(mergedProps.placement);
  const anchorRef = () => getAnchorElement(mergedProps.anchorRef(), mergedProps.getAnchorRect);
  const {
    direction
  } = useLocale();
  async function updatePosition() {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    const arrowEl = arrowRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const arrowOffset = (arrowEl?.clientHeight || 0) / 2;
    const finalGutter = typeof mergedProps.gutter === "number" ? mergedProps.gutter + arrowOffset : mergedProps.gutter ?? arrowOffset;
    floatingEl.style.setProperty("--kb-popper-content-overflow-padding", `${mergedProps.overflowPadding}px`);
    referenceEl.getBoundingClientRect();
    const middleware = [offset(({
      placement
    }) => {
      const hasAlignment = !!placement.split("-")[1];
      return {
        mainAxis: finalGutter,
        crossAxis: !hasAlignment ? mergedProps.shift : undefined,
        alignmentAxis: mergedProps.shift
      };
    })];
    if (mergedProps.flip !== false) {
      const fallbackPlacements = typeof mergedProps.flip === "string" ? mergedProps.flip.split(" ") : undefined;
      if (fallbackPlacements !== undefined && !fallbackPlacements.every(isValidPlacement)) {
        throw new Error("`flip` expects a spaced-delimited list of placements");
      }
      middleware.push(flip({
        padding: mergedProps.overflowPadding,
        fallbackPlacements: fallbackPlacements
      }));
    }
    if (mergedProps.slide || mergedProps.overlap) {
      middleware.push(shift({
        mainAxis: mergedProps.slide,
        crossAxis: mergedProps.overlap,
        padding: mergedProps.overflowPadding
      }));
    }
    middleware.push(size({
      padding: mergedProps.overflowPadding,
      apply({
        availableWidth,
        availableHeight,
        rects
      }) {
        const referenceWidth = Math.round(rects.reference.width);
        availableWidth = Math.floor(availableWidth);
        availableHeight = Math.floor(availableHeight);
        floatingEl.style.setProperty("--kb-popper-anchor-width", `${referenceWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-width", `${availableWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-height", `${availableHeight}px`);
        if (mergedProps.sameWidth) {
          floatingEl.style.width = `${referenceWidth}px`;
        }
        if (mergedProps.fitViewport) {
          floatingEl.style.maxWidth = `${availableWidth}px`;
          floatingEl.style.maxHeight = `${availableHeight}px`;
        }
      }
    }));
    if (mergedProps.hideWhenDetached) {
      middleware.push(hide({
        padding: mergedProps.detachedPadding
      }));
    }
    if (arrowEl) {
      middleware.push(arrow({
        element: arrowEl,
        padding: mergedProps.arrowPadding
      }));
    }
    const pos = await computePosition(referenceEl, floatingEl, {
      placement: mergedProps.placement,
      strategy: "absolute",
      middleware,
      platform: {
        ...platform,
        isRTL: () => direction() === "rtl"
      }
    });
    setCurrentPlacement(pos.placement);
    mergedProps.onCurrentPlacementChange?.(pos.placement);
    if (!floatingEl) {
      return;
    }
    floatingEl.style.setProperty("--kb-popper-content-transform-origin", getTransformOrigin(pos.placement, direction()));
    const x = Math.round(pos.x);
    const y = Math.round(pos.y);
    let visibility;
    if (mergedProps.hideWhenDetached) {
      visibility = pos.middlewareData.hide?.referenceHidden ? "hidden" : "visible";
    }
    Object.assign(floatingEl.style, {
      top: "0",
      left: "0",
      transform: `translate3d(${x}px, ${y}px, 0)`,
      visibility
    });
    if (arrowEl && pos.middlewareData.arrow) {
      const {
        x: arrowX,
        y: arrowY
      } = pos.middlewareData.arrow;
      const dir = pos.placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: arrowX != null ? `${arrowX}px` : "",
        top: arrowY != null ? `${arrowY}px` : "",
        [dir]: "100%"
      });
    }
  }
  createEffect(() => {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const cleanupAutoUpdate = autoUpdate(referenceEl, floatingEl, updatePosition, {
      elementResize: typeof ResizeObserver === "function"
    });
    onCleanup(cleanupAutoUpdate);
  });
  createEffect(() => {
    const positioner = positionerRef();
    const content = mergedProps.contentRef();
    if (!positioner || !content) {
      return;
    }
    queueMicrotask(() => {
      positioner.style.zIndex = getComputedStyle(content).zIndex;
    });
  });
  const context = {
    currentPlacement,
    contentRef: () => mergedProps.contentRef(),
    setPositionerRef,
    setArrowRef
  };
  return createComponent(PopperContext.Provider, {
    value: context,
    get children() {
      return mergedProps.children;
    }
  });
}

const ComboboxContext = createContext();
function useComboboxContext() {
  const context = useContext(ComboboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useComboboxContext` must be used within a `Combobox` component");
  }
  return context;
}

function ComboboxContent(props) {
  let ref;
  const context = useComboboxContext();
  const [local, others] = splitProps(props, ["ref", "id", "style", "onCloseAutoFocus", "onFocusOutside"]);
  const close = () => {
    context.resetInputValue(context.listState().selectionManager().selectedKeys());
    context.close();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => {
      const excludedElements = [];
      if (ref) {
        excludedElements.push(ref);
      }
      const controlEl = context.controlRef();
      if (controlEl) {
        excludedElements.push(controlEl);
      }
      return excludedElements;
    }
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: e => {
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      local.onCloseAutoFocus?.(e);
      if (!e.defaultPrevented) {
        focusWithoutScrolling(context.inputRef());
        e.preventDefault();
      }
    }
  }, () => ref);
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get disableOutsidePointerEvents() {
              return memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.controlRef];
            },
            get style() {
              return {
                "--kb-combobox-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: onFocusOutside,
            onDismiss: close
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function ComboboxInput(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "disabled", "onInput", "onPointerDown", "onClick", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const collection = () => context.listState().collection();
  const selectionManager = () => context.listState().selectionManager();
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled();
  };
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onInput = e => {
    callHandler(e, local.onInput);
    if (formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    const target = e.target;
    context.setInputValue(target.value);
    target.value = context.inputValue() ?? "";
    if (context.isOpen()) {
      if (collection().getSize() <= 0 && !context.allowsEmptyCollection()) {
        context.close();
      }
    } else {
      if (collection().getSize() > 0) {
        context.open(false, "input");
      }
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    if (context.isOpen()) {
      callHandler(e, context.onInputKeyDown);
    }
    switch (e.key) {
      case "Enter":
        if (context.isOpen()) {
          e.preventDefault();
          const focusedKey = selectionManager().focusedKey();
          if (focusedKey != null) {
            selectionManager().select(focusedKey);
          }
        }
        break;
      case "Tab":
        if (context.isOpen()) {
          context.close();
          context.resetInputValue(context.listState().selectionManager().selectedKeys());
        }
        break;
      case "Escape":
        if (context.isOpen()) {
          context.close();
          context.resetInputValue(context.listState().selectionManager().selectedKeys());
        } else {
          context.setInputValue("");
        }
        break;
      case "ArrowDown":
        if (!context.isOpen()) {
          context.open(e.altKey ? false : "first", "manual");
        }
        break;
      case "ArrowUp":
        if (!context.isOpen()) {
          context.open("last", "manual");
        } else {
          if (e.altKey) {
            context.close();
            context.resetInputValue(context.listState().selectionManager().selectedKeys());
          }
        }
        break;
      case "ArrowLeft":
      case "ArrowRight":
        selectionManager().setFocusedKey(undefined);
        break;
      case "Backspace":
        if (context.removeOnBackspace() && selectionManager().selectionMode() === "multiple" && context.inputValue() === "") {
          const lastSelectedKey = [...selectionManager().selectedKeys()].pop() ?? "";
          selectionManager().toggleSelection(lastSelectedKey);
        }
        break;
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (context.isInputFocused()) {
      return;
    }
    context.setIsInputFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    if (contains(context.controlRef(), e.relatedTarget) || contains(context.contentRef(), e.relatedTarget)) {
      return;
    }
    context.setIsInputFocused(false);
  };
  let lastEventTime = 0;
  const onTouchEnd = e => {
    if (!ref || formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    if (e.timeStamp - lastEventTime < 500) {
      e.preventDefault();
      ref.focus();
      return;
    }
    const rect = e.target.getBoundingClientRect();
    const touch = e.changedTouches[0];
    const centerX = Math.ceil(rect.left + 0.5 * rect.width);
    const centerY = Math.ceil(rect.top + 0.5 * rect.height);
    if (touch.clientX === centerX && touch.clientY === centerY) {
      e.preventDefault();
      ref.focus();
      context.toggle(false, "manual");
      lastEventTime = e.timeStamp;
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "input",
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        context.setInputRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get value() {
      return context.inputValue();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get placeholder() {
      return context.placeholder();
    },
    type: "text",
    role: "combobox",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: "false",
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-activedescendant"]() {
      return context.activeDescendant();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    onInput: onInput,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur,
    onTouchEnd: onTouchEnd
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const ListboxContext = createContext();
function useListboxContext() {
  const context = useContext(ListboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxContext` must be used within a `Listbox` component");
  }
  return context;
}

const ListboxItemContext = createContext();
function useListboxItemContext() {
  const context = useContext(ListboxItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxItemContext` must be used within a `Listbox.Item` component");
  }
  return context;
}

function ListboxItem(props) {
  let ref;
  const listBoxContext = useListboxContext();
  const defaultId = `${listBoxContext.generateId("item")}-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "item", "aria-label", "aria-labelledby", "aria-describedby", "onPointerMove", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const selectionManager = () => listBoxContext.listState().selectionManager();
  const isHighlighted = () => selectionManager().focusedKey() === local.item.key;
  const selectableItem = createSelectableItem({
    key: () => local.item.key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: listBoxContext.shouldSelectOnPressUp,
    allowsDifferentPressOrigin: () => {
      return listBoxContext.shouldSelectOnPressUp() && listBoxContext.shouldFocusOnHover();
    },
    shouldUseVirtualFocus: listBoxContext.shouldUseVirtualFocus,
    disabled: () => local.item.disabled
  }, () => ref);
  const ariaSelected = () => {
    if (selectionManager().selectionMode() === "none") {
      return undefined;
    }
    return selectableItem.isSelected();
  };
  const isNotSafariMacOS = createMemo(() => !(isMac() && isWebKit()));
  const ariaLabel = () => isNotSafariMacOS() ? local["aria-label"] : undefined;
  const ariaLabelledBy = () => isNotSafariMacOS() ? labelId() : undefined;
  const ariaDescribedBy = () => isNotSafariMacOS() ? descriptionId() : undefined;
  const ariaPosInSet = () => {
    if (!listBoxContext.isVirtualized()) {
      return undefined;
    }
    const index = listBoxContext.listState().collection().getItem(local.item.key)?.index;
    return index != null ? index + 1 : undefined;
  };
  const ariaSetSize = () => {
    if (!listBoxContext.isVirtualized()) {
      return undefined;
    }
    return getItemCount(listBoxContext.listState().collection());
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (!selectableItem.isDisabled() && listBoxContext.shouldFocusOnHover()) {
      focusWithoutScrolling(e.currentTarget);
      selectionManager().setFocused(true);
      selectionManager().setFocusedKey(local.item.key);
    }
  };
  const dataset = createMemo(() => ({
    "data-disabled": selectableItem.isDisabled() ? "" : undefined,
    "data-selected": selectableItem.isSelected() ? "" : undefined,
    "data-highlighted": isHighlighted() ? "" : undefined
  }));
  const context = {
    isSelected: selectableItem.isSelected,
    dataset,
    generateId: createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(ListboxItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "li",
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "option",
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-disabled"]() {
          return selectableItem.isDisabled();
        },
        get ["aria-selected"]() {
          return ariaSelected();
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        },
        get ["aria-posinset"]() {
          return ariaPosInSet();
        },
        get ["aria-setsize"]() {
          return ariaSetSize();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return composeEventHandlers([local.onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove: onPointerMove
      }, dataset, others));
    }
  });
}

function ListboxItemDescription(props) {
  const context = useListboxItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function ListboxItemIndicator(props) {
  const context = useListboxItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(mergedProps, ["forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isSelected();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        "aria-hidden": "true"
      }, () => context.dataset(), others));
    }
  });
}

function ListboxItemLabel(props) {
  const context = useListboxItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function ListboxRoot(props) {
  let ref;
  const defaultId = `listbox-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    virtualized: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "children", "renderItem", "renderSection", "value", "defaultValue", "onChange", "options", "optionValue", "optionTextValue", "optionDisabled", "optionGroupChildren", "state", "keyboardDelegate", "autoFocus", "selectionMode", "shouldFocusWrap", "shouldUseVirtualFocus", "shouldSelectOnPressUp", "shouldFocusOnHover", "allowDuplicateSelectionEvents", "disallowEmptySelection", "selectionBehavior", "selectOnFocus", "disallowTypeAhead", "allowsTabNavigation", "virtualized", "scrollToItem", "scrollRef", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const listState = createMemo(() => {
    if (local.state) {
      return local.state;
    }
    return createListState({
      selectedKeys: () => local.value,
      defaultSelectedKeys: () => local.defaultValue,
      onSelectionChange: local.onChange,
      allowDuplicateSelectionEvents: () => access(local.allowDuplicateSelectionEvents),
      disallowEmptySelection: () => access(local.disallowEmptySelection),
      selectionBehavior: () => access(local.selectionBehavior),
      selectionMode: () => access(local.selectionMode),
      dataSource: () => local.options ?? [],
      getKey: () => local.optionValue,
      getTextValue: () => local.optionTextValue,
      getDisabled: () => local.optionDisabled,
      getSectionChildren: () => local.optionGroupChildren
    });
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState().selectionManager(),
    collection: () => listState().collection(),
    autoFocus: () => access(local.autoFocus),
    shouldFocusWrap: () => access(local.shouldFocusWrap),
    keyboardDelegate: () => local.keyboardDelegate,
    disallowEmptySelection: () => access(local.disallowEmptySelection),
    selectOnFocus: () => access(local.selectOnFocus),
    disallowTypeAhead: () => access(local.disallowTypeAhead),
    shouldUseVirtualFocus: () => access(local.shouldUseVirtualFocus),
    allowsTabNavigation: () => access(local.allowsTabNavigation),
    isVirtualized: () => local.virtualized,
    scrollToKey: () => local.scrollToItem
  }, () => ref, () => local.scrollRef?.());
  const context = {
    listState,
    generateId: createGenerateId(() => others.id),
    shouldUseVirtualFocus: () => mergedProps.shouldUseVirtualFocus,
    shouldSelectOnPressUp: () => mergedProps.shouldSelectOnPressUp,
    shouldFocusOnHover: () => mergedProps.shouldFocusOnHover,
    isVirtualized: () => local.virtualized
  };
  return createComponent(ListboxContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "ul",
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "listbox",
        get tabIndex() {
          return selectableList.tabIndex();
        },
        get ["aria-multiselectable"]() {
          return listState().selectionManager().selectionMode() === "multiple" ? true : undefined;
        },
        get onKeyDown() {
          return composeEventHandlers([local.onKeyDown, selectableList.onKeyDown]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
        },
        get onFocusIn() {
          return composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
        },
        get onFocusOut() {
          return composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
        }
      }, others, {
        get children() {
          return createComponent(Show, {
            get when() {
              return !local.virtualized;
            },
            get fallback() {
              return local.children?.(listState().collection);
            },
            get children() {
              return createComponent(Key, {
                get each() {
                  return [...listState().collection()];
                },
                by: "key",
                children: item => createComponent(Switch, {
                  get children() {
                    return [createComponent(Match, {
                      get when() {
                        return item().type === "section";
                      },
                      get children() {
                        return local.renderSection?.(item());
                      }
                    }), createComponent(Match, {
                      get when() {
                        return item().type === "item";
                      },
                      get children() {
                        return local.renderItem?.(item());
                      }
                    })];
                  }
                })
              });
            }
          });
        }
      }));
    }
  });
}

function ListboxSection(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "li",
    role: "presentation"
  }, props));
}

var index$m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Item: ListboxItem,
	ItemDescription: ListboxItemDescription,
	ItemIndicator: ListboxItemIndicator,
	ItemLabel: ListboxItemLabel,
	Root: ListboxRoot,
	Section: ListboxSection
});

function ComboboxListbox(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("listbox")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref"]);
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, context.listboxAriaLabel(), undefined);
  };
  createEffect(() => onCleanup(context.registerListboxId(others.id)));
  return createComponent(ListboxRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get state() {
      return context.listState();
    },
    get autoFocus() {
      return context.autoFocus();
    },
    shouldUseVirtualFocus: true,
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get ["aria-label"]() {
      return context.listboxAriaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get renderItem() {
      return context.renderItem;
    },
    get renderSection() {
      return context.renderSection;
    },
    get virtualized() {
      return context.isVirtualized();
    }
  }, others));
}

function ComboboxPortal(props) {
  const context = useComboboxContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

function ComboboxControl(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const [local, others] = splitProps(props, ["ref", "children"]);
  const selectionManager = () => context.listState().selectionManager();
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(context.setControlRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, () => context.dataset(), () => formControlContext.dataset(), others, {
    get children() {
      return createComponent(ComboboxControlChild, {
        state: {
          selectedOptions: () => context.selectedOptions(),
          remove: option => context.removeOptionFromSelection(option),
          clear: () => selectionManager().clearSelection()
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
function ComboboxControlChild(props) {
  const resolvedChildren = children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
  return memo(resolvedChildren);
}

const _tmpl$$f = /*#__PURE__*/template(`<option>`),
  _tmpl$2 = /*#__PURE__*/template(`<div aria-hidden="true"><input type="text"><select tabindex="-1"><option>`);
function HiddenSelectBase(props) {
  let ref;
  const [local, others] = splitProps(props, ["ref", "onChange", "collection", "selectionManager", "isOpen", "isMultiple", "isVirtualized", "focusTrigger"]);
  const formControlContext = useFormControlContext();
  const [isInternalChangeEvent, setIsInternalChangeEvent] = createSignal(false);
  const renderOption = key => {
    const item = local.collection.getItem(key);
    return createComponent(Show, {
      get when() {
        return item?.type === "item";
      },
      get children() {
        const _el$ = _tmpl$$f();
        _el$.value = key;
        insert(_el$, () => item?.textValue);
        effect(() => _el$.selected = local.selectionManager.isSelected(key));
        return _el$;
      }
    });
  };
  createEffect(on(() => local.selectionManager.selectedKeys(), (keys, prevKeys) => {
    if (prevKeys && isSameSelection(keys, prevKeys)) {
      return;
    }
    setIsInternalChangeEvent(true);
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));
  return (() => {
    const _el$2 = _tmpl$2(),
      _el$3 = _el$2.firstChild,
      _el$4 = _el$3.nextSibling;
      _el$4.firstChild;
    _el$3.addEventListener("focus", () => local.focusTrigger());
    _el$3.style.setProperty("font-size", "16px");
    _el$4.addEventListener("change", e => {
      callHandler(e, local.onChange);
      if (!isInternalChangeEvent()) {
        local.selectionManager.setSelectedKeys(new Set([e.target.value]));
      }
      setIsInternalChangeEvent(false);
    });
    const _ref$ = mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$4);
    spread(_el$4, mergeProps$1({
      get multiple() {
        return local.isMultiple;
      },
      get name() {
        return formControlContext.name();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get size() {
        return local.collection.getSize();
      },
      get value() {
        return local.selectionManager.firstSelectedKey() ?? "";
      }
    }, others), false, true);
    insert(_el$4, createComponent(Show, {
      get when() {
        return local.isVirtualized;
      },
      get fallback() {
        return createComponent(For, {
          get each() {
            return [...local.collection.getKeys()];
          },
          children: renderOption
        });
      },
      get children() {
        return createComponent(For, {
          get each() {
            return [...local.selectionManager.selectedKeys()];
          },
          children: renderOption
        });
      }
    }), null);
    effect(_p$ => {
      const _v$ = visuallyHiddenStyles,
        _v$2 = local.selectionManager.isFocused() || local.isOpen ? -1 : 0,
        _v$3 = formControlContext.isRequired(),
        _v$4 = formControlContext.isDisabled(),
        _v$5 = formControlContext.isReadOnly();
      _p$._v$ = style(_el$2, _v$, _p$._v$);
      _v$2 !== _p$._v$2 && setAttribute(_el$3, "tabindex", _p$._v$2 = _v$2);
      _v$3 !== _p$._v$3 && (_el$3.required = _p$._v$3 = _v$3);
      _v$4 !== _p$._v$4 && (_el$3.disabled = _p$._v$4 = _v$4);
      _v$5 !== _p$._v$5 && (_el$3.readOnly = _p$._v$5 = _v$5);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined,
      _v$3: undefined,
      _v$4: undefined,
      _v$5: undefined
    });
    return _el$2;
  })();
}

function ComboboxHiddenSelect(props) {
  const context = useComboboxContext();
  return createComponent(HiddenSelectBase, mergeProps$1({
    get collection() {
      return context.listState().collection();
    },
    get selectionManager() {
      return context.listState().selectionManager();
    },
    get isOpen() {
      return context.isOpen();
    },
    get isMultiple() {
      return context.isMultiple();
    },
    get isVirtualized() {
      return context.isVirtualized();
    },
    focusTrigger: () => context.inputRef()?.focus()
  }, props));
}

function ComboboxIcon(props) {
  const context = useComboboxContext();
  const mergedProps = mergeDefaultProps({
    children: "▼"
  }, props);
  return createComponent(Polymorphic, mergeProps$1({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}

const COMBOBOX_INTL_TRANSLATIONS = {
  focusAnnouncement: (optionText, isSelected) => `${optionText}${isSelected ? ", selected" : ""}`,
  countAnnouncement: optionCount => {
    switch (optionCount) {
      case 1:
        return "one option available";
    }
  },
  selectedAnnouncement: optionText => `${optionText}, selected`,
  triggerLabel: "Show suggestions",
  listboxLabel: "Suggestions"
};

function ComboboxBase(props) {
  const defaultId = `combobox-${createUniqueId()}`;
  const filter = createFilter({
    sensitivity: "base"
  });
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    allowsEmptyCollection: false,
    disallowEmptySelection: false,
    allowDuplicateSelectionEvents: true,
    closeOnSelection: props.selectionMode === "single",
    removeOnBackspace: true,
    gutter: 8,
    sameWidth: true,
    modal: false,
    defaultFilter: "contains",
    triggerMode: "input",
    translations: COMBOBOX_INTL_TRANSLATIONS
  }, props);
  const [local, popperProps, formControlProps, others] = splitProps(mergedProps, ["translations", "itemComponent", "sectionComponent", "open", "defaultOpen", "onOpenChange", "onInputChange", "value", "defaultValue", "onChange", "triggerMode", "placeholder", "options", "optionValue", "optionTextValue", "optionLabel", "optionDisabled", "optionGroupChildren", "keyboardDelegate", "allowDuplicateSelectionEvents", "disallowEmptySelection", "defaultFilter", "shouldFocusWrap", "allowsEmptyCollection", "closeOnSelection", "removeOnBackspace", "selectionBehavior", "selectionMode", "virtualized", "modal", "preventScroll", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [listboxId, setListboxId] = createSignal();
  const [controlRef, setControlRef] = createSignal();
  const [inputRef, setInputRef] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [listboxRef, setListboxRef] = createSignal();
  const [focusStrategy, setFocusStrategy] = createSignal(false);
  const [isInputFocused, setIsInputFocusedState] = createSignal(false);
  const [showAllOptions, setShowAllOptions] = createSignal(false);
  const [lastDisplayedOptions, setLastDisplayedOptions] = createSignal(local.options);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen, openTriggerMode)
  });
  const [inputValue, setInputValue] = createControllableSignal({
    defaultValue: () => "",
    onChange: value => {
      local.onInputChange?.(value);
      if (value === "" && local.selectionMode === "single" && !listState.selectionManager().isEmpty() && local.value === undefined) {
        listState.selectionManager().setSelectedKeys([]);
      }
      listState.selectionManager().setFocusedKey(undefined);
    }
  });
  const getOptionValue = option => {
    const optionValue = local.optionValue;
    if (optionValue == null) {
      return String(option);
    }
    return String(isFunction(optionValue) ? optionValue(option) : option[optionValue]);
  };
  const getOptionLabel = option => {
    const optionLabel = local.optionLabel;
    if (optionLabel == null) {
      return String(option);
    }
    return String(isFunction(optionLabel) ? optionLabel(option) : option[optionLabel]);
  };
  const allOptions = createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;
    if (optionGroupChildren == null) {
      return local.options;
    }
    return local.options.flatMap(item => item[optionGroupChildren] ?? item);
  });
  const filterFn = option => {
    const inputVal = inputValue() ?? "";
    if (isFunction(local.defaultFilter)) {
      return local.defaultFilter?.(option, inputVal);
    }
    const textVal = getOptionLabel(option);
    switch (local.defaultFilter) {
      case "startsWith":
        return filter.startsWith(textVal, inputVal);
      case "endsWith":
        return filter.endsWith(textVal, inputVal);
      case "contains":
        return filter.contains(textVal, inputVal);
    }
  };
  const filteredOptions = createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;
    if (optionGroupChildren == null) {
      return local.options.filter(filterFn);
    }
    const filteredGroups = [];
    for (const optGroup of local.options) {
      const filteredChildrenOptions = optGroup[optionGroupChildren].filter(filterFn);
      if (filteredChildrenOptions.length === 0) continue;
      filteredGroups.push({
        ...optGroup,
        [optionGroupChildren]: filteredChildrenOptions
      });
    }
    return filteredGroups;
  });
  const displayedOptions = createMemo(() => {
    if (disclosureState.isOpen()) {
      if (showAllOptions()) {
        return local.options;
      }
      return filteredOptions();
    }
    return lastDisplayedOptions();
  });
  let openTriggerMode = "focus";
  const getOptionsFromValues = values => {
    return [...values].map(value => allOptions().find(option => getOptionValue(option) === value)).filter(option => option != null);
  };
  const listState = createListState({
    selectedKeys: () => {
      if (local.value != null) {
        return local.value.map(getOptionValue);
      }
      return local.value;
    },
    defaultSelectedKeys: () => {
      if (local.defaultValue != null) {
        return local.defaultValue.map(getOptionValue);
      }
      return local.defaultValue;
    },
    onSelectionChange: selectedKeys => {
      local.onChange?.(getOptionsFromValues(selectedKeys));
      if (local.closeOnSelection) {
        if (disclosureState.isOpen() && selectedKeys.size > 0) {
          close();
        }
      }
      const inputEl = inputRef();
      if (inputEl) {
        inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
        focusWithoutScrolling(inputEl);
      }
    },
    allowDuplicateSelectionEvents: () => access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => local.disallowEmptySelection,
    selectionBehavior: () => access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: displayedOptions,
    getKey: () => local.optionValue,
    getTextValue: () => local.optionTextValue,
    getDisabled: () => local.optionDisabled,
    getSectionChildren: () => local.optionGroupChildren
  });
  const selectedOptions = createMemo(() => {
    return getOptionsFromValues(listState.selectionManager().selectedKeys());
  });
  const removeOptionFromSelection = option => {
    listState.selectionManager().toggleSelection(getOptionValue(option));
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const open = (focusStrategy, triggerMode) => {
    const showAllOptions = setShowAllOptions(triggerMode === "manual");
    const hasOptions = showAllOptions ? local.options.length > 0 : filteredOptions().length > 0;
    if (!hasOptions && !local.allowsEmptyCollection) {
      return;
    }
    openTriggerMode = triggerMode;
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
  };
  const toggle = (focusStrategy, triggerMode) => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy, triggerMode);
    }
  };
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(inputRef, () => {
    const defaultSelectedKeys = local.defaultValue ? [...local.defaultValue].map(getOptionValue) : new Selection();
    listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
  });
  const delegate = createMemo(() => {
    const keyboardDelegate = access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, listboxRef, undefined);
  });
  const selectableCollection = createSelectableCollection({
    selectionManager: () => listState.selectionManager(),
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap: () => local.shouldFocusWrap,
    isVirtualized: true
  }, inputRef);
  const setIsInputFocused = isFocused => {
    if (isFocused && local.triggerMode === "focus") {
      open(false, "focus");
    }
    setIsInputFocusedState(isFocused);
    listState.selectionManager().setFocused(isFocused);
  };
  const activeDescendant = createMemo(() => {
    const focusedKey = listState.selectionManager().focusedKey();
    if (focusedKey) {
      return listboxRef()?.querySelector(`[data-key="${focusedKey}"]`)?.id;
    }
    return undefined;
  });
  const resetInputValue = selectedKeys => {
    if (local.selectionMode === "single") {
      const selectedKey = [...selectedKeys][0];
      const selectedOption = allOptions().find(option => getOptionValue(option) === selectedKey);
      setInputValue(selectedOption ? getOptionLabel(selectedOption) : "");
    } else {
      setInputValue("");
    }
  };
  const renderItem = item => {
    return local.itemComponent?.({
      item
    });
  };
  const renderSection = section => {
    return local.sectionComponent?.({
      section
    });
  };
  createEffect(on([filteredOptions, showAllOptions], (input, prevInput) => {
    if (disclosureState.isOpen() && prevInput != null) {
      const prevFilteredOptions = prevInput[0];
      const prevShowAllOptions = prevInput[1];
      setLastDisplayedOptions(prevShowAllOptions ? local.options : prevFilteredOptions);
    } else {
      const filteredOptions = input[0];
      const showAllOptions = input[1];
      setLastDisplayedOptions(showAllOptions ? local.options : filteredOptions);
    }
  }));
  createEffect(on(inputValue, () => {
    if (showAllOptions()) {
      setShowAllOptions(false);
    }
  }));
  createEffect(on(() => listState.selectionManager().selectedKeys(), resetInputValue));
  let lastAnnouncedFocusedKey = "";
  createEffect(() => {
    const focusedKey = listState.selectionManager().focusedKey() ?? "";
    const focusedItem = listState.collection().getItem(focusedKey);
    if (isAppleDevice() && focusedItem != null && focusedKey !== lastAnnouncedFocusedKey) {
      const isSelected = listState.selectionManager().isSelected(focusedKey);
      const announcement = local.translations?.focusAnnouncement(focusedItem?.textValue || "", isSelected) ?? "";
      announce(announcement);
    }
    if (focusedKey) {
      lastAnnouncedFocusedKey = focusedKey;
    }
  });
  let lastOptionCount = getItemCount(listState.collection());
  let lastOpen = disclosureState.isOpen();
  createEffect(() => {
    const optionCount = getItemCount(listState.collection());
    const isOpen = disclosureState.isOpen();
    const didOpenWithoutFocusedItem = isOpen !== lastOpen && (listState.selectionManager().focusedKey() == null || isAppleDevice());
    if (isOpen && (didOpenWithoutFocusedItem || optionCount !== lastOptionCount)) {
      const announcement = local.translations?.countAnnouncement(optionCount) ?? "";
      announce(announcement);
    }
    lastOptionCount = optionCount;
    lastOpen = isOpen;
  });
  let lastAnnouncedSelectedKey = "";
  createEffect(() => {
    const lastSelectedKey = [...listState.selectionManager().selectedKeys()].pop() ?? "";
    const lastSelectedItem = listState.collection().getItem(lastSelectedKey);
    if (isAppleDevice() && isInputFocused() && lastSelectedItem && lastSelectedKey !== lastAnnouncedSelectedKey) {
      const announcement = local.translations?.selectedAnnouncement(lastSelectedItem?.textValue || "") ?? "";
      announce(announcement);
    }
    if (lastSelectedKey) {
      lastAnnouncedSelectedKey = lastSelectedKey;
    }
  });
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => access(local.selectionMode) === "multiple",
    isVirtualized: () => local.virtualized ?? false,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    allowsEmptyCollection: () => local.allowsEmptyCollection ?? false,
    shouldFocusWrap: () => local.shouldFocusWrap ?? false,
    removeOnBackspace: () => local.removeOnBackspace ?? true,
    selectedOptions,
    isInputFocused,
    contentPresence,
    autoFocus: focusStrategy,
    inputValue,
    triggerMode: () => local.triggerMode,
    activeDescendant,
    controlRef,
    inputRef,
    triggerRef,
    contentRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    listboxId,
    triggerAriaLabel: () => local.translations?.triggerLabel,
    listboxAriaLabel: () => local.translations?.listboxLabel,
    setIsInputFocused,
    resetInputValue,
    setInputValue,
    setControlRef,
    setInputRef,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    placeholder: () => local.placeholder,
    renderItem,
    renderSection,
    removeOptionFromSelection,
    onInputKeyDown: e => selectableCollection.onKeyDown(e),
    generateId: createGenerateId(() => access(formControlProps.id)),
    registerListboxId: createRegisterId(setListboxId)
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(ComboboxContext.Provider, {
        value: context,
        get children() {
          return createComponent(PopperRoot, mergeProps$1({
            anchorRef: controlRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return createComponent(Polymorphic, mergeProps$1({
                as: "div",
                role: "group",
                get id() {
                  return access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

function ComboboxRoot(props) {
  const [local, others] = splitProps(props, ["value", "defaultValue", "onChange", "multiple"]);
  const value = createMemo(() => {
    if (local.value != null) {
      return local.multiple ? local.value : [local.value];
    }
    return local.value;
  });
  const defaultValue = createMemo(() => {
    if (local.defaultValue != null) {
      return local.multiple ? local.defaultValue : [local.defaultValue];
    }
    return local.defaultValue;
  });
  const onChange = value => {
    if (local.multiple) {
      local.onChange?.(value);
    } else {
      local.onChange?.(value[0] ?? null);
    }
  };
  return createComponent(ComboboxBase, mergeProps$1({
    get value() {
      return value();
    },
    get defaultValue() {
      return defaultValue();
    },
    onChange: onChange,
    get selectionMode() {
      return local.multiple ? "multiple" : "single";
    }
  }, others));
}

function ComboboxTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "disabled", "onPointerDown", "onClick", "aria-labelledby"]);
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
      e.preventDefault();
      context.toggle(false, "manual");
    }
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    if (!isDisabled()) {
      if (e.currentTarget.dataset.pointerType === "touch") {
        context.toggle(false, "manual");
      }
      context.inputRef()?.focus();
    }
  };
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, context.triggerAriaLabel(), local["aria-labelledby"]);
  };
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get disabled() {
      return isDisabled();
    },
    tabIndex: "-1",
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return context.triggerAriaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$l = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: ComboboxContent,
	Control: ComboboxControl,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	HiddenSelect: ComboboxHiddenSelect,
	Icon: ComboboxIcon,
	Input: ComboboxInput,
	Item: ListboxItem,
	ItemDescription: ListboxItemDescription,
	ItemIndicator: ListboxItemIndicator,
	ItemLabel: ListboxItemLabel,
	Label: FormControlLabel,
	Listbox: ComboboxListbox,
	Portal: ComboboxPortal,
	Root: ComboboxRoot,
	Section: ListboxSection,
	Trigger: ComboboxTrigger
});

const MenuContext = createContext();
function useOptionalMenuContext() {
  return useContext(MenuContext);
}
function useMenuContext() {
  const context = useOptionalMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuContext` must be used within a `Menu` component");
  }
  return context;
}

const MenuRootContext = createContext();
function useMenuRootContext() {
  const context = useContext(MenuRootContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRootContext` must be used within a `MenuRoot` component");
  }
  return context;
}

function getPointerGraceArea(placement, event, contentEl) {
  const basePlacement = placement.split("-")[0];
  const contentRect = contentEl.getBoundingClientRect();
  const polygon = [];
  const pointerX = event.clientX;
  const pointerY = event.clientY;
  switch (basePlacement) {
    case "top":
      polygon.push([pointerX, pointerY + 5]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      break;
    case "right":
      polygon.push([pointerX - 5, pointerY]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      break;
    case "bottom":
      polygon.push([pointerX, pointerY - 5]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      break;
    case "left":
      polygon.push([pointerX + 5, pointerY]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      break;
  }
  return polygon;
}
function isPointerInGraceArea(event, area) {
  if (!area) {
    return false;
  }
  return isPointInPolygon([event.clientX, event.clientY], area);
}

function Menu(props) {
  const rootContext = useMenuRootContext();
  const parentDomCollectionContext = useOptionalDomCollectionContext();
  const parentMenuContext = useOptionalMenuContext();
  const mergedProps = mergeDefaultProps({
    placement: "bottom-start"
  }, props);
  const [local, others] = splitProps(mergedProps, ["open", "defaultOpen", "onOpenChange"]);
  let pointerGraceTimeoutId = 0;
  let pointerGraceIntent = null;
  let pointerDir = "right";
  const [triggerId, setTriggerId] = createSignal();
  const [contentId, setContentId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [focusStrategy, setFocusStrategy] = createSignal(true);
  const [currentPlacement, setCurrentPlacement] = createSignal(others.placement);
  const [nestedMenus, setNestedMenus] = createSignal([]);
  const [items, setItems] = createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => rootContext.forceMount() || disclosureState.isOpen());
  const listState = createListState({
    selectionMode: "none",
    dataSource: items
  });
  const open = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.open();
  };
  const close = (recursively = false) => {
    disclosureState.close();
    if (recursively && parentMenuContext) {
      parentMenuContext.close(true);
    }
  };
  const toggle = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.toggle();
  };
  const focusContent = () => {
    const content = contentRef();
    if (content) {
      focusWithoutScrolling(content);
      listState.selectionManager().setFocused(true);
      listState.selectionManager().setFocusedKey(undefined);
    }
  };
  const registerNestedMenu = element => {
    setNestedMenus(prev => [...prev, element]);
    const parentUnregister = parentMenuContext?.registerNestedMenu(element);
    return () => {
      setNestedMenus(prev => removeItemFromArray(prev, element));
      parentUnregister?.();
    };
  };
  const isPointerMovingToSubmenu = e => {
    const isMovingTowards = pointerDir === pointerGraceIntent?.side;
    return isMovingTowards && isPointerInGraceArea(e, pointerGraceIntent?.area);
  };
  const onItemEnter = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  const onItemLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    focusContent();
  };
  const onTriggerLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => {
      return !(parentMenuContext == null && disclosureState.isOpen() && rootContext.isModal());
    },
    targets: () => [contentRef(), ...nestedMenus()].filter(Boolean)
  });
  createEffect(() => {
    const contentEl = contentRef();
    if (!contentEl || !parentMenuContext) {
      return;
    }
    const parentUnregister = parentMenuContext.registerNestedMenu(contentEl);
    onCleanup(() => {
      parentUnregister();
    });
  });
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresence,
    nestedMenus,
    currentPlacement,
    pointerGraceTimeoutId: () => pointerGraceTimeoutId,
    autoFocus: focusStrategy,
    listState: () => listState,
    parentMenuContext: () => parentMenuContext,
    triggerRef,
    contentRef,
    triggerId,
    contentId,
    setTriggerRef,
    setContentRef,
    open,
    close,
    toggle,
    focusContent,
    onItemEnter,
    onItemLeave,
    onTriggerLeave,
    setPointerDir: dir => pointerDir = dir,
    setPointerGraceTimeoutId: id => pointerGraceTimeoutId = id,
    setPointerGraceIntent: intent => pointerGraceIntent = intent,
    registerNestedMenu,
    registerItemToParentDomCollection: parentDomCollectionContext?.registerItem,
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(MenuContext.Provider, {
        value: context,
        get children() {
          return createComponent(PopperRoot, mergeProps$1({
            anchorRef: triggerRef,
            contentRef: contentRef,
            onCurrentPlacementChange: setCurrentPlacement
          }, others));
        }
      });
    }
  });
}

const MenuItemContext = createContext();
function useMenuItemContext() {
  const context = useContext(MenuItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuItemContext` must be used within a `Menu.Item` component");
  }
  return context;
}

function MenuItemBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`item-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "textValue", "disabled", "closeOnSelect", "checked", "indeterminate", "onSelect", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [labelRef, setLabelRef] = createSignal();
  const selectionManager = () => menuContext.listState().selectionManager();
  const key = () => others.id;
  const isHighlighted = () => selectionManager().focusedKey() === key();
  const onSelect = () => {
    local.onSelect?.();
    if (local.closeOnSelect) {
      menuContext.close(true);
    }
  };
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    })
  });
  const selectableItem = createSelectableItem({
    key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (local.disabled) {
      menuContext.onItemLeave(e);
    } else {
      menuContext.onItemEnter(e);
      if (!e.defaultPrevented) {
        focusWithoutScrolling(e.currentTarget);
        menuContext.listState().selectionManager().setFocused(true);
        menuContext.listState().selectionManager().setFocusedKey(key());
      }
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    menuContext.onItemLeave(e);
  };
  const onPointerUp = e => {
    callHandler(e, local.onPointerUp);
    if (!local.disabled && e.button === 0) {
      onSelect();
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
        onSelect();
        break;
    }
  };
  const ariaChecked = createMemo(() => {
    if (local.indeterminate) {
      return "mixed";
    }
    if (local.checked == null) {
      return undefined;
    }
    return local.checked;
  });
  const dataset = createMemo(() => ({
    "data-indeterminate": local.indeterminate ? "" : undefined,
    "data-checked": local.checked && !local.indeterminate ? "" : undefined,
    "data-disabled": local.disabled ? "" : undefined,
    "data-highlighted": isHighlighted() ? "" : undefined
  }));
  const context = {
    isChecked: () => local.checked,
    dataset,
    setLabelRef,
    generateId: createGenerateId(() => others.id),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId)
  };
  return createComponent(MenuItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-checked"]() {
          return ariaChecked();
        },
        get ["aria-disabled"]() {
          return local.disabled;
        },
        get ["aria-labelledby"]() {
          return labelId();
        },
        get ["aria-describedby"]() {
          return descriptionId();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return composeEventHandlers([onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove: onPointerMove,
        onPointerLeave: onPointerLeave
      }, dataset, others));
    }
  });
}

function MenuCheckboxItem(props) {
  const mergedProps = mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["checked", "defaultChecked", "onChange", "onSelect"]);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: checked => local.onChange?.(checked),
    isDisabled: () => others.disabled
  });
  const onSelect = () => {
    local.onSelect?.();
    state.toggle();
  };
  return createComponent(MenuItemBase, mergeProps$1({
    role: "menuitemcheckbox",
    get checked() {
      return state.isSelected();
    },
    onSelect: onSelect
  }, others));
}

const MenubarContext = createContext();
function useOptionalMenubarContext() {
  return useContext(MenubarContext);
}
function useMenubarContext() {
  const context = useOptionalMenubarContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenubarContext` must be used within a `Menubar` component");
  }
  return context;
}

function MenuContentBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`content-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onEscapeKeyDown", "onFocusOutside", "onPointerEnter", "onPointerMove", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  let lastPointerX = 0;
  const isRootModalContent = () => {
    return context.parentMenuContext() == null && optionalMenubarContext === undefined && rootContext.isModal();
  };
  const selectableList = createSelectableList({
    selectionManager: context.listState().selectionManager,
    collection: context.listState().collection,
    autoFocus: context.autoFocus,
    deferAutoFocus: true,
    shouldFocusWrap: true,
    disallowTypeAhead: () => !context.listState().selectionManager().isFocused()
  }, () => ref);
  createFocusScope({
    trapFocus: () => isRootModalContent() && context.isOpen(),
    onMountAutoFocus: event => {
      if (optionalMenubarContext === undefined) local.onOpenAutoFocus?.(event);
    },
    onUnmountAutoFocus: local.onCloseAutoFocus
  }, () => ref);
  const onKeyDown = e => {
    if (!contains(e.currentTarget, e.target)) {
      return;
    }
    if (e.key === "Tab" && context.isOpen()) {
      e.preventDefault();
    }
    if (optionalMenubarContext !== undefined) {
      if (e.currentTarget.getAttribute("aria-haspopup") !== "true") switch (e.key) {
        case "ArrowRight":
          e.stopPropagation();
          e.preventDefault();
          context.close(true);
          optionalMenubarContext.setAutoFocusMenu(true);
          optionalMenubarContext.nextMenu();
          break;
        case "ArrowLeft":
          if (e.currentTarget.hasAttribute("data-closed")) break;
          e.stopPropagation();
          e.preventDefault();
          context.close(true);
          optionalMenubarContext.setAutoFocusMenu(true);
          optionalMenubarContext.previousMenu();
          break;
      }
    }
  };
  const onEscapeKeyDown = e => {
    local.onEscapeKeyDown?.(e);
    optionalMenubarContext?.setAutoFocusMenu(false);
    context.close(true);
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (rootContext.isModal()) {
      e.preventDefault();
    }
  };
  const onPointerEnter = e => {
    callHandler(e, local.onPointerEnter);
    if (!context.isOpen()) {
      return;
    }
    context.parentMenuContext()?.listState().selectionManager().setFocused(false);
    context.parentMenuContext()?.listState().selectionManager().setFocusedKey(undefined);
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const target = e.target;
    const pointerXHasChanged = lastPointerX !== e.clientX;
    if (contains(e.currentTarget, target) && pointerXHasChanged) {
      context.setPointerDir(e.clientX > lastPointerX ? "right" : "left");
      lastPointerX = e.clientX;
    }
  };
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "menu",
            get id() {
              return local.id;
            },
            get tabIndex() {
              return selectableList.tabIndex();
            },
            get disableOutsidePointerEvents() {
              return memo(() => !!isRootModalContent())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            bypassTopMostLayerCheck: true,
            get style() {
              return {
                "--kb-menu-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.triggerId();
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            },
            get onKeyDown() {
              return composeEventHandlers([local.onKeyDown, selectableList.onKeyDown, onKeyDown]);
            },
            get onMouseDown() {
              return composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
            },
            get onFocusIn() {
              return composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
            },
            get onFocusOut() {
              return composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
            },
            onPointerEnter: onPointerEnter,
            onPointerMove: onPointerMove
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function MenuContent(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["ref"]);
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && rootContext.preventScroll()
  });
  return createComponent(MenuContentBase, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}

const MenuGroupContext = createContext();
function useMenuGroupContext() {
  const context = useContext(MenuGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuGroupContext` must be used within a `Menu.Group` component");
  }
  return context;
}

function MenuGroup(props) {
  const rootContext = useMenuRootContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`group-${createUniqueId()}`)
  }, props);
  const [labelId, setLabelId] = createSignal();
  const context = {
    generateId: createGenerateId(() => mergedProps.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return createComponent(MenuGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        role: "group",
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, mergedProps));
    }
  });
}

function MenuGroupLabel(props) {
  const context = useMenuGroupContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "span",
    get id() {
      return local.id;
    },
    "aria-hidden": "true"
  }, others));
}

function MenuIcon(props) {
  const context = useMenuContext();
  const mergedProps = mergeDefaultProps({
    children: "▼"
  }, props);
  return createComponent(Polymorphic, mergeProps$1({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}

function MenuItem(props) {
  return createComponent(MenuItemBase, mergeProps$1({
    role: "menuitem",
    closeOnSelect: true
  }, props));
}

function MenuItemDescription(props) {
  const context = useMenuItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerDescription(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function MenuItemIndicator(props) {
  const context = useMenuItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(mergedProps, ["forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isChecked();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}

function MenuItemLabel(props) {
  const context = useMenuItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id"]);
  createEffect(() => onCleanup(context.registerLabel(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(context.setLabelRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function MenuPortal(props) {
  const context = useMenuContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

const MenuRadioGroupContext = createContext();
function useMenuRadioGroupContext() {
  const context = useContext(MenuRadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRadioGroupContext` must be used within a `Menu.RadioGroup` component");
  }
  return context;
}

function MenuRadioGroup(props) {
  const rootContext = useMenuRootContext();
  const defaultId = rootContext.generateId(`radiogroup-${createUniqueId()}`);
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "defaultValue", "onChange", "disabled"]);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const context = {
    isDisabled: () => local.disabled,
    isSelectedValue: value => value === selected(),
    setSelectedValue: setSelected
  };
  return createComponent(MenuRadioGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(MenuGroup, others);
    }
  });
}

function MenuRadioItem(props) {
  const context = useMenuRadioGroupContext();
  const mergedProps = mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "onSelect"]);
  const onSelect = () => {
    local.onSelect?.();
    context.setSelectedValue(local.value);
  };
  return createComponent(MenuItemBase, mergeProps$1({
    role: "menuitemradio",
    get checked() {
      return context.isSelectedValue(local.value);
    },
    onSelect: onSelect
  }, others));
}

function MenuRoot(props) {
  const defaultId = `menu-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    modal: true
  }, props);
  const [local, others] = splitProps(mergedProps, ["id", "modal", "preventScroll", "forceMount", "open", "defaultOpen", "onOpenChange", "value"]);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    isModal: () => local.modal ?? true,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    forceMount: () => local.forceMount ?? false,
    generateId: createGenerateId(() => local.id),
    value: () => local.value
  };
  return createComponent(MenuRootContext.Provider, {
    value: context,
    get children() {
      return createComponent(Menu, mergeProps$1({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        }
      }, others));
    }
  });
}

function MenuSub(props) {
  const {
    direction
  } = useLocale();
  return createComponent(Menu, mergeProps$1({
    get placement() {
      return direction() === "rtl" ? "left-start" : "right-start";
    },
    flip: true
  }, props));
}

const SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function MenuSubContent(props) {
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["onFocusOutside", "onKeyDown", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const onOpenAutoFocus = e => {
    e.preventDefault();
  };
  const onCloseAutoFocus = e => {
    e.preventDefault();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    const target = e.target;
    if (!contains(context.triggerRef(), target)) {
      context.close();
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    const isKeyDownInside = contains(e.currentTarget, e.target);
    const isCloseKey = SUB_CLOSE_KEYS[direction()].includes(e.key);
    const isSubMenu = context.parentMenuContext() != null;
    if (isKeyDownInside && isCloseKey && isSubMenu) {
      context.close();
      focusWithoutScrolling(context.triggerRef());
    }
  };
  return createComponent(MenuContentBase, mergeProps$1({
    onOpenAutoFocus: onOpenAutoFocus,
    onCloseAutoFocus: onCloseAutoFocus,
    onFocusOutside: onFocusOutside,
    onKeyDown: onKeyDown
  }, others));
}

const SELECTION_KEYS = ["Enter", " "];
const SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
function MenuSubTrigger(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`sub-trigger-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "textValue", "disabled", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  let openTimeoutId = null;
  const clearOpenTimeout = () => {
    if (isServer) {
      return;
    }
    if (openTimeoutId) {
      window.clearTimeout(openTimeoutId);
    }
    openTimeoutId = null;
  };
  const {
    direction
  } = useLocale();
  const key = () => local.id;
  const parentSelectionManager = () => {
    const parentMenuContext = context.parentMenuContext();
    if (parentMenuContext == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    return parentMenuContext.listState().selectionManager();
  };
  const collection = () => context.listState().collection();
  const isHighlighted = () => parentSelectionManager().focusedKey() === key();
  const selectableItem = createSelectableItem({
    key,
    selectionManager: parentSelectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onClick = e => {
    callHandler(e, local.onClick);
    if (!context.isOpen() && !local.disabled) {
      context.open(true);
    }
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const parentMenuContext = context.parentMenuContext();
    parentMenuContext?.onItemEnter(e);
    if (e.defaultPrevented) {
      return;
    }
    if (local.disabled) {
      parentMenuContext?.onItemLeave(e);
      return;
    }
    if (!context.isOpen() && !openTimeoutId) {
      context.parentMenuContext()?.setPointerGraceIntent(null);
      openTimeoutId = window.setTimeout(() => {
        context.open(false);
        clearOpenTimeout();
      }, 100);
    }
    parentMenuContext?.onItemEnter(e);
    if (!e.defaultPrevented) {
      if (context.listState().selectionManager().isFocused()) {
        context.listState().selectionManager().setFocused(false);
        context.listState().selectionManager().setFocusedKey(undefined);
      }
      focusWithoutScrolling(e.currentTarget);
      parentMenuContext?.listState().selectionManager().setFocused(true);
      parentMenuContext?.listState().selectionManager().setFocusedKey(key());
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    clearOpenTimeout();
    const parentMenuContext = context.parentMenuContext();
    const contentEl = context.contentRef();
    if (contentEl) {
      parentMenuContext?.setPointerGraceIntent({
        area: getPointerGraceArea(context.currentPlacement(), e, contentEl),
        side: context.currentPlacement().split("-")[0]
      });
      window.clearTimeout(parentMenuContext?.pointerGraceTimeoutId());
      const pointerGraceTimeoutId = window.setTimeout(() => {
        parentMenuContext?.setPointerGraceIntent(null);
      }, 300);
      parentMenuContext?.setPointerGraceTimeoutId(pointerGraceTimeoutId);
    } else {
      parentMenuContext?.onTriggerLeave(e);
      if (e.defaultPrevented) {
        return;
      }
      parentMenuContext?.setPointerGraceIntent(null);
    }
    parentMenuContext?.onItemLeave(e);
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    if (SUB_OPEN_KEYS[direction()].includes(e.key)) {
      e.stopPropagation();
      e.preventDefault();
      parentSelectionManager().setFocused(false);
      parentSelectionManager().setFocusedKey(undefined);
      if (!context.isOpen()) {
        context.open("first");
      }
      context.focusContent();
      context.listState().selectionManager().setFocused(true);
      context.listState().selectionManager().setFocusedKey(collection().getFirstKey());
    }
  };
  createEffect(() => {
    if (context.registerItemToParentDomCollection == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    const unregister = context.registerItemToParentDomCollection({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    });
    onCleanup(unregister);
  });
  createEffect(on(() => context.parentMenuContext()?.pointerGraceTimeoutId(), pointerGraceTimer => {
    onCleanup(() => {
      window.clearTimeout(pointerGraceTimer);
      context.parentMenuContext()?.setPointerGraceIntent(null);
    });
  }));
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  onCleanup(() => {
    clearOpenTimeout();
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    role: "menuitem",
    get tabIndex() {
      return selectableItem.tabIndex();
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["aria-disabled"]() {
      return local.disabled;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    },
    get onPointerDown() {
      return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return composeEventHandlers([onClick, selectableItem.onClick]);
    },
    get onKeyDown() {
      return composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    onPointerMove: onPointerMove,
    onPointerLeave: onPointerLeave
  }, () => context.dataset(), others));
}

function MenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "disabled", "onPointerDown", "onClick", "onKeyDown", "onMouseOver", "onFocus"]);
  let key;
  if (optionalMenubarContext !== undefined) {
    key = rootContext.value() ?? local.id;
    createEffect(() => {
      optionalMenubarContext.registerMenu(key, [context.contentRef(), ...context.nestedMenus()]);
    });
    createEffect(() => {
      if (optionalMenubarContext.value() === key) {
        context.triggerRef()?.focus();
        if (optionalMenubarContext.autoFocusMenu()) context.open(true);
      } else context.close(true);
    });
    createEffect(() => {
      if (context.isOpen()) optionalMenubarContext.setValue(key);
    });
    onCleanup(() => {
      optionalMenubarContext.unregisterMenu(key);
    });
    if (optionalMenubarContext.lastValue() === undefined) optionalMenubarContext.setLastValue(key);
  }
  const handleClick = () => {
    optionalMenubarContext?.setAutoFocusMenu(true);
    if (optionalMenubarContext !== undefined) context.toggle(false);else context.toggle(true);
    if (optionalMenubarContext !== undefined && !context.isOpen() && optionalMenubarContext.value() === key) {
      optionalMenubarContext.closeMenu();
    }
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!local.disabled && e.pointerType !== "touch" && e.button === 0) {
      handleClick();
    }
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    if (!local.disabled) {
      if (e.currentTarget.dataset.pointerType === "touch") handleClick();
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (local.disabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        scrollIntoViewport(e.currentTarget);
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowRight":
        if (optionalMenubarContext === undefined) break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.nextMenu();
        break;
      case "ArrowLeft":
        if (optionalMenubarContext === undefined) break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.previousMenu();
        break;
    }
  };
  const onMouseOver = e => {
    callHandler(e, local.onMouseOver);
    if (!local.disabled && optionalMenubarContext !== undefined && optionalMenubarContext.value() !== undefined) {
      optionalMenubarContext.setValue(key);
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (optionalMenubarContext !== undefined) optionalMenubarContext.setValue(key);
  };
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get disabled() {
      return local.disabled;
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-highlighted"]() {
      return key !== undefined && optionalMenubarContext?.value() === key ? true : undefined;
    },
    get tabIndex() {
      return optionalMenubarContext !== undefined ? optionalMenubarContext.value() === key || optionalMenubarContext.lastValue() === key ? 0 : -1 : undefined;
    },
    onPointerDown: onPointerDown,
    onMouseOver: onMouseOver,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    role: optionalMenubarContext !== undefined ? "menuitem" : undefined
  }, () => context.dataset(), others));
}

function SeparatorRoot(props) {
  let ref;
  const mergedProps = mergeDefaultProps({
    orientation: "horizontal"
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "orientation"]);
  const tagName = createTagName(() => ref, () => "hr");
  return createComponent(Polymorphic, mergeProps$1({
    as: "hr",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "hr" ? "separator" : undefined;
    },
    get ["aria-orientation"]() {
      return local.orientation === "vertical" ? "vertical" : undefined;
    },
    get ["data-orientation"]() {
      return local.orientation;
    }
  }, others));
}

var index$k = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: SeparatorRoot
});

function ContextMenuContent(props) {
  const rootContext = useMenuRootContext();
  const [local, others] = splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!e.defaultPrevented && hasInteractedOutside) {
      e.preventDefault();
    }
    hasInteractedOutside = false;
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented && !rootContext.isModal()) {
      hasInteractedOutside = true;
    }
  };
  return createComponent(MenuContent, mergeProps$1({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
}

const ContextMenuContext = createContext();
function useOptionalContextMenuContext() {
  return useContext(ContextMenuContext);
}
function useContextMenuContext() {
  const context = useOptionalContextMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useContextMenuContext` must be used within a `ContextMenu` component");
  }
  return context;
}

function ContextMenuRoot(props) {
  const defaultId = `contextmenu-${createUniqueId()}`;
  const {
    direction
  } = useLocale();
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    placement: direction() === "rtl" ? "left-start" : "right-start",
    gutter: 2,
    shift: 2
  }, props);
  const [local, others] = splitProps(mergedProps, ["onOpenChange"]);
  const [anchorRect, setAnchorRect] = createSignal({
    x: 0,
    y: 0
  });
  const disclosureState = createDisclosureState({
    defaultOpen: false,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    setAnchorRect
  };
  return createComponent(ContextMenuContext.Provider, {
    value: context,
    get children() {
      return createComponent(MenuRoot, mergeProps$1({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        },
        getAnchorRect: anchorRect
      }, others));
    }
  });
}

function ContextMenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const context = useContextMenuContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style", "disabled", "onContextMenu", "onPointerDown", "onPointerMove", "onPointerCancel", "onPointerUp"]);
  let longPressTimoutId = 0;
  const clearLongPressTimeout = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(longPressTimoutId);
  };
  onCleanup(() => {
    clearLongPressTimeout();
  });
  const onContextMenu = e => {
    if (local.disabled) {
      callHandler(e, local.onContextMenu);
      return;
    }
    clearLongPressTimeout();
    e.preventDefault();
    e.stopPropagation();
    context.setAnchorRect({
      x: e.clientX,
      y: e.clientY
    });
    if (menuContext.isOpen()) {
      menuContext.focusContent();
    } else {
      menuContext.open(true);
    }
  };
  const isTouchOrPen = e => e.pointerType === "touch" || e.pointerType === "pen";
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
      context.setAnchorRect({
        x: e.clientX,
        y: e.clientY
      });
      longPressTimoutId = window.setTimeout(() => menuContext.open(false), 700);
    }
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  const onPointerCancel = e => {
    callHandler(e, local.onPointerCancel);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  const onPointerUp = e => {
    callHandler(e, local.onPointerUp);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(menuContext.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get style() {
      return {
        "-webkit-touch-callout": "none",
        ...local.style
      };
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    },
    onContextMenu: onContextMenu,
    onPointerDown: onPointerDown,
    onPointerMove: onPointerMove,
    onPointerCancel: onPointerCancel,
    onPointerUp: onPointerUp
  }, () => menuContext.dataset(), others));
}

var index$j = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	CheckboxItem: MenuCheckboxItem,
	Content: ContextMenuContent,
	Group: MenuGroup,
	GroupLabel: MenuGroupLabel,
	Icon: MenuIcon,
	Item: MenuItem,
	ItemDescription: MenuItemDescription,
	ItemIndicator: MenuItemIndicator,
	ItemLabel: MenuItemLabel,
	Portal: MenuPortal,
	RadioGroup: MenuRadioGroup,
	RadioItem: MenuRadioItem,
	Root: ContextMenuRoot,
	Separator: SeparatorRoot,
	Sub: MenuSub,
	SubContent: MenuSubContent,
	SubTrigger: MenuSubTrigger,
	Trigger: ContextMenuTrigger
});

const DatePickerContext = createContext();
function useDatePickerContext() {
  const context = useContext(DatePickerContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDatePickerContext` must be used within a `DatePicker` component");
  }
  return context;
}

function DatePickerCalendar(props) {
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("calendar")
  }, props);
  return createComponent(CalendarRoot, mergeProps$1({
    autoFocus: true,
    get selectionMode() {
      return context.selectionMode();
    },
    get value() {
      return context.dateValue();
    },
    get onChange() {
      return context.setDateValue;
    },
    get locale() {
      return context.locale();
    },
    get createCalendar() {
      return context.createCalendar;
    },
    get isDateUnavailable() {
      return context.isDateUnavailable;
    },
    get visibleDuration() {
      return context.visibleDuration();
    },
    get allowsNonContiguousRanges() {
      return context.allowsNonContiguousRanges();
    },
    get defaultFocusedValue() {
      return memo(() => !!context.dateValue())() ? undefined : context.placeholderValue();
    },
    get minValue() {
      return context.minValue();
    },
    get maxValue() {
      return context.maxValue();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readOnly() {
      return formControlContext.isReadOnly();
    },
    get validationState() {
      return context.validationState();
    }
  }, mergedProps));
}

function DatePickerContent(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "aria-labelledby"]);
  let isRightClickOutside = false;
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(context.triggerId(), others["aria-label"], local["aria-labelledby"]);
  };
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      if (!isRightClickOutside) {
        focusWithoutScrolling(context.triggerRef());
      }
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          focusWithoutScrolling(context.triggerRef());
        }
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.isModal()) {
      isRightClickOutside = e.detail.isContextMenu;
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.isModal()) {
      return;
    }
    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }
    if (contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isModal() && context.isOpen()),
    targets: () => {
      const excludedElements = [];
      if (ref) {
        excludedElements.push(ref);
      }
      const controlEl = context.controlRef();
      if (controlEl) {
        excludedElements.push(controlEl);
      }
      return excludedElements;
    }
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isModal() && context.isOpen()
  });
  createFocusScope({
    trapFocus: () => context.isModal() && context.isOpen(),
    onMountAutoFocus: e => {
      e.preventDefault();
    },
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  createEffect(() => onCleanup(context.registerContentId(others.id)));
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "dialog",
            tabIndex: -1,
            get disableOutsidePointerEvents() {
              return memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.controlRef];
            },
            get style() {
              return {
                "--kb-date-picker-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return ariaLabelledBy();
            },
            onPointerDownOutside: onPointerDownOutside,
            onFocusOutside: onFocusOutside,
            onInteractOutside: onInteractOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function DatePickerControl(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "onPointerDown", "onClick", "onKeyDown", "aria-labelledby"]);
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, others["aria-label"], local["aria-labelledby"]);
  };
  const focusLast = () => {
    if (!ref) {
      return;
    }
    let target = getWindow(ref).event?.target;
    const walker = getFocusableTreeWalker(ref, {
      tabbable: true
    });
    if (target) {
      walker.currentNode = target;
      target = walker.previousNode();
    }
    if (!target) {
      let last;
      do {
        last = walker.lastChild();
        if (last) {
          target = last;
        }
      } while (last);
    }
    while (target?.hasAttribute("data-placeholder")) {
      const prev = walker.previousNode();
      if (prev?.hasAttribute("data-placeholder")) {
        target = prev;
      } else {
        break;
      }
    }
    if (target) {
      target.focus();
    }
  };
  let pointerDownType = null;
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    pointerDownType = e.pointerType;
    if (e.pointerType === "mouse") {
      focusLast();
    }
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    if (pointerDownType !== "mouse") {
      focusLast();
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.altKey && (e.key === "ArrowDown" || e.key === "ArrowUp")) {
      e.preventDefault();
      e.stopPropagation();
      context.open();
    }
    switch (e.key) {
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        if (context.direction() === "rtl") {
          context.focusManager().focusNext();
        } else {
          context.focusManager().focusPrevious();
        }
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        if (context.direction() === "rtl") {
          context.focusManager().focusPrevious();
        } else {
          context.focusManager().focusNext();
        }
        break;
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    role: "group",
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        context.setControlRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["aria-disabled"]() {
      return context.isDisabled() || undefined;
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return context.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const DatePickerInputContext = createContext();
function useDatePickerInputContext() {
  const context = useContext(DatePickerInputContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDatePickerInputContext` must be used within a `DatePicker.Input` component");
  }
  return context;
}

const DEFAULT_FIELD_OPTIONS = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  second: "2-digit"
};
const TWO_DIGIT_FIELD_OPTIONS = {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
};
function getDateFieldFormatOptions(fieldOptions, options) {
  const defaultFieldOptions = options.shouldForceLeadingZeros ? TWO_DIGIT_FIELD_OPTIONS : DEFAULT_FIELD_OPTIONS;
  const finalFieldOptions = {
    ...defaultFieldOptions,
    ...fieldOptions
  };
  const granularity = options.granularity || "minute";
  const keys = Object.keys(finalFieldOptions);
  let startIdx = keys.indexOf(options.maxGranularity ?? "year");
  if (startIdx < 0) {
    startIdx = 0;
  }
  let endIdx = keys.indexOf(granularity);
  if (endIdx < 0) {
    endIdx = 2;
  }
  if (startIdx > endIdx) {
    throw new Error("maxGranularity must be greater than granularity");
  }
  const opts = keys.slice(startIdx, endIdx + 1).reduce((opts, key) => {
    opts[key] = finalFieldOptions[key];
    return opts;
  }, {});
  if (options.hourCycle != null) {
    opts.hour12 = options.hourCycle === 12;
  }
  opts.timeZone = options.timeZone || "UTC";
  const hasTime = granularity === "hour" || granularity === "minute" || granularity === "second";
  if (hasTime && options.timeZone && !options.hideTimeZone) {
    opts.timeZoneName = "short";
  }
  if (options.showEra && startIdx === 0) {
    opts.era = "short";
  }
  return opts;
}
function getPlaceholderTime(placeholderValue) {
  if (placeholderValue && "hour" in placeholderValue) {
    return placeholderValue;
  }
  return new Time();
}
function convertValue(value, calendar) {
  if (value === null) {
    return null;
  }
  if (!value) {
    return undefined;
  }
  return toCalendar(value, calendar);
}
function createPlaceholderDate(placeholderValue, granularity, calendar, timeZone) {
  if (placeholderValue) {
    return convertValue(placeholderValue, calendar);
  }
  const date = toCalendar(now(timeZone).set({
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }), calendar);
  if (granularity === "year" || granularity === "month" || granularity === "day") {
    return toCalendarDate(date);
  }
  if (!timeZone) {
    return toCalendarDateTime(date);
  }
  return date;
}
function createDefaultProps(props) {
  let lastValue;
  const value = createMemo(() => {
    const resolvedValue = props.value();
    if (resolvedValue) {
      lastValue = resolvedValue;
    }
    return lastValue;
  });
  const defaultTimeZone = createMemo(() => {
    const resolvedValue = value();
    if (resolvedValue && "timeZone" in resolvedValue) {
      return resolvedValue.timeZone;
    }
    return undefined;
  });
  const granularity = createMemo(() => {
    const resolvedValue = value();
    return props.granularity() || (resolvedValue && "minute" in resolvedValue ? "minute" : "day");
  });
  createEffect(() => {
    const resolvedValue = value();
    const resolvedGranularity = granularity();
    if (resolvedValue && !(resolvedGranularity in resolvedValue)) {
      throw new Error(`Invalid granularity ${resolvedGranularity} for value ${resolvedValue.toString()}`);
    }
  });
  return {
    granularity,
    defaultTimeZone
  };
}

const EDITABLE_SEGMENTS = {
  year: true,
  month: true,
  day: true,
  hour: true,
  minute: true,
  second: true,
  dayPeriod: true,
  era: true
};
const PAGE_STEP = {
  year: 5,
  month: 2,
  day: 7,
  hour: 2,
  minute: 15,
  second: 15
};
const TYPE_MAPPING = {
  dayperiod: "dayPeriod"
};
function DatePickerInput(props) {
  const formControlContext = useFormControlContext();
  const datePickerContext = useDatePickerContext();
  const mergedProps = mergeDefaultProps({
    id: datePickerContext.generateId("input")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "children", "onFocusOut", "aria-labelledby", "aria-describedby"]);
  const timeZone = createMemo(() => datePickerContext.defaultTimeZone() || "UTC");
  const defaultFormatter = createMemo(() => new DateFormatter(datePickerContext.locale()));
  const calendar = createMemo(() => {
    return datePickerContext.createCalendar(defaultFormatter().resolvedOptions().calendar);
  });
  const calendarValue = createMemo(() => {
    if (datePickerContext.selectionMode() === "single") {
      return convertValue(asSingleValue(datePickerContext.dateValue()), calendar());
    }
    if (datePickerContext.selectionMode() === "multiple") ; else if (datePickerContext.selectionMode() === "range") ;
  });
  const [placeholderDate, setPlaceholderDate] = createSignal(createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone()));
  const val = createMemo(() => calendarValue() || placeholderDate());
  const showEra = createMemo(() => calendar().identifier === "gregory" && val()?.era === "BC");
  const formatOpts = createMemo(() => ({
    granularity: datePickerContext.granularity(),
    maxGranularity: datePickerContext.maxGranularity() ?? "year",
    timeZone: datePickerContext.defaultTimeZone(),
    hideTimeZone: datePickerContext.hideTimeZone(),
    hourCycle: datePickerContext.hourCycle(),
    showEra: showEra(),
    shouldForceLeadingZeros: datePickerContext.shouldForceLeadingZeros()
  }));
  const opts = createMemo(() => getDateFieldFormatOptions({}, formatOpts()));
  const dateFormatter = createMemo(() => new DateFormatter(datePickerContext.locale(), opts()));
  const resolvedOptions = createMemo(() => dateFormatter().resolvedOptions());
  const ariaLabelledBy = createMemo(() => {
    return formControlContext.getAriaLabelledBy(others.id, others["aria-label"], local["aria-labelledby"]);
  });
  const ariaDescribedBy = createMemo(() => {
    return [local["aria-describedby"], datePickerContext.ariaDescribedBy()].filter(Boolean).join(" ");
  });
  const allSegments = createMemo(() => {
    return dateFormatter().formatToParts(new Date()).filter(segment => EDITABLE_SEGMENTS[segment.type]).reduce((acc, segment) => {
      acc[segment.type] = true;
      return acc;
    }, {});
  });
  const [validSegments, setValidSegments] = createSignal(datePickerContext.value() ? {
    ...allSegments()
  } : {});
  const displayValue = createMemo(() => {
    return calendarValue() && Object.keys(validSegments()).length >= Object.keys(allSegments()).length ? calendarValue() : placeholderDate();
  });
  const setValue = newValue => {
    if (formControlContext.isDisabled() || formControlContext.isReadOnly()) {
      return;
    }
    if (datePickerContext.selectionMode() === "single") {
      if (Object.keys(validSegments()).length >= Object.keys(allSegments()).length) {
        const v = asSingleValue(datePickerContext.value() || datePickerContext.placeholderValue());
        datePickerContext.setDateValue(toCalendar(newValue, v?.calendar || new GregorianCalendar()));
      } else {
        setPlaceholderDate(newValue);
      }
    } else if (datePickerContext.selectionMode() === "multiple") ; else if (datePickerContext.selectionMode() === "range") ;
  };
  const dateValue = createMemo(() => displayValue()?.toDate(timeZone()));
  const segments = createMemo(() => {
    const resolvedDateValue = dateValue();
    const resolvedDisplayValue = displayValue();
    if (!resolvedDateValue || !resolvedDisplayValue) {
      return [];
    }
    return dateFormatter().formatToParts(resolvedDateValue).map(segment => {
      const isOriginallyEditable = EDITABLE_SEGMENTS[segment.type];
      let isEditable = isOriginallyEditable;
      if (segment.type === "era" && calendar().getEras().length === 1) {
        isEditable = false;
      }
      const isPlaceholder = isOriginallyEditable && !validSegments()[segment.type];
      const placeholder = isOriginallyEditable ? getPlaceholder(datePickerContext.translations(), segment.type, segment.value) : null;
      return {
        type: TYPE_MAPPING[segment.type] || segment.type,
        text: isPlaceholder ? placeholder : segment.value,
        ...getSegmentLimits(resolvedDisplayValue, segment.type, resolvedOptions()),
        isPlaceholder,
        placeholder,
        isEditable
      };
    });
  });
  const markValid = part => {
    setValidSegments(prev => {
      const newValue = {
        ...prev,
        [part]: true
      };
      if (part === "year" && allSegments().era) {
        newValue.era = true;
      }
      return newValue;
    });
  };
  const adjustSegment = (type, amount) => {
    const resolvedDisplayValue = displayValue();
    if (!validSegments()[type]) {
      markValid(type);
      if (resolvedDisplayValue && Object.keys(validSegments()).length >= Object.keys(allSegments()).length) {
        setValue(resolvedDisplayValue);
      }
    } else if (resolvedDisplayValue) {
      const newValue = addSegment(resolvedDisplayValue, type, amount, resolvedOptions());
      if (newValue) {
        setValue(newValue);
      }
    }
  };
  const increment = part => {
    adjustSegment(part, 1);
  };
  const decrement = part => {
    adjustSegment(part, -1);
  };
  const incrementPage = part => {
    adjustSegment(part, PAGE_STEP[part] || 1);
  };
  const decrementPage = part => {
    adjustSegment(part, -(PAGE_STEP[part] || 1));
  };
  const setSegment = (part, value) => {
    markValid(part);
    const resolvedDisplayValue = displayValue();
    if (resolvedDisplayValue) {
      const newValue = setSegmentBase(resolvedDisplayValue, part, value, resolvedOptions());
      if (newValue) {
        setValue(newValue);
      }
    }
  };
  const clearSegment = part => {
    setValidSegments(prev => {
      const newValue = {
        ...prev
      };
      delete newValue[part];
      return newValue;
    });
    const placeholder = createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone());
    const resolvedDisplayValue = displayValue();
    let value = resolvedDisplayValue;
    if (resolvedDisplayValue && placeholder) {
      if (part === "dayPeriod" && "hour" in resolvedDisplayValue && "hour" in placeholder) {
        const isPM = resolvedDisplayValue.hour >= 12;
        const shouldBePM = placeholder.hour >= 12;
        if (isPM && !shouldBePM) {
          value = resolvedDisplayValue.set({
            hour: resolvedDisplayValue.hour - 12
          });
        } else if (!isPM && shouldBePM) {
          value = resolvedDisplayValue.set({
            hour: resolvedDisplayValue.hour + 12
          });
        }
      } else if (part in resolvedDisplayValue) {
        value = resolvedDisplayValue.set({
          [part]: placeholder[part]
        });
      }
    }
    datePickerContext.setDateValue(undefined);
    if (value) {
      setValue(value);
    }
  };
  const formatValue = fieldOptions => {
    const resolvedDateValue = dateValue();
    if (!calendarValue() || !resolvedDateValue) {
      return "";
    }
    const formatOptions = getDateFieldFormatOptions(fieldOptions, formatOpts());
    const formatter = new DateFormatter(datePickerContext.locale(), formatOptions);
    return formatter.format(resolvedDateValue);
  };
  const onFocusOut = e => {
    callHandler(e, local.onFocusOut);
    if (formControlContext.isDisabled() || formControlContext.isReadOnly()) {
      return;
    }
    const validKeys = Object.keys(validSegments());
    const allKeys = Object.keys(allSegments());
    if (validKeys.length === allKeys.length - 1 && allSegments().dayPeriod && !validSegments().dayPeriod) {
      setValidSegments({
        ...allSegments()
      });
      const resolvedDisplayValue = displayValue();
      if (resolvedDisplayValue) {
        setValue(resolvedDisplayValue.copy());
      }
    }
  };
  createEffect(on([calendar, timeZone, validSegments, () => datePickerContext.placeholderValue(), () => datePickerContext.granularity()], ([calendar, timeZone, validSegments, placeholderValue, granularity]) => {
    setPlaceholderDate(placeholder => {
      return Object.keys(validSegments).length > 0 ? convertValue(placeholder, calendar) : createPlaceholderDate(placeholderValue, granularity, calendar, timeZone);
    });
  }));
  createEffect(() => {
    if (datePickerContext.value() && Object.keys(validSegments()).length < Object.keys(allSegments()).length) {
      setValidSegments({
        ...allSegments()
      });
    }
  });
  createEffect(() => {
    if (datePickerContext.value() == null) {
      setValidSegments({});
      setPlaceholderDate(createPlaceholderDate(datePickerContext.placeholderValue(), datePickerContext.granularity(), calendar(), timeZone()));
    }
  });
  createEffect(() => {
    if (allSegments().era && validSegments().year && !validSegments().era) {
      setValidSegments(prev => ({
        ...prev,
        era: true
      }));
    } else if (!allSegments().era && validSegments().era) {
      setValidSegments(prev => {
        const newValue = {
          ...prev
        };
        newValue.era = undefined;
        return newValue;
      });
    }
  });
  const context = {
    calendar,
    dateValue,
    dateFormatterResolvedOptions: resolvedOptions,
    ariaLabel: () => others["aria-label"],
    ariaLabelledBy,
    ariaDescribedBy,
    segments,
    increment,
    decrement,
    incrementPage,
    decrementPage,
    setSegment,
    clearSegment,
    formatValue
  };
  return createComponent(DatePickerInputContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        role: "presentation",
        ref(r$) {
          const _ref$ = mergeRefs(el => el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        onFocusOut: onFocusOut,
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        }
      }, () => datePickerContext.dataset(), () => formControlContext.dataset(), others, {
        get children() {
          return createComponent(Index, {
            get each() {
              return segments();
            },
            children: segment => local.children?.(segment)
          });
        }
      }));
    }
  });
}
function getSegmentLimits(date, type, options) {
  switch (type) {
    case "era":
      {
        const eras = date.calendar.getEras();
        return {
          value: eras.indexOf(date.era),
          minValue: 0,
          maxValue: eras.length - 1
        };
      }
    case "year":
      return {
        value: date.year,
        minValue: 1,
        maxValue: date.calendar.getYearsInEra(date)
      };
    case "month":
      return {
        value: date.month,
        minValue: getMinimumMonthInYear(date),
        maxValue: date.calendar.getMonthsInYear(date)
      };
    case "day":
      return {
        value: date.day,
        minValue: getMinimumDayInMonth(date),
        maxValue: date.calendar.getDaysInMonth(date)
      };
  }
  if ("hour" in date) {
    switch (type) {
      case "dayPeriod":
        return {
          value: date.hour >= 12 ? 12 : 0,
          minValue: 0,
          maxValue: 12
        };
      case "hour":
        if (options.hour12) {
          const isPM = date.hour >= 12;
          return {
            value: date.hour,
            minValue: isPM ? 12 : 0,
            maxValue: isPM ? 23 : 11
          };
        }
        return {
          value: date.hour,
          minValue: 0,
          maxValue: 23
        };
      case "minute":
        return {
          value: date.minute,
          minValue: 0,
          maxValue: 59
        };
      case "second":
        return {
          value: date.second,
          minValue: 0,
          maxValue: 59
        };
    }
  }
  return {};
}
function addSegment(value, part, amount, options) {
  switch (part) {
    case "era":
    case "year":
    case "month":
    case "day":
      return value.cycle(part, amount, {
        round: part === "year"
      });
  }
  if ("hour" in value) {
    switch (part) {
      case "dayPeriod":
        {
          const hours = value.hour;
          const isPM = hours >= 12;
          return value.set({
            hour: isPM ? hours - 12 : hours + 12
          });
        }
      case "hour":
      case "minute":
      case "second":
        return value.cycle(part, amount, {
          round: part !== "hour",
          hourCycle: options.hour12 ? 12 : 24
        });
    }
  }
}
function setSegmentBase(value, part, segmentValue, options) {
  switch (part) {
    case "day":
    case "month":
    case "year":
    case "era":
      return value.set({
        [part]: segmentValue
      });
  }
  if ("hour" in value) {
    switch (part) {
      case "dayPeriod":
        {
          const hours = value.hour;
          const wasPM = hours >= 12;
          const isPM = segmentValue >= 12;
          if (isPM === wasPM) {
            return value;
          }
          return value.set({
            hour: wasPM ? hours - 12 : hours + 12
          });
        }
      case "hour":
        if (options.hour12) {
          const hours = value.hour;
          const wasPM = hours >= 12;
          if (!wasPM && segmentValue === 12) {
            segmentValue = 0;
          }
          if (wasPM && segmentValue < 12) {
            segmentValue += 12;
          }
        }
        return value.set({
          [part]: segmentValue
        });
      case "minute":
      case "second":
        return value.set({
          [part]: segmentValue
        });
    }
  }
}
function getPlaceholder(translations, field, value) {
  if (field === "era" || field === "dayPeriod") {
    return value;
  }
  if (field === "year" || field === "month" || field === "day") {
    return translations.placeholder[field];
  }
  return "––";
}

function DatePickerPortal(props) {
  const context = useDatePickerContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

const DATE_PICKER_INTL_MESSAGES = {
  era: "era",
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  dayPeriod: "AM/PM",
  calendar: "Calendar",
  startDate: "Start Date",
  endDate: "End Date",
  weekday: "day of the week",
  timeZoneName: "time zone",
  selectedDateDescription: date => `Selected Date: ${date}`,
  selectedRangeDescription: (startDate, endDate) => `Selected Range: ${startDate} to ${endDate}`,
  selectedTimeDescription: time => `Selected Time: ${time}`,
  placeholder: {
    year: "yyyy",
    month: "mm",
    day: "dd"
  }
};

function DatePickerRoot(props) {
  const defaultId = `date-picker-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    visibleDuration: {
      months: 1
    },
    selectionMode: "single",
    maxGranularity: "year",
    hideTimeZone: false,
    shouldForceLeadingZeros: false,
    modal: false,
    gutter: 8,
    sameWidth: false,
    placement: "bottom-start",
    translations: DATE_PICKER_INTL_MESSAGES
  }, props);
  const [local, popperProps, formControlProps, others] = splitProps(mergedProps, ["translations", "locale", "createCalendar", "visibleDuration", "selectionMode", "isDateUnavailable", "allowsNonContiguousRanges", "closeOnSelect", "minValue", "maxValue", "placeholderValue", "hourCycle", "granularity", "maxGranularity", "hideTimeZone", "shouldForceLeadingZeros", "validationState", "open", "defaultOpen", "onOpenChange", "value", "defaultValue", "onChange", "modal", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [triggerId, setTriggerId] = createSignal();
  const [contentId, setContentId] = createSignal();
  const [controlRef, setControlRef] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const locale = createMemo(() => {
    return local.locale ?? useLocale().locale();
  });
  const direction = createMemo(() => {
    return getReadingDirection(locale());
  });
  const focusManager = createFocusManager(controlRef);
  const closeOnSelect = createMemo(() => {
    return local.closeOnSelect ?? local.selectionMode !== "multiple";
  });
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const [selectedDate, setSelectedDate] = createSignal();
  const [selectedTime, setSelectedTime] = createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const {
    granularity,
    defaultTimeZone
  } = createDefaultProps({
    value: () => getFirstValueOfSelection(local.selectionMode, value()) ?? local.placeholderValue,
    granularity: () => local.granularity
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const validationState = createMemo(() => {
    if (local.validationState) {
      return local.validationState;
    }
    const values = getArrayValueOfSelection(local.selectionMode, value());
    if (values.length <= 0) {
      return undefined;
    }
    const isSomeDateInvalid = values.some(date => {
      return local.isDateUnavailable?.(date) || isDateInvalid(date, local.minValue, local.maxValue);
    });
    return isSomeDateInvalid ? "invalid" : undefined;
  });
  const {
    formControlContext
  } = createFormControl(mergeProps(formControlProps, {
    get validationState() {
      return validationState();
    }
  }));
  createFormResetListener(contentRef, () => {
    setValue(local.defaultValue);
  });
  const hasTime = createMemo(() => {
    return granularity() === "hour" || granularity() === "minute" || granularity() === "second";
  });
  const formattedValue = createMemo(() => {
    const firstValue = getFirstValueOfSelection(local.selectionMode, value());
    if (!firstValue) {
      return "";
    }
    const formatOptions = getDateFieldFormatOptions({
      month: "long"
    }, {
      granularity: granularity(),
      timeZone: defaultTimeZone(),
      hideTimeZone: local.hideTimeZone,
      hourCycle: local.hourCycle,
      showEra: firstValue.calendar.identifier === "gregory" && firstValue.era === "BC"
    });
    const dateFormatter = createMemo(() => new DateFormatter(locale(), formatOptions));
    const formatDate = date => {
      return date ? dateFormatter().format(date.toDate(defaultTimeZone() ?? "UTC")) : "";
    };
    let formattedValue;
    if (local.selectionMode === "single") {
      formattedValue = formatDate(asSingleValue(value()));
    } else if (local.selectionMode === "multiple") {
      formattedValue = asArrayValue(value())?.map(formatDate).join(", ");
    } else if (local.selectionMode === "range") ;
    return formattedValue ?? "";
  });
  const ariaDescribedBy = () => {
    let description = "";
    if (local.selectionMode === "single" || local.selectionMode === "multiple") {
      description = local.translations.selectedDateDescription(formattedValue());
    } else if (local.selectionMode === "range") ;
    return formControlContext.getAriaDescribedBy(description);
  };
  const commitSingleValue = (date, time) => {
    setValue("timeZone" in time ? time.set(toCalendarDate(date)) : toCalendarDateTime(date, time));
  };
  const selectDate = newValue => {
    if (local.selectionMode === "single") {
      if (hasTime()) {
        const resolvedSelectedTime = selectedTime();
        if (resolvedSelectedTime || closeOnSelect()) {
          commitSingleValue(newValue, resolvedSelectedTime || getPlaceholderTime(local.placeholderValue));
        } else {
          setSelectedDate(newValue);
        }
      } else {
        setValue(newValue);
      }
      if (closeOnSelect()) {
        disclosureState.close();
      }
    } else if (local.selectionMode === "multiple") {
      setValue(newValue);
    } else if (local.selectionMode === "range") ;
  };
  const selectTime = newValue => {
    if (local.selectionMode === "single") {
      const resolvedSelectedDate = selectedDate();
      if (resolvedSelectedDate && newValue) {
        commitSingleValue(resolvedSelectedDate, newValue);
      } else {
        setSelectedTime(newValue);
      }
    } else if (local.selectionMode === "range") ;
  };
  const close = () => {
    if (local.selectionMode === "single") {
      const resolvedSelectedDate = selectedDate();
      const resolvedSelectedTime = selectedTime();
      if (!value() && resolvedSelectedDate && hasTime()) {
        commitSingleValue(resolvedSelectedDate, resolvedSelectedTime || getPlaceholderTime(local.placeholderValue));
      }
    } else if (local.selectionMode === "range") ;
    disclosureState.close();
  };
  const toggle = () => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      disclosureState.open();
    }
  };
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  createEffect(on(value, value => {
    if (!value) {
      setSelectedDate(undefined);
      setSelectedTime(undefined);
      return;
    }
    if (local.selectionMode === "single") {
      setSelectedDate(value);
      if ("hour" in value) {
        setSelectedTime(value);
      }
    } else if (local.selectionMode === "multiple") {
      setSelectedDate(value);
    } else if (local.selectionMode === "range") ;
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isModal: () => local.modal ?? false,
    contentPresence,
    translations: () => local.translations,
    granularity,
    maxGranularity: () => local.maxGranularity,
    hourCycle: () => local.hourCycle,
    hideTimeZone: () => local.hideTimeZone ?? false,
    defaultTimeZone,
    shouldForceLeadingZeros: () => local.shouldForceLeadingZeros ?? false,
    visibleDuration: () => local.visibleDuration,
    selectionMode: () => local.selectionMode,
    allowsNonContiguousRanges: () => local.allowsNonContiguousRanges ?? false,
    placeholderValue: () => local.placeholderValue,
    minValue: () => local.minValue,
    maxValue: () => local.maxValue,
    focusManager: () => focusManager,
    locale,
    direction,
    ariaDescribedBy,
    validationState,
    value,
    dateValue: selectedDate,
    timeValue: selectedTime,
    triggerId,
    contentId,
    controlRef,
    triggerRef,
    contentRef,
    setControlRef,
    setTriggerRef,
    setContentRef,
    createCalendar: name => local.createCalendar(name),
    isDateUnavailable: date => local.isDateUnavailable?.(date) ?? false,
    setDateValue: selectDate,
    setTimeValue: selectTime,
    open: disclosureState.open,
    close,
    toggle,
    generateId: createGenerateId(() => access(formControlProps.id)),
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(DatePickerContext.Provider, {
        value: context,
        get children() {
          return createComponent(PopperRoot, mergeProps$1({
            anchorRef: controlRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return createComponent(Polymorphic, mergeProps$1({
                as: "div",
                role: "group",
                get id() {
                  return access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

const SPIN_BUTTON_INTL_TRANSLATIONS = {
  empty: "Empty"
};

function SpinButtonRoot(props) {
  const mergedProps = mergeDefaultProps({
    translations: SPIN_BUTTON_INTL_TRANSLATIONS
  }, props);
  const [local, others] = splitProps(mergedProps, ["translations", "ref", "value", "textValue", "minValue", "maxValue", "validationState", "onIncrement", "onIncrementPage", "onDecrement", "onDecrementPage", "onDecrementToMin", "onIncrementToMax", "onKeyDown", "onFocus", "onBlur"]);
  let isFocused = false;
  const textValue = createMemo(() => {
    if (local.textValue === "") {
      return local.translations?.empty;
    }
    return (local.textValue || `${local.value}`).replace("-", "\u2212");
  });
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey || props.readOnly) {
      return;
    }
    switch (e.key) {
      case "PageUp":
        if (local.onIncrementPage) {
          e.preventDefault();
          local.onIncrementPage();
          break;
        }
      case "ArrowUp":
      case "Up":
        if (local.onIncrement) {
          e.preventDefault();
          local.onIncrement();
        }
        break;
      case "PageDown":
        if (local.onDecrementPage) {
          e.preventDefault();
          local.onDecrementPage();
          break;
        }
      case "ArrowDown":
      case "Down":
        if (local.onDecrement) {
          e.preventDefault();
          local.onDecrement();
        }
        break;
      case "Home":
        if (local.onDecrementToMin) {
          e.preventDefault();
          local.onDecrementToMin();
        }
        break;
      case "End":
        if (local.onIncrementToMax) {
          e.preventDefault();
          local.onIncrementToMax();
        }
        break;
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    isFocused = true;
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    isFocused = false;
  };
  createEffect(on(textValue, textValue => {
    if (isFocused) {
      clearAnnouncer("assertive");
      announce(textValue ?? "", "assertive");
    }
  }));
  return createComponent(Polymorphic, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    as: "div",
    role: "spinbutton",
    get ["aria-valuenow"]() {
      return local.value != null && !Number.isNaN(local.value) ? local.value : null;
    },
    get ["aria-valuetext"]() {
      return textValue();
    },
    get ["aria-valuemin"]() {
      return local.minValue;
    },
    get ["aria-valuemax"]() {
      return local.maxValue;
    },
    get ["aria-required"]() {
      return props.required || undefined;
    },
    get ["aria-disabled"]() {
      return props.disabled || undefined;
    },
    get ["aria-readonly"]() {
      return props.readOnly || undefined;
    },
    get ["aria-invalid"]() {
      return local.validationState === "invalid" || undefined;
    },
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
}

function DatePickerSegment(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const datePickerContext = useDatePickerContext();
  const inputContext = useDatePickerInputContext();
  const [local, others] = splitProps(props, ["ref", "segment", "children", "onKeyDown", "onBeforeInput", "onInput", "onFocus"]);
  const [textValue, setTextValue] = createSignal(local.segment.isPlaceholder ? "" : local.segment.text);
  const resolvedChildren = children(() => local.children);
  let enteredKeys = "";
  let composition = "";
  const touchPropOverrides = createMemo(() => {
    return isIOS() || local.segment.type === "timeZoneName" ? {
      role: "textbox",
      "aria-valuemax": undefined,
      "aria-valuemin": undefined,
      "aria-valuetext": undefined,
      "aria-valuenow": undefined
    } : {};
  });
  const firstSegment = createMemo(() => inputContext.segments().find(s => s.isEditable));
  const name = createMemo(() => {
    return local.segment.type === "literal" ? "" : datePickerContext.translations()[local.segment.type];
  });
  const ariaLabel = createMemo(() => {
    return `${name()}${inputContext.ariaLabel() ? `, ${inputContext.ariaLabel()}` : ""}${inputContext.ariaLabelledBy() ? ", " : ""}`;
  });
  const ariaDescribedBy = createMemo(() => {
    if (local.segment !== firstSegment() && formControlContext.validationState() !== "invalid") {
      return undefined;
    }
    return inputContext.ariaDescribedBy();
  });
  const isEditable = createMemo(() => {
    return !formControlContext.isDisabled() && !formControlContext.isReadOnly() && local.segment.isEditable;
  });
  const inputMode = createMemo(() => {
    return formControlContext.isDisabled() || local.segment.type === "dayPeriod" || local.segment.type === "era" || !isEditable() ? undefined : "numeric";
  });
  const filter = createFilter({
    sensitivity: "base"
  });
  const options = createMemo(() => inputContext.dateFormatterResolvedOptions());
  const eraFormatter = createDateFormatter({
    year: "numeric",
    era: "narrow",
    timeZone: "UTC"
  });
  const monthDateFormatter = createDateFormatter(() => ({
    month: "long",
    timeZone: options().timeZone
  }));
  const hourDateFormatter = createDateFormatter(() => ({
    hour: "numeric",
    hour12: options().hour12,
    timeZone: options().timeZone
  }));
  const amPmFormatter = createDateFormatter({
    hour: "numeric",
    hour12: true
  });
  const eras = createMemo(() => {
    if (local.segment.type !== "era") {
      return [];
    }
    const date = toCalendar(new CalendarDate(1, 1, 1), inputContext.calendar());
    const eras = inputContext.calendar().getEras().map(era => {
      const eraDate = date.set({
        year: 1,
        month: 1,
        day: 1,
        era
      }).toDate("UTC");
      const parts = eraFormatter().formatToParts(eraDate);
      const formatted = parts.find(p => p.type === "era")?.value ?? "";
      return {
        era,
        formatted
      };
    });
    const prefixLength = commonPrefixLength(eras.map(era => era.formatted));
    if (prefixLength) {
      for (const era of eras) {
        era.formatted = era.formatted.slice(prefixLength);
      }
    }
    return eras;
  });
  const am = createMemo(() => {
    const date = new Date();
    date.setHours(0);
    return amPmFormatter().formatToParts(date).find(part => part.type === "dayPeriod")?.value ?? "";
  });
  const pm = createMemo(() => {
    const date = new Date();
    date.setHours(12);
    return amPmFormatter().formatToParts(date).find(part => part.type === "dayPeriod")?.value ?? "";
  });
  const numberParser = createMemo(() => {
    return new NumberParser(datePickerContext.locale(), {
      maximumFractionDigits: 0
    });
  });
  const onBackspaceKeyDown = () => {
    if (numberParser().isValidPartialNumber(local.segment.text) && !formControlContext.isReadOnly() && !local.segment.isPlaceholder) {
      const newValue = local.segment.text.slice(0, -1);
      const parsed = numberParser().parse(newValue);
      if (newValue.length === 0 || parsed === 0) {
        inputContext.clearSegment(local.segment.type);
      } else {
        inputContext.setSegment(local.segment.type, parsed);
      }
      enteredKeys = newValue;
    } else if (local.segment.type === "dayPeriod") {
      inputContext.clearSegment(local.segment.type);
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.key === "a" && (isMac() ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
    }
    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {
      return;
    }
    switch (e.key) {
      case "Backspace":
      case "Delete":
        {
          e.preventDefault();
          e.stopPropagation();
          onBackspaceKeyDown();
          break;
        }
    }
  };
  const onInputBase = key => {
    if (formControlContext.isDisabled() || formControlContext.isReadOnly()) {
      return;
    }
    const newValue = enteredKeys + key;
    switch (local.segment.type) {
      case "dayPeriod":
        if (filter.startsWith(am(), key)) {
          inputContext.setSegment("dayPeriod", 0);
        } else if (filter.startsWith(pm(), key)) {
          inputContext.setSegment("dayPeriod", 12);
        } else {
          break;
        }
        datePickerContext.focusManager().focusNext();
        break;
      case "era":
        {
          const matched = eras().find(e => filter.startsWith(e.formatted, key));
          if (matched) {
            inputContext.setSegment("era", +matched.era);
            datePickerContext.focusManager().focusNext();
          }
          break;
        }
      case "day":
      case "hour":
      case "minute":
      case "second":
      case "month":
      case "year":
        {
          if (!numberParser().isValidPartialNumber(newValue)) {
            return;
          }
          let numberValue = numberParser().parse(newValue);
          let segmentValue = numberValue;
          let allowsZero = local.segment.minValue === 0;
          if (local.segment.type === "hour" && inputContext.dateFormatterResolvedOptions().hour12) {
            switch (inputContext.dateFormatterResolvedOptions().hourCycle) {
              case "h11":
                if (numberValue > 11) {
                  segmentValue = numberParser().parse(key);
                }
                break;
              case "h12":
                allowsZero = false;
                if (numberValue > 12) {
                  segmentValue = numberParser().parse(key);
                }
                break;
            }
            if (local.segment.value != null && local.segment.value >= 12 && numberValue > 1) {
              numberValue += 12;
            }
          } else if (local.segment.maxValue != null && numberValue > local.segment.maxValue) {
            segmentValue = numberParser().parse(key);
          }
          if (Number.isNaN(numberValue)) {
            return;
          }
          const shouldSetValue = segmentValue !== 0 || allowsZero;
          if (shouldSetValue) {
            inputContext.setSegment(local.segment.type, segmentValue);
          }
          if (local.segment.maxValue != null && Number(`${numberValue}0`) > local.segment.maxValue || newValue.length >= String(local.segment.maxValue).length) {
            enteredKeys = "";
            if (shouldSetValue) {
              datePickerContext.focusManager().focusNext();
            }
          } else {
            enteredKeys = newValue;
          }
          break;
        }
    }
  };
  const onBeforeInput = e => {
    callHandler(e, local.onBeforeInput);
    e.preventDefault();
    switch (e.inputType) {
      case "deleteContentBackward":
      case "deleteContentForward":
        if (numberParser().isValidPartialNumber(local.segment.text) && !formControlContext.isReadOnly()) {
          onBackspaceKeyDown();
        }
        break;
      case "insertCompositionText":
        if (ref) {
          composition = ref.textContent;
          ref.textContent = ref.textContent;
        }
        break;
      default:
        if (e.data != null) {
          onInputBase(e.data);
        }
        break;
    }
  };
  const onInput = e => {
    callHandler(e, local.onInput);
    const {
      inputType,
      data
    } = e;
    if (ref && data != null) {
      switch (inputType) {
        case "insertCompositionText":
          ref.textContent = composition;
          if (filter.startsWith(am(), data) || filter.startsWith(pm(), data)) {
            onInputBase(data);
          }
          break;
      }
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (ref) {
      enteredKeys = "";
      scrollIntoViewport(ref, {
        containingElement: getScrollParent(ref)
      });
      const selection = getWindow(ref).getSelection();
      selection?.collapse(ref);
    }
  };
  const onIncrement = () => {
    enteredKeys = "";
    inputContext.increment(local.segment.type);
  };
  const onDecrement = () => {
    enteredKeys = "";
    inputContext.decrement(local.segment.type);
  };
  const onIncrementPage = () => {
    enteredKeys = "";
    inputContext.incrementPage(local.segment.type);
  };
  const onDecrementPage = () => {
    enteredKeys = "";
    inputContext.decrementPage(local.segment.type);
  };
  const onDecrementToMin = () => {
    if (local.segment.minValue == null) {
      return;
    }
    enteredKeys = "";
    inputContext.setSegment(local.segment.type, local.segment.minValue);
  };
  const onIncrementToMax = () => {
    if (local.segment.maxValue == null) {
      return;
    }
    enteredKeys = "";
    inputContext.setSegment(local.segment.type, local.segment.maxValue);
  };
  createEffect(() => {
    const resolvedDateValue = inputContext.dateValue();
    if (resolvedDateValue) {
      if (local.segment.type === "month" && !local.segment.isPlaceholder) {
        const monthTextValue = monthDateFormatter().format(resolvedDateValue);
        setTextValue(prev => monthTextValue !== prev ? `${prev} – ${monthTextValue}` : monthTextValue);
      } else if (local.segment.type === "hour" && !local.segment.isPlaceholder) {
        setTextValue(hourDateFormatter().format(resolvedDateValue));
      }
    } else {
      setTextValue(local.segment.isPlaceholder ? "" : local.segment.text);
    }
  });
  createEffect(on([() => ref, () => datePickerContext.focusManager()], ([ref, focusManager]) => {
    const element = ref;
    onCleanup(() => {
      if (getActiveElement(element) === element) {
        const prev = focusManager.focusPrevious();
        if (!prev) {
          focusManager.focusNext();
        }
      }
    });
  }));
  return createComponent(Show, {
    get when() {
      return local.segment.type !== "literal";
    },
    get fallback() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        "aria-hidden": true,
        "data-separator": ""
      }, others, {
        get children() {
          return local.segment.text;
        }
      }));
    },
    get children() {
      return createComponent(SpinButtonRoot, mergeProps$1({
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return formControlContext.isDisabled() ? undefined : 0;
        },
        get value() {
          return local.segment.value;
        },
        get textValue() {
          return textValue();
        },
        get minValue() {
          return local.segment.minValue;
        },
        get maxValue() {
          return local.segment.maxValue;
        },
        get validationState() {
          return formControlContext.validationState();
        },
        get required() {
          return formControlContext.isRequired();
        },
        get disabled() {
          return formControlContext.isDisabled();
        },
        get readOnly() {
          return formControlContext.isReadOnly() || !local.segment.isEditable;
        },
        get contentEditable() {
          return isEditable();
        },
        get inputMode() {
          return inputMode();
        },
        get autocorrect() {
          return isEditable() ? "off" : undefined;
        },
        get autoCapitalize() {
          return isEditable() ? "off" : undefined;
        },
        get spellcheck() {
          return isEditable() ? false : undefined;
        },
        get enterkeyhint() {
          return isEditable() ? "next" : undefined;
        },
        style: {
          "caret-color": "transparent"
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        get ["aria-labelledby"]() {
          return inputContext.ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        },
        get ["data-placeholder"]() {
          return local.segment.isPlaceholder ? "" : undefined;
        },
        onKeyDown: onKeyDown,
        onBeforeInput: onBeforeInput,
        onInput: onInput,
        onFocus: onFocus,
        onIncrement: onIncrement,
        onDecrement: onDecrement,
        onIncrementPage: onIncrementPage,
        onDecrementPage: onDecrementPage,
        onDecrementToMin: onDecrementToMin,
        onIncrementToMax: onIncrementToMax
      }, () => datePickerContext.dataset(), () => formControlContext.dataset(), others, touchPropOverrides, {
        get children() {
          return createComponent(Show, {
            get when() {
              return resolvedChildren();
            },
            get fallback() {
              return local.segment.text;
            },
            get children() {
              return resolvedChildren();
            }
          });
        }
      }));
    }
  });
}
function commonPrefixLength(strings) {
  strings.sort();
  const first = strings[0];
  const last = strings[strings.length - 1];
  for (let i = 0; i < first.length; i++) {
    if (first[i] !== last[i]) {
      return i;
    }
  }
  return 0;
}

function DatePickerTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useDatePickerContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "disabled", "onPointerDown", "onClick", "aria-labelledby"]);
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    e.stopPropagation();
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    e.stopPropagation();
    if (!isDisabled()) {
      context.toggle();
    }
  };
  const ariaLabel = createMemo(() => {
    return context.translations().calendar;
  });
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, ariaLabel(), local["aria-labelledby"]);
  };
  createEffect(() => onCleanup(context.registerTriggerId(others.id)));
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get disabled() {
      return isDisabled();
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["aria-label"]() {
      return ariaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return context.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$i = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Calendar: DatePickerCalendar,
	CalendarBody: CalendarBody,
	CalendarGrid: CalendarGrid,
	CalendarGridBody: CalendarGridBody,
	CalendarGridBodyCell: CalendarGridBodyCell,
	CalendarGridBodyCellTrigger: CalendarGridBodyCellTrigger,
	CalendarGridBodyRow: CalendarGridBodyRow,
	CalendarGridHeader: CalendarGridHeader,
	CalendarGridHeaderCell: CalendarGridHeaderCell,
	CalendarGridHeaderRow: CalendarGridHeaderRow,
	CalendarHeader: CalendarHeader,
	CalendarHeading: CalendarHeading,
	CalendarNextTrigger: CalendarNextTrigger,
	CalendarPrevTrigger: CalendarPrevTrigger,
	Content: DatePickerContent,
	Control: DatePickerControl,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Input: DatePickerInput,
	Portal: DatePickerPortal,
	Root: DatePickerRoot,
	Segment: DatePickerSegment,
	Trigger: DatePickerTrigger
});

function DropdownMenuContent(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!hasInteractedOutside) {
      focusWithoutScrolling(context.triggerRef());
    }
    hasInteractedOutside = false;
    e.preventDefault();
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!rootContext.isModal() || e.detail.isContextMenu) {
      hasInteractedOutside = true;
    }
  };
  return createComponent(MenuContent, mergeProps$1({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
}

function DropdownMenuRoot(props) {
  const defaultId = `dropdownmenu-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  return createComponent(MenuRoot, mergedProps);
}

var index$h = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	CheckboxItem: MenuCheckboxItem,
	Content: DropdownMenuContent,
	Group: MenuGroup,
	GroupLabel: MenuGroupLabel,
	Icon: MenuIcon,
	Item: MenuItem,
	ItemDescription: MenuItemDescription,
	ItemIndicator: MenuItemIndicator,
	ItemLabel: MenuItemLabel,
	Portal: MenuPortal,
	RadioGroup: MenuRadioGroup,
	RadioItem: MenuRadioItem,
	Root: DropdownMenuRoot,
	Separator: SeparatorRoot,
	Sub: MenuSub,
	SubContent: MenuSubContent,
	SubTrigger: MenuSubTrigger,
	Trigger: MenuTrigger
});

const HoverCardContext = createContext();
function useHoverCardContext() {
  const context = useContext(HoverCardContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useHoverCardContext` must be used within a `HoverCard` component");
  }
  return context;
}

function HoverCardContent(props) {
  const context = useHoverCardContext();
  const [local, others] = splitProps(props, ["ref", "style"]);
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            disableOutsidePointerEvents: false,
            get style() {
              return {
                "--kb-hovercard-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function HoverCardPortal(props) {
  const context = useHoverCardContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

function getHoverCardSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

function HoverCardRoot(props) {
  const defaultId = `hovercard-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = splitProps(mergedProps, ["id", "open", "defaultOpen", "onOpenChange", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let openTimeoutId;
  let closeTimeoutId;
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [currentPlacement, setCurrentPlacement] = createSignal(others.placement);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const {
    addGlobalListener,
    removeGlobalListener
  } = createGlobalListeners();
  const openWithDelay = () => {
    if (isServer) {
      return;
    }
    openTimeoutId = window.setTimeout(() => {
      openTimeoutId = undefined;
      disclosureState.open();
    }, local.openDelay);
  };
  const closeWithDelay = () => {
    if (isServer) {
      return;
    }
    closeTimeoutId = window.setTimeout(() => {
      closeTimeoutId = undefined;
      disclosureState.close();
    }, local.closeDelay);
  };
  const cancelOpening = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(openTimeoutId);
    openTimeoutId = undefined;
  };
  const cancelClosing = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnHoverCard = target => {
    return contains(triggerRef(), target) || contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getHoverCardSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;
    if (isTargetOnHoverCard(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());
      if (polygon && isPointInPolygon(getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }
    if (closeTimeoutId) {
      return;
    }
    closeWithDelay();
  };
  createEffect(() => {
    if (!disclosureState.isOpen()) {
      return;
    }
    addGlobalListener(document, "pointermove", onHoverOutside, true);
    onCleanup(() => {
      removeGlobalListener(document, "pointermove", onHoverOutside, true);
    });
  });
  onCleanup(() => {
    cancelOpening();
    cancelClosing();
  });
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresence,
    openWithDelay,
    closeWithDelay,
    cancelOpening,
    cancelClosing,
    close: disclosureState.close,
    isTargetOnHoverCard,
    setTriggerRef,
    setContentRef
  };
  return createComponent(HoverCardContext.Provider, {
    value: context,
    get children() {
      return createComponent(PopperRoot, mergeProps$1({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
}

function HoverCardTrigger(props) {
  const context = useHoverCardContext();
  const [local, others] = splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onFocus", "onBlur", "onTouchStart"]);
  const onPointerEnter = e => {
    callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || others.disabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }
    context.cancelOpening();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (others.disabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.cancelOpening();
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnHoverCard(relatedTarget)) {
      return;
    }
    context.closeWithDelay();
  };
  onCleanup(context.cancelOpening);
  return createComponent(LinkRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), others));
}

var index$g = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: HoverCardContent,
	Portal: HoverCardPortal,
	Root: HoverCardRoot,
	Trigger: HoverCardTrigger
});

const ImageContext = createContext();
function useImageContext() {
  const context = useContext(ImageContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useImageContext` must be used within an `Image.Root` component");
  }
  return context;
}

function ImageFallback(props) {
  const context = useImageContext();
  const [canRender, setCanRender] = createSignal(context.fallbackDelay() === undefined);
  createEffect(() => {
    const delayMs = context.fallbackDelay();
    if (delayMs !== undefined) {
      const timerId = window.setTimeout(() => setCanRender(true), delayMs);
      onCleanup(() => window.clearTimeout(timerId));
    }
  });
  return createComponent(Show, {
    get when() {
      return memo(() => !!canRender())() && context.imageLoadingStatus() !== "loaded";
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "span"
      }, props));
    }
  });
}

const _tmpl$$e = /*#__PURE__*/template(`<img>`);
function ImageImg(props) {
  const context = useImageContext();
  const [loadingStatus, setLoadingStatus] = createSignal("idle");
  createEffect(on(() => props.src, src => {
    if (!src) {
      setLoadingStatus("error");
      return;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = status => () => {
      if (!isMounted) {
        return;
      }
      setLoadingStatus(status);
    };
    setLoadingStatus("loading");
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = src;
    onCleanup(() => {
      isMounted = false;
    });
  }));
  createEffect(() => {
    const imageLoadingStatus = loadingStatus();
    if (imageLoadingStatus !== "idle") {
      context.onImageLoadingStatusChange(imageLoadingStatus);
    }
  });
  return createComponent(Show, {
    get when() {
      return loadingStatus() === "loaded";
    },
    get children() {
      const _el$ = _tmpl$$e();
      spread(_el$, props, false, false);
      return _el$;
    }
  });
}

function ImageRoot(props) {
  const [local, others] = splitProps(props, ["fallbackDelay", "onLoadingStatusChange"]);
  const [imageLoadingStatus, setImageLoadingStatus] = createSignal("idle");
  const context = {
    fallbackDelay: () => local.fallbackDelay,
    imageLoadingStatus,
    onImageLoadingStatusChange: status => {
      setImageLoadingStatus(status);
      local.onLoadingStatusChange?.(status);
    }
  };
  return createComponent(ImageContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "span"
      }, others));
    }
  });
}

var index$f = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Fallback: ImageFallback,
	Img: ImageImg,
	Root: ImageRoot
});

function MenubarMenu(props) {
  const menubarContext = useMenubarContext();
  const mergedProps = mergeDefaultProps({
    modal: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["value"]);
  const uniqueid = createUniqueId();
  const defaultId = menubarContext.generateId(`menubar-menu-${uniqueid}`);
  const mergedPropsWithId = mergeDefaultProps({
    id: defaultId
  }, mergedProps);
  return createComponent(MenuRoot, mergeProps$1({
    get value() {
      return local.value ?? uniqueid;
    }
  }, mergedPropsWithId));
}

function MenubarRoot(props) {
  let ref;
  const defaultId = `menubar-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    loop: true
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onValueChange", "loop", "focusOnAlt"]);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onValueChange?.(value)
  });
  const [lastValue, setLastValue] = createSignal();
  const [menuRefs, setMenuRefs] = createSignal(new Map());
  const dataset = createMemo(() => ({
    "data-expanded": value() !== undefined ? "" : undefined,
    "data-closed": value() === undefined ? "" : undefined
  }));
  const [autoFocusMenu, setAutoFocusMenu] = createSignal(false);
  const context = {
    dataset,
    value,
    setValue,
    lastValue,
    setLastValue,
    menus: () => new Set([...menuRefs().keys()]),
    menuRefs: () => [...menuRefs().values()].flat(),
    registerMenu: (value, refs) => {
      setMenuRefs(prev => {
        prev.set(value, refs);
        return prev;
      });
    },
    unregisterMenu: value => {
      setMenuRefs(prev => {
        prev.delete(value);
        return prev;
      });
    },
    nextMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === undefined) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === menusArray.length - 1) {
        if (local.loop) setValue(menusArray[0]);
        return;
      }
      setValue(menusArray[currentIndex + 1]);
    },
    previousMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === undefined) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === 0) {
        if (local.loop) setValue(menusArray[menusArray.length - 1]);
        return;
      }
      setValue(menusArray[currentIndex - 1]);
    },
    closeMenu: () => {
      setAutoFocusMenu(false);
      setValue(undefined);
    },
    autoFocusMenu,
    setAutoFocusMenu,
    generateId: createGenerateId(() => others.id)
  };
  createInteractOutside({
    onInteractOutside: () => {
      context.closeMenu();
    },
    shouldExcludeElement: element => {
      return [ref, ...menuRefs().values()].flat().some(ref => contains(ref, element));
    }
  }, () => ref);
  const keydownHandler = e => {
    if (e.key === "Alt") {
      e.preventDefault();
      e.stopPropagation();
      if (context.value() === undefined) context.nextMenu();else context.closeMenu();
    }
  };
  createEffect(() => {
    if (isServer) return;
    if (local.focusOnAlt) window.addEventListener("keydown", keydownHandler);else window.removeEventListener("keydown", keydownHandler);
  });
  createEffect(() => {
    if (value() !== undefined) setLastValue(value());
  });
  onCleanup(() => {
    if (isServer) return;
    window.removeEventListener("keydown", keydownHandler);
  });
  return createComponent(MenubarContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others, {
        role: "menubar",
        "data-orientation": "horizontal"
      }));
    }
  });
}

var index$e = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	CheckboxItem: MenuCheckboxItem,
	Content: MenuContent,
	Group: MenuGroup,
	GroupLabel: MenuGroupLabel,
	Icon: MenuIcon,
	Item: MenuItem,
	ItemDescription: MenuItemDescription,
	ItemIndicator: MenuItemIndicator,
	ItemLabel: MenuItemLabel,
	Menu: MenubarMenu,
	Portal: MenuPortal,
	RadioGroup: MenuRadioGroup,
	RadioItem: MenuRadioItem,
	Root: MenubarRoot,
	Separator: SeparatorRoot,
	Sub: MenuSub,
	SubContent: MenuSubContent,
	SubTrigger: MenuSubTrigger,
	Trigger: MenuTrigger
});

const NumberFieldContext = createContext();
function useNumberFieldContext() {
  const context = useContext(NumberFieldContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useNumberFieldContext` must be used within a `NumberField` component");
  }
  return context;
}

function NumberFieldVaryTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useNumberFieldContext();
  const [local, others] = splitProps(props, ["numberFieldVaryType", "onClick"]);
  return createComponent(ButtonRoot, mergeProps$1({
    tabIndex: -1,
    get disabled() {
      return formControlContext.isDisabled() || context.rawValue() === (local.numberFieldVaryType === "increment" ? context.maxValue() : context.minValue());
    },
    get ["aria-controls"]() {
      return formControlContext.fieldId();
    },
    onClick: e => {
      callHandler(e, local.onClick);
      context.varyValue(context.step() * (local.numberFieldVaryType === "increment" ? 1 : -1));
      context.inputRef()?.focus();
    }
  }, others));
}

function NumberFieldDecrementTrigger(props) {
  return createComponent(NumberFieldVaryTrigger, mergeProps$1({
    numberFieldVaryType: "decrement"
  }, props));
}

const _tmpl$$d = /*#__PURE__*/template(`<div aria-hidden="true"><input type="text" tabindex="-1">`);
function NumberFieldHiddenInput(props) {
  const context = useNumberFieldContext();
  const [local, others] = splitProps(props, ["ref", "onChange"]);
  const formControlContext = useFormControlContext();
  return (() => {
    const _el$ = _tmpl$$d(),
      _el$2 = _el$.firstChild;
    _el$2.addEventListener("change", e => {
      callHandler(e, local.onChange);
      batch(() => {
        context.setValue(e.target.value);
        context.format();
      });
    });
    const _ref$ = mergeRefs(context.setHiddenInputRef, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$2);
    _el$2.style.setProperty("font-size", "16px");
    spread(_el$2, mergeProps$1({
      get name() {
        return formControlContext.name();
      },
      get value() {
        return memo(() => !!Number.isNaN(context.rawValue()))() ? "" : context.rawValue();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readOnly() {
        return formControlContext.isReadOnly();
      }
    }, others), false, false);
    effect(_$p => style(_el$, visuallyHiddenStyles, _$p));
    return _el$;
  })();
}

function NumberFieldIncrementTrigger(props) {
  return createComponent(NumberFieldVaryTrigger, mergeProps$1({
    numberFieldVaryType: "increment"
  }, props));
}

function NumberFieldInput(props) {
  const formControlContext = useFormControlContext();
  const context = useNumberFieldContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("input"),
    inputMode: "decimal",
    autocomplete: "off",
    autocorrect: "off",
    spellcheck: false
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "onInput", "onChange", "onWheel"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  return createComponent(SpinButtonRoot, {
    get value() {
      return context.value();
    },
    get validationState() {
      return formControlContext.validationState();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readOnly() {
      return formControlContext.isReadOnly();
    },
    get textValue() {
      return context.textValue();
    },
    get minValue() {
      return context.minValue();
    },
    get maxValue() {
      return context.maxValue();
    },
    onIncrement: () => {
      context.varyValue(context.step());
    },
    onIncrementPage: () => {
      context.varyValue(context.largeStep());
    },
    onIncrementToMax: () => {
      context.setValue(context.maxValue());
      context.format();
    },
    onDecrement: () => {
      context.varyValue(-context.step());
    },
    onDecrementPage: () => {
      context.varyValue(-context.largeStep());
    },
    onDecrementToMin: () => {
      context.setValue(context.minValue());
      context.format();
    },
    get translations() {
      return context.translations();
    },
    asChild: true,
    get children() {
      return createComponent(As, mergeProps$1({
        component: "input",
        type: "text",
        ref(r$) {
          const _ref$ = mergeRefs(context.setInputRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return fieldProps.id();
        },
        get value() {
          return memo(() => !!Number.isNaN(context.rawValue()))() ? "" : context.formatNumber(context.rawValue());
        },
        get required() {
          return formControlContext.isRequired();
        },
        get disabled() {
          return formControlContext.isDisabled();
        },
        get readOnly() {
          return formControlContext.isReadOnly();
        },
        get ["aria-label"]() {
          return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"]() {
          return fieldProps.ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return fieldProps.ariaDescribedBy();
        },
        get onInput() {
          return composeEventHandlers([local.onInput, context.onInput]);
        },
        onChange: e => {
          callHandler(e, local.onChange);
          context.format();
        },
        onWheel: e => {
          callHandler(e, local.onWheel);
          if (!context.changeOnWheel() || document.activeElement !== context.inputRef()) return;
          e.preventDefault();
          if (e.deltaY < 0) context.varyValue(context.step());else context.varyValue(-context.step());
        }
      }, () => formControlContext.dataset(), others));
    }
  });
}

function NumberFieldRoot(props) {
  let ref;
  const defaultId = `NumberField-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    format: true,
    minValue: Number.MIN_SAFE_INTEGER,
    maxValue: Number.MAX_SAFE_INTEGER,
    step: 1,
    changeOnWheel: true
  }, props);
  const [local, formControlProps, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "rawValue", "onRawValueChange", "translations", "format", "formatOptions", "textValue", "minValue", "maxValue", "step", "largeStep", "changeOnWheel", "translations", "allowedInput"], FORM_CONTROL_PROP_NAMES);
  const {
    locale
  } = useLocale();
  const numberParser = createMemo(() => {
    return new NumberParser(locale(), local.formatOptions);
  });
  const numberFormatter = createMemo(() => {
    return new NumberFormatter(locale(), local.formatOptions);
  });
  const allNumberFormatParts = createMemo(() => [...numberFormatter().formatToParts(-1234567890.1), ...numberFormatter().formatToParts(1)]);
  const uniquePartTypes = ["decimal", "minusSign", "plusSign"];
  const commonPartTypes = ["integer", "group", "percentSign"];
  const uniqueCharacters = () => new Set(allNumberFormatParts().filter(part => uniquePartTypes.includes(part.type)).map(part => part.value).join("").split(""));
  const commonCharacters = () => new Set(allNumberFormatParts().filter(part => commonPartTypes.includes(part.type)).map(part => part.value).join("").split(""));
  const parseRawValue = value => local.format && typeof value !== "number" ? numberParser().parse(value ?? "") : Number(value ?? "");
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue ?? local.rawValue,
    onChange: value => {
      local.onChange?.(typeof value === "number" ? numberFormatter().format(value) : value);
      local.onRawValueChange?.(parseRawValue(value));
    }
  });
  local.onRawValueChange?.(parseRawValue(value()));
  function isAllowedInput(char) {
    if (local.allowedInput !== undefined) return local.allowedInput.test(char);
    if (commonCharacters().has(char)) return true;
    if (uniqueCharacters().has(char)) {
      let val = value() ?? "";
      if (typeof val === "number") val = numberFormatter().format(val);
      return !val.split("").includes(char);
    }
    return false;
  }
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => {
    setValue(local.defaultValue ?? "");
  });
  const [inputRef, setInputRef] = createSignal();
  const [hiddenInputRef, setHiddenInputRef] = createSignal();
  const onInput = e => {
    if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
      return;
    }
    const target = e.target;
    if (e.inputType !== "insertText" || isAllowedInput(e.data || "")) {
      setValue(target.value);
    }
    target.value = String(value() ?? "");
  };
  const context = {
    value,
    setValue,
    rawValue: () => parseRawValue(value()),
    generateId: createGenerateId(() => access(formControlProps.id)),
    formatNumber: number => numberFormatter().format(number),
    format: () => {
      if (!local.format) return;
      let rawValue = context.rawValue();
      if (Number.isNaN(rawValue)) {
        if (hiddenInputRef()) hiddenInputRef().value = "";
        local.onRawValueChange?.(rawValue);
        return;
      }
      if (context.minValue()) rawValue = Math.max(rawValue, context.minValue());
      if (context.maxValue()) rawValue = Math.min(rawValue, context.maxValue());
      const formattedValue = context.formatNumber(rawValue);
      if (value() != formattedValue) setValue(formattedValue);
      if (inputRef()) inputRef().value = formattedValue;
      if (hiddenInputRef()) hiddenInputRef().value = String(rawValue);
    },
    onInput,
    textValue: () => local.textValue,
    minValue: () => local.minValue,
    maxValue: () => local.maxValue,
    step: () => local.step,
    largeStep: () => local.largeStep ?? local.step * 10,
    changeOnWheel: () => local.changeOnWheel,
    translations: () => local.translations,
    inputRef,
    setInputRef,
    hiddenInputRef,
    setHiddenInputRef,
    varyValue: offset => {
      let rawValue = context.rawValue() ?? 0;
      if (Number.isNaN(rawValue)) rawValue = 0;
      batch(() => {
        const decimals = Math.max(local.formatOptions?.minimumFractionDigits ?? 0, local.formatOptions?.maximumFractionDigits ?? 3);
        const newValue = Number.parseFloat((rawValue + offset).toFixed(decimals));
        context.setValue(newValue);
        context.format();
      });
    }
  };
  createEffect(on(() => local.rawValue, rawValue => {
    if (rawValue !== context.rawValue()) {
      if (Number.isNaN(rawValue)) return;
      batch(() => {
        setValue(rawValue ?? "");
        context.format();
      });
    }
  }, {
    defer: true
  }));
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(NumberFieldContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return access(formControlProps.id);
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

var index$d = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DecrementTrigger: NumberFieldDecrementTrigger,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	HiddenInput: NumberFieldHiddenInput,
	IncrementTrigger: NumberFieldIncrementTrigger,
	Input: NumberFieldInput,
	Label: FormControlLabel,
	Root: NumberFieldRoot
});

const _tmpl$$c = /*#__PURE__*/template(`<li>`);
function PaginationEllipsis(props) {
  return (() => {
    const _el$ = _tmpl$$c();
    insert(_el$, createComponent(Polymorphic, mergeProps$1({
      as: "div"
    }, props)));
    return _el$;
  })();
}

const PaginationContext = createContext();
function usePaginationContext() {
  const context = useContext(PaginationContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePaginationContext` must be used within a `Pagination` component");
  }
  return context;
}

const _tmpl$$b = /*#__PURE__*/template(`<li>`);
function PaginationItem(props) {
  const context = usePaginationContext();
  const [local, others] = splitProps(props, ["page", "onClick"]);
  const isCurrent = () => {
    return context.page() === local.page;
  };
  const onClick = () => {
    context.setPage(local.page);
  };
  return (() => {
    const _el$ = _tmpl$$b();
    insert(_el$, createComponent(Polymorphic, mergeProps$1({
      as: "button",
      get ["aria-current"]() {
        return isCurrent() ? "page" : undefined;
      },
      get ["data-current"]() {
        return isCurrent() ? "" : undefined;
      },
      get onClick() {
        return composeEventHandlers([local.onClick, onClick]);
      }
    }, others)));
    return _el$;
  })();
}

function PaginationItems(props) {
  const context = usePaginationContext();
  const [showFirst, setShowFirst] = createSignal(false);
  const [showLast, setShowLast] = createSignal(false);
  const [showFirstEllipsis, setShowFirstEllipsis] = createSignal(false);
  const [showLastEllipsis, setShowLastEllipsis] = createSignal(false);
  const [previousSiblingCount, setPreviousSiblingCount] = createSignal(0);
  const [nextSiblingCount, setNextSiblingCount] = createSignal(0);
  createEffect(() => {
    batch(() => {
      setShowFirst(context.showFirst() && context.page() - 1 > context.siblingCount());
      setShowLast(context.showLast() && context.count() - context.page() > context.siblingCount());
      setShowFirstEllipsis(context.page() - (context.showFirst() ? 2 : 1) > context.siblingCount());
      setShowLastEllipsis(context.count() - context.page() - (context.showLast() ? 1 : 0) > context.siblingCount());
      setPreviousSiblingCount(Math.min(context.page() - 1, context.siblingCount()));
      setNextSiblingCount(Math.min(context.count() - context.page(), context.siblingCount()));
      if (context.fixedItems() !== false) {
        untrack(() => {
          setPreviousSiblingCount(prev => prev + Math.max(context.siblingCount() - nextSiblingCount(), 0));
          setNextSiblingCount(prev => prev + Math.max(context.siblingCount() - previousSiblingCount(), 0));
        });
        if (!showFirst()) setNextSiblingCount(prev => prev + 1);
        if (!showLast()) setPreviousSiblingCount(prev => prev + 1);
        if (context.fixedItems() === true) {
          if (!showFirstEllipsis()) setNextSiblingCount(prev => prev + 1);
          if (!showLastEllipsis()) setPreviousSiblingCount(prev => prev + 1);
        }
      }
    });
  });
  return [createComponent(Show, {
    get when() {
      return showFirst();
    },
    get children() {
      return context.renderItem(1);
    }
  }), createComponent(Show, {
    get when() {
      return showFirstEllipsis();
    },
    get children() {
      return context.renderEllipsis();
    }
  }), createComponent(For, {
    get each() {
      return [...Array(previousSiblingCount()).keys()].reverse();
    },
    children: offset => memo(() => context.renderItem(context.page() - (offset + 1)))
  }), memo(() => context.renderItem(context.page())), createComponent(For, {
    get each() {
      return [...Array(nextSiblingCount()).keys()];
    },
    children: offset => memo(() => context.renderItem(context.page() + (offset + 1)))
  }), createComponent(Show, {
    get when() {
      return showLastEllipsis();
    },
    get children() {
      return context.renderEllipsis();
    }
  }), createComponent(Show, {
    get when() {
      return showLast();
    },
    get children() {
      return context.renderItem(context.count());
    }
  })];
}

const _tmpl$$a = /*#__PURE__*/template(`<li>`);
function PaginationNext(props) {
  const context = usePaginationContext();
  const [local, others] = splitProps(props, ["onClick"]);
  const onClick = () => {
    context.setPage(context.page() + 1);
  };
  const isDisabled = () => context.page() === context.count();
  return (() => {
    const _el$ = _tmpl$$a();
    insert(_el$, createComponent(Polymorphic, mergeProps$1({
      as: "button",
      get tabIndex() {
        return isDisabled() || context.page() === context.count() ? "-1" : undefined;
      },
      get disabled() {
        return isDisabled();
      },
      get ["aria-disabled"]() {
        return isDisabled() || undefined;
      },
      get ["data-disabled"]() {
        return isDisabled() ? "" : undefined;
      },
      get onClick() {
        return composeEventHandlers([local.onClick, onClick]);
      }
    }, others)));
    return _el$;
  })();
}

const _tmpl$$9 = /*#__PURE__*/template(`<li>`);
function PaginationPrevious(props) {
  const context = usePaginationContext();
  const mergedProps = mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = splitProps(mergedProps, ["onClick"]);
  const onClick = () => {
    context.setPage(context.page() - 1);
  };
  const isDisabled = () => context.page() === 1;
  return (() => {
    const _el$ = _tmpl$$9();
    insert(_el$, createComponent(Polymorphic, mergeProps$1({
      as: "button",
      get tabIndex() {
        return isDisabled() || context.page() === 1 ? "-1" : undefined;
      },
      get disabled() {
        return isDisabled();
      },
      get ["aria-disabled"]() {
        return isDisabled() || undefined;
      },
      get ["data-disabled"]() {
        return isDisabled() ? "" : undefined;
      },
      get onClick() {
        return composeEventHandlers([local.onClick, onClick]);
      }
    }, others)));
    return _el$;
  })();
}

const _tmpl$$8 = /*#__PURE__*/template(`<ul>`);
function PaginationRoot(props) {
  const defaultId = `pagination-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["page", "defaultPage", "onPageChange", "count", "siblingCount", "showFirst", "showLast", "fixedItems", "itemComponent", "ellipsisComponent", "disabled", "children"]);
  const state = createControllableSignal({
    defaultValue: () => local.defaultPage ?? 1,
    onChange: local.onPageChange,
    value: () => local.page
  });
  const context = {
    count: () => local.count,
    siblingCount: () => local.siblingCount ?? 1,
    showFirst: () => local.showFirst ?? true,
    showLast: () => local.showLast ?? true,
    fixedItems: () => local.fixedItems ?? false,
    isDisabled: () => local.disabled ?? false,
    renderItem: page => local.itemComponent({
      page
    }),
    renderEllipsis: local.ellipsisComponent,
    page: state[0],
    setPage: state[1]
  };
  return createComponent(PaginationContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "nav",
        get ["data-disabled"]() {
          return local.disabled ? "" : undefined;
        }
      }, others, {
        get children() {
          const _el$ = _tmpl$$8();
          insert(_el$, () => local.children);
          return _el$;
        }
      }));
    }
  });
}

var index$c = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Ellipsis: PaginationEllipsis,
	Item: PaginationItem,
	Items: PaginationItems,
	Next: PaginationNext,
	Previous: PaginationPrevious,
	Root: PaginationRoot
});

const PopoverContext = createContext();
function usePopoverContext() {
  const context = useContext(PopoverContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopoverContext` must be used within a `Popover` component");
  }
  return context;
}

function PopoverAnchor(props) {
  const context = usePopoverContext();
  const [local, others] = splitProps(props, ["ref"]);
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(context.setDefaultAnchorRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, () => context.dataset(), others));
}

function PopoverCloseButton(props) {
  const context = usePopoverContext();
  const [local, others] = splitProps(props, ["aria-label", "onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.close();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-label"]() {
      return local["aria-label"] || context.translations().dismiss;
    },
    onClick: onClick
  }, () => context.dataset(), others));
}

function PopoverContent(props) {
  let ref;
  const context = usePopoverContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let isRightClickOutside = false;
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      if (!isRightClickOutside) {
        focusWithoutScrolling(context.triggerRef());
      }
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          focusWithoutScrolling(context.triggerRef());
        }
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.isModal()) {
      isRightClickOutside = e.detail.isContextMenu;
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.isModal()) {
      return;
    }
    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }
    if (contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  createEffect(() => onCleanup(context.registerContentId(others.id)));
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "dialog",
            tabIndex: -1,
            get disableOutsidePointerEvents() {
              return memo(() => !!context.isOpen())() && context.isModal();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                "--kb-popover-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.titleId();
            },
            get ["aria-describedby"]() {
              return context.descriptionId();
            },
            onPointerDownOutside: onPointerDownOutside,
            onFocusOutside: onFocusOutside,
            onInteractOutside: onInteractOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function PopoverDescription(props) {
  const context = usePopoverContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "p",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function PopoverPortal(props) {
  const context = usePopoverContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

const POPOVER_INTL_TRANSLATIONS = {
  dismiss: "Dismiss"
};

function PopoverRoot(props) {
  const defaultId = `popover-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    modal: false,
    translations: POPOVER_INTL_TRANSLATIONS
  }, props);
  const [local, others] = splitProps(mergedProps, ["translations", "id", "open", "defaultOpen", "onOpenChange", "modal", "preventScroll", "forceMount", "anchorRef"]);
  const [defaultAnchorRef, setDefaultAnchorRef] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [contentId, setContentId] = createSignal();
  const [titleId, setTitleId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const anchorRef = () => {
    return local.anchorRef?.() ?? defaultAnchorRef() ?? triggerRef();
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    translations: () => local.translations ?? POPOVER_INTL_TRANSLATIONS,
    dataset,
    isOpen: disclosureState.isOpen,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    contentPresence,
    triggerRef,
    contentId,
    titleId,
    descriptionId,
    setDefaultAnchorRef,
    setTriggerRef,
    setContentRef,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    generateId: createGenerateId(() => local.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(PopoverContext.Provider, {
    value: context,
    get children() {
      return createComponent(PopperRoot, mergeProps$1({
        anchorRef: anchorRef,
        contentRef: contentRef
      }, others));
    }
  });
}

function PopoverTitle(props) {
  const context = usePopoverContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerTitleId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "h2",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function PopoverTrigger(props) {
  const context = usePopoverContext();
  const [local, others] = splitProps(props, ["ref", "onClick", "onPointerDown"]);
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    e.preventDefault();
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    context.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$b = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Anchor: PopoverAnchor,
	Arrow: PopperArrow,
	CloseButton: PopoverCloseButton,
	Content: PopoverContent,
	Description: PopoverDescription,
	Portal: PopoverPortal,
	Root: PopoverRoot,
	Title: PopoverTitle,
	Trigger: PopoverTrigger
});

const ProgressContext = createContext();
function useProgressContext() {
  const context = useContext(ProgressContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useProgressContext` must be used within a `Progress.Root` component");
  }
  return context;
}

function ProgressFill(props) {
  const context = useProgressContext();
  const [local, others] = splitProps(props, ["style"]);
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get style() {
      return {
        "--kb-progress-fill-width": context.progressFillWidth(),
        ...local.style
      };
    }
  }, () => context.dataset(), others));
}

function ProgressLabel(props) {
  const context = useProgressContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "span",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

function ProgressRoot(props) {
  const defaultId = `progress-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    value: 0,
    minValue: 0,
    maxValue: 100
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "minValue", "maxValue", "indeterminate", "getValueLabel"]);
  const [labelId, setLabelId] = createSignal();
  const defaultFormatter = createNumberFormatter(() => ({
    style: "percent"
  }));
  const value = () => {
    return clamp(local.value, local.minValue, local.maxValue);
  };
  const valuePercent = () => {
    return (value() - local.minValue) / (local.maxValue - local.minValue);
  };
  const valueLabel = () => {
    if (local.indeterminate) {
      return undefined;
    }
    if (local.getValueLabel) {
      return local.getValueLabel({
        value: value(),
        min: local.minValue,
        max: local.maxValue
      });
    }
    return defaultFormatter().format(valuePercent());
  };
  const progressFillWidth = () => {
    return local.indeterminate ? undefined : `${Math.round(valuePercent() * 100)}%`;
  };
  const dataset = createMemo(() => {
    let dataProgress = undefined;
    if (!local.indeterminate) {
      dataProgress = valuePercent() === 1 ? "complete" : "loading";
    }
    return {
      "data-progress": dataProgress,
      "data-indeterminate": local.indeterminate ? "" : undefined
    };
  });
  const context = {
    dataset,
    value,
    valuePercent,
    valueLabel,
    labelId,
    progressFillWidth,
    generateId: createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return createComponent(ProgressContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        role: "progressbar",
        get ["aria-valuenow"]() {
          return memo(() => !!local.indeterminate)() ? undefined : value();
        },
        get ["aria-valuemin"]() {
          return local.minValue;
        },
        get ["aria-valuemax"]() {
          return local.maxValue;
        },
        get ["aria-valuetext"]() {
          return valueLabel();
        },
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, dataset, others));
    }
  });
}

function ProgressTrack(props) {
  const context = useProgressContext();
  return createComponent(Polymorphic, mergeProps$1({
    as: "div"
  }, () => context.dataset(), props));
}

function ProgressValueLabel(props) {
  const context = useProgressContext();
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get children() {
      return context.valueLabel();
    }
  }, () => context.dataset(), props));
}

var index$a = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Fill: ProgressFill,
	Label: ProgressLabel,
	Root: ProgressRoot,
	Track: ProgressTrack,
	ValueLabel: ProgressValueLabel
});

const RadioGroupContext = createContext();
function useRadioGroupContext() {
  const context = useContext(RadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupContext` must be used within a `RadioGroup` component");
  }
  return context;
}

const RadioGroupItemContext = createContext();
function useRadioGroupItemContext() {
  const context = useContext(RadioGroupItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupItemContext` must be used within a `RadioGroup.Item` component");
  }
  return context;
}

function RadioGroupItem(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const defaultId = `${formControlContext.generateId("item")}-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "disabled", "onPointerDown"]);
  const [inputId, setInputId] = createSignal();
  const [labelId, setLabelId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [inputRef, setInputRef] = createSignal();
  const [isFocused, setIsFocused] = createSignal(false);
  const isSelected = createMemo(() => {
    return radioGroupContext.isSelectedValue(local.value);
  });
  const isDisabled = createMemo(() => {
    return local.disabled || formControlContext.isDisabled() || false;
  });
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = createMemo(() => ({
    ...formControlContext.dataset(),
    "data-disabled": isDisabled() ? "" : undefined,
    "data-checked": isSelected() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    isSelected,
    isDisabled,
    inputId,
    labelId,
    descriptionId,
    inputRef,
    select: () => radioGroupContext.setSelectedValue(local.value),
    generateId: createGenerateId(() => others.id),
    registerInput: createRegisterId(setInputId),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId),
    setIsFocused,
    setInputRef
  };
  return createComponent(RadioGroupItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        role: "group",
        onPointerDown: onPointerDown
      }, dataset, others));
    }
  });
}

function RadioGroupItemControl(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(mergedProps, ["onClick", "onKeyDown"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.select();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.key === EventKey.Space) {
      context.select();
      context.inputRef()?.focus();
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => context.dataset(), others));
}

function RadioGroupItemDescription(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  createEffect(() => onCleanup(context.registerDescription(mergedProps.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div"
  }, () => context.dataset(), mergedProps));
}

function RadioGroupItemIndicator(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "forceMount"]);
  const presence = createPresence(() => local.forceMount || context.isSelected());
  return createComponent(Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, () => context.dataset(), others));
    }
  });
}

const _tmpl$$7 = /*#__PURE__*/template(`<input type="radio">`);
function RadioGroupItemInput(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const radioContext = useRadioGroupItemContext();
  const mergedProps = mergeDefaultProps({
    id: radioContext.generateId("input")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style", "aria-labelledby", "aria-describedby", "onChange", "onFocus", "onBlur"]);
  const ariaLabelledBy = () => {
    return [local["aria-labelledby"], radioContext.labelId(), local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined].filter(Boolean).join(" ") || undefined;
  };
  const ariaDescribedBy = () => {
    return [local["aria-describedby"], radioContext.descriptionId(), radioGroupContext.ariaDescribedBy()].filter(Boolean).join(" ") || undefined;
  };
  const [isInternalChangeEvent, setIsInternalChangeEvent] = createSignal(false);
  const onChange = e => {
    callHandler(e, local.onChange);
    e.stopPropagation();
    if (!isInternalChangeEvent()) {
      radioGroupContext.setSelectedValue(radioContext.value());
      const target = e.target;
      target.checked = radioContext.isSelected();
    }
    setIsInternalChangeEvent(false);
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    radioContext.setIsFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    radioContext.setIsFocused(false);
  };
  createEffect(on([() => radioContext.isSelected(), () => radioContext.value()], c => {
    if (!c[0] && c[1] === radioContext.value()) return;
    setIsInternalChangeEvent(true);
    const ref = radioContext.inputRef();
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));
  createEffect(() => onCleanup(radioContext.registerInput(others.id)));
  return (() => {
    const _el$ = _tmpl$$7();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = mergeRefs(radioContext.setInputRef, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$);
    spread(_el$, mergeProps$1({
      get name() {
        return formControlContext.name();
      },
      get value() {
        return radioContext.value();
      },
      get checked() {
        return radioContext.isSelected();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return radioContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-labelledby"]() {
        return ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return ariaDescribedBy();
      }
    }, () => radioContext.dataset(), others), false, false);
    return _el$;
  })();
}

const _tmpl$$6 = /*#__PURE__*/template(`<label>`);
function RadioGroupItemLabel(props) {
  const context = useRadioGroupItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  createEffect(() => onCleanup(context.registerLabel(mergedProps.id)));
  return (() => {
    const _el$ = _tmpl$$6();
    spread(_el$, mergeProps$1({
      get ["for"]() {
        return context.inputId();
      }
    }, () => context.dataset(), mergedProps), false, false);
    return _el$;
  })();
}

function RadioGroupLabel(props) {
  return createComponent(FormControlLabel, mergeProps$1({
    as: "span"
  }, props));
}

function RadioGroupRoot(props) {
  let ref;
  const defaultId = `radiogroup-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    orientation: "vertical"
  }, props);
  const [local, formControlProps, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "orientation", "aria-labelledby", "aria-describedby"], FORM_CONTROL_PROP_NAMES);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setSelected(local.defaultValue ?? ""));
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(access(formControlProps.id), others["aria-label"], local["aria-labelledby"]);
  };
  const ariaDescribedBy = () => {
    return formControlContext.getAriaDescribedBy(local["aria-describedby"]);
  };
  const isSelectedValue = value => {
    return value === selected();
  };
  const context = {
    ariaDescribedBy,
    isSelectedValue,
    setSelectedValue: value => {
      if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
        return;
      }
      setSelected(value);
      if (ref) for (const el of ref.querySelectorAll("[type='radio']")) {
        const radio = el;
        radio.checked = isSelectedValue(radio.value);
      }
    }
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(RadioGroupContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "radiogroup",
            get id() {
              return access(formControlProps.id);
            },
            get ["aria-invalid"]() {
              return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"]() {
              return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"]() {
              return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"]() {
              return formControlContext.isReadOnly() || undefined;
            },
            get ["aria-orientation"]() {
              return local.orientation;
            },
            get ["aria-labelledby"]() {
              return ariaLabelledBy();
            },
            get ["aria-describedby"]() {
              return ariaDescribedBy();
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

var index$9 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Item: RadioGroupItem,
	ItemControl: RadioGroupItemControl,
	ItemDescription: RadioGroupItemDescription,
	ItemIndicator: RadioGroupItemIndicator,
	ItemInput: RadioGroupItemInput,
	ItemLabel: RadioGroupItemLabel,
	Label: RadioGroupLabel,
	Root: RadioGroupRoot
});

const SelectContext = createContext();
function useSelectContext() {
  const context = useContext(SelectContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSelectContext` must be used within a `Select` component");
  }
  return context;
}

function SelectContent(props) {
  let ref;
  const context = useSelectContext();
  const [local, others] = splitProps(props, ["ref", "id", "style", "onCloseAutoFocus", "onFocusOutside"]);
  const onEscapeKeyDown = e => {
    context.close();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    element: () => ref ?? null,
    enabled: () => context.isOpen() && context.preventScroll()
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: e => {
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      local.onCloseAutoFocus?.(e);
      if (!e.defaultPrevented) {
        focusWithoutScrolling(context.triggerRef());
        e.preventDefault();
      }
    }
  }, () => ref);
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get disableOutsidePointerEvents() {
              return memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                "--kb-select-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function SelectHiddenSelect(props) {
  const context = useSelectContext();
  return createComponent(HiddenSelectBase, mergeProps$1({
    get collection() {
      return context.listState().collection();
    },
    get selectionManager() {
      return context.listState().selectionManager();
    },
    get isOpen() {
      return context.isOpen();
    },
    get isMultiple() {
      return context.isMultiple();
    },
    get isVirtualized() {
      return context.isVirtualized();
    },
    focusTrigger: () => context.triggerRef()?.focus()
  }, props));
}

function SelectIcon(props) {
  const context = useSelectContext();
  const mergedProps = mergeDefaultProps({
    children: "▼"
  }, props);
  return createComponent(Polymorphic, mergeProps$1({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}

function SelectLabel(props) {
  const context = useSelectContext();
  const [local, others] = splitProps(props, ["onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    if (!context.isDisabled()) {
      context.triggerRef()?.focus();
    }
  };
  return createComponent(FormControlLabel, mergeProps$1({
    as: "span",
    onClick: onClick
  }, others));
}

function SelectListbox(props) {
  const context = useSelectContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("listbox")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "onKeyDown"]);
  createEffect(() => onCleanup(context.registerListboxId(local.id)));
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.key === "Escape") {
      e.preventDefault();
    }
  };
  return createComponent(ListboxRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get state() {
      return context.listState();
    },
    get virtualized() {
      return context.isVirtualized();
    },
    get autoFocus() {
      return context.autoFocus();
    },
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get shouldFocusWrap() {
      return context.shouldFocusWrap();
    },
    get disallowTypeAhead() {
      return context.disallowTypeAhead();
    },
    get ["aria-labelledby"]() {
      return context.listboxAriaLabelledBy();
    },
    get renderItem() {
      return context.renderItem;
    },
    get renderSection() {
      return context.renderSection;
    },
    onKeyDown: onKeyDown
  }, others));
}

function SelectPortal(props) {
  const context = useSelectContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

function SelectBase(props) {
  const defaultId = `select-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    disallowEmptySelection: false,
    closeOnSelection: props.selectionMode === "single",
    allowDuplicateSelectionEvents: true,
    gutter: 8,
    sameWidth: true,
    modal: false
  }, props);
  const [local, popperProps, formControlProps, others] = splitProps(mergedProps, ["itemComponent", "sectionComponent", "open", "defaultOpen", "onOpenChange", "value", "defaultValue", "onChange", "placeholder", "options", "optionValue", "optionTextValue", "optionDisabled", "optionGroupChildren", "keyboardDelegate", "allowDuplicateSelectionEvents", "disallowEmptySelection", "closeOnSelection", "disallowTypeAhead", "shouldFocusWrap", "selectionBehavior", "selectionMode", "virtualized", "modal", "preventScroll", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [triggerId, setTriggerId] = createSignal();
  const [valueId, setValueId] = createSignal();
  const [listboxId, setListboxId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [listboxRef, setListboxRef] = createSignal();
  const [listboxAriaLabelledBy, setListboxAriaLabelledBy] = createSignal();
  const [focusStrategy, setFocusStrategy] = createSignal(true);
  const getOptionValue = option => {
    const optionValue = local.optionValue;
    if (optionValue == null) {
      return String(option);
    }
    return String(isFunction(optionValue) ? optionValue(option) : option[optionValue]);
  };
  const flattenOptions = createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;
    if (optionGroupChildren == null) {
      return local.options;
    }
    return local.options.flatMap(item => item[optionGroupChildren] ?? item);
  });
  const flattenOptionKeys = createMemo(() => {
    return flattenOptions().map(option => getOptionValue(option));
  });
  const getOptionsFromValues = values => {
    return [...values].map(value => flattenOptions().find(option => getOptionValue(option) === value)).filter(option => option != null);
  };
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const listState = createListState({
    selectedKeys: () => {
      if (local.value != null) {
        return local.value.map(getOptionValue);
      }
      return local.value;
    },
    defaultSelectedKeys: () => {
      if (local.defaultValue != null) {
        return local.defaultValue.map(getOptionValue);
      }
      return local.defaultValue;
    },
    onSelectionChange: selectedKeys => {
      local.onChange?.(getOptionsFromValues(selectedKeys));
      if (local.closeOnSelection) {
        close();
      }
    },
    allowDuplicateSelectionEvents: () => access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => access(local.disallowEmptySelection),
    selectionBehavior: () => access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: () => local.options ?? [],
    getKey: () => local.optionValue,
    getTextValue: () => local.optionTextValue,
    getDisabled: () => local.optionDisabled,
    getSectionChildren: () => local.optionGroupChildren
  });
  const selectedOptions = createMemo(() => {
    return getOptionsFromValues(listState.selectionManager().selectedKeys());
  });
  const removeOptionFromSelection = option => {
    listState.selectionManager().toggleSelection(getOptionValue(option));
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const focusListbox = () => {
    const listboxEl = listboxRef();
    if (listboxEl) {
      focusWithoutScrolling(listboxEl);
    }
  };
  const open = focusStrategy => {
    if (local.options.length <= 0) {
      return;
    }
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    focusListbox();
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
  };
  const toggle = focusStrategy => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy);
    }
  };
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(triggerRef, () => {
    const defaultSelectedKeys = local.defaultValue ? [...local.defaultValue].map(getOptionValue) : new Selection();
    listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
  });
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });
  const delegate = createMemo(() => {
    const keyboardDelegate = access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, undefined, collator);
  });
  const renderItem = item => {
    return local.itemComponent?.({
      item
    });
  };
  const renderSection = section => {
    return local.sectionComponent?.({
      section
    });
  };
  createEffect(on([flattenOptionKeys], ([flattenOptionKeys]) => {
    const currentSelectedKeys = [...listState.selectionManager().selectedKeys()];
    const keysToKeep = currentSelectedKeys.filter(key => flattenOptionKeys.includes(key));
    listState.selectionManager().setSelectedKeys(keysToKeep);
  }, {
    defer: true
  }));
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => access(local.selectionMode) === "multiple",
    isVirtualized: () => local.virtualized ?? false,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    disallowTypeAhead: () => local.disallowTypeAhead ?? false,
    shouldFocusWrap: () => local.shouldFocusWrap ?? false,
    selectedOptions,
    contentPresence,
    autoFocus: focusStrategy,
    triggerRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    triggerId,
    valueId,
    listboxId,
    listboxAriaLabelledBy,
    setListboxAriaLabelledBy,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    placeholder: () => local.placeholder,
    renderItem,
    renderSection,
    removeOptionFromSelection,
    generateId: createGenerateId(() => access(formControlProps.id)),
    registerTriggerId: createRegisterId(setTriggerId),
    registerValueId: createRegisterId(setValueId),
    registerListboxId: createRegisterId(setListboxId)
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(SelectContext.Provider, {
        value: context,
        get children() {
          return createComponent(PopperRoot, mergeProps$1({
            anchorRef: triggerRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return createComponent(Polymorphic, mergeProps$1({
                as: "div",
                role: "group",
                get id() {
                  return access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

function SelectRoot(props) {
  const [local, others] = splitProps(props, ["value", "defaultValue", "onChange", "multiple"]);
  const value = createMemo(() => {
    if (local.value != null) {
      return local.multiple ? local.value : [local.value];
    }
    return local.value;
  });
  const defaultValue = createMemo(() => {
    if (local.defaultValue != null) {
      return local.multiple ? local.defaultValue : [local.defaultValue];
    }
    return local.defaultValue;
  });
  const onChange = value => {
    if (local.multiple) {
      local.onChange?.(value);
    } else {
      local.onChange?.(value[0] ?? null);
    }
  };
  return createComponent(SelectBase, mergeProps$1({
    get value() {
      return value();
    },
    get defaultValue() {
      return defaultValue();
    },
    onChange: onChange,
    get selectionMode() {
      return local.multiple ? "multiple" : "single";
    }
  }, others));
}

function SelectTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "disabled", "onPointerDown", "onClick", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const selectionManager = () => context.listState().selectionManager();
  const keyboardDelegate = () => context.keyboardDelegate();
  const isDisabled = () => local.disabled || context.isDisabled();
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const {
    typeSelectHandlers
  } = createTypeSelect({
    keyboardDelegate: keyboardDelegate,
    selectionManager: selectionManager,
    onTypeSelect: key => selectionManager().select(key)
  });
  const ariaLabelledBy = () => {
    return [context.listboxAriaLabelledBy(), context.valueId()].filter(Boolean).join(" ") || undefined;
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
      e.preventDefault();
      context.toggle(true);
    }
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    if (!isDisabled() && e.currentTarget.dataset.pointerType === "touch") {
      context.toggle(true);
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (isDisabled()) {
      return;
    }
    callHandler(e, typeSelectHandlers.onKeyDown);
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowLeft":
        {
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyAbove?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
      case "ArrowRight":
        {
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyBelow?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (selectionManager().isFocused()) {
      return;
    }
    selectionManager().setFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    if (context.isOpen()) {
      return;
    }
    selectionManager().setFocused(false);
  };
  createEffect(() => onCleanup(context.registerTriggerId(fieldProps.id())));
  createEffect(() => {
    context.setListboxAriaLabelledBy([fieldProps.ariaLabelledBy(), fieldProps.ariaLabel() && !fieldProps.ariaLabelledBy() ? fieldProps.id() : null].filter(Boolean).join(" ") || undefined);
  });
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get disabled() {
      return isDisabled();
    },
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const _tmpl$$5 = /*#__PURE__*/template(`<span>`);
function SelectValue(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("value")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id", "children"]);
  const selectionManager = () => context.listState().selectionManager();
  const isSelectionEmpty = () => {
    const selectedKeys = selectionManager().selectedKeys();
    if (selectedKeys.size === 1 && selectedKeys.has("")) {
      return true;
    }
    return selectionManager().isEmpty();
  };
  createEffect(() => onCleanup(context.registerValueId(local.id)));
  return (() => {
    const _el$ = _tmpl$$5();
    spread(_el$, mergeProps$1({
      get id() {
        return local.id;
      },
      get ["data-placeholder-shown"]() {
        return isSelectionEmpty() ? "" : undefined;
      }
    }, () => formControlContext.dataset(), others), false, true);
    insert(_el$, createComponent(Show, {
      get when() {
        return !isSelectionEmpty();
      },
      get fallback() {
        return context.placeholder();
      },
      get children() {
        return createComponent(SelectValueChild, {
          state: {
            selectedOption: () => context.selectedOptions()[0],
            selectedOptions: () => context.selectedOptions(),
            remove: option => context.removeOptionFromSelection(option),
            clear: () => selectionManager().clearSelection()
          },
          get children() {
            return local.children;
          }
        });
      }
    }));
    return _el$;
  })();
}
function SelectValueChild(props) {
  const resolvedChildren = children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
  return memo(resolvedChildren);
}

var index$8 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: SelectContent,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	HiddenSelect: SelectHiddenSelect,
	Icon: SelectIcon,
	Item: ListboxItem,
	ItemDescription: ListboxItemDescription,
	ItemIndicator: ListboxItemIndicator,
	ItemLabel: ListboxItemLabel,
	Label: SelectLabel,
	Listbox: SelectListbox,
	Portal: SelectPortal,
	Root: SelectRoot,
	Section: ListboxSection,
	Trigger: SelectTrigger,
	Value: SelectValue
});

function Skeleton(props) {
  const defaultId = `skeleton-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    visible: true,
    animate: true,
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["style", "ref", "radius", "animate", "height", "width", "visible", "circle"]);
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    role: "group",
    get ["data-animate"]() {
      return local.animate;
    },
    get ["data-visible"]() {
      return local.visible;
    },
    get style() {
      return {
        "border-radius": local.circle ? "9999px" : local.radius ? `${local.radius}px` : undefined,
        width: local.circle ? `${local.height}px` : local.width ? `${local.width}px` : "100%",
        height: local.height ? `${local.height}px` : "auto",
        ...local.style
      };
    }
  }, others));
}

var index$7 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: Skeleton
});

const SliderContext = createContext();
function useSliderContext() {
  const context = useContext(SliderContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSliderContext` must be used within a `Slider.Root` component");
  }
  return context;
}

function SliderFill(props) {
  const context = useSliderContext();
  const [local, others] = splitProps(props, ["style"]);
  const percentages = () => {
    return context.state.values().map(value => context.state.getValuePercent(value) * 100);
  };
  const offsetStart = () => {
    return context.state.values().length > 1 ? Math.min(...percentages()) : 0;
  };
  const offsetEnd = () => {
    return 100 - Math.max(...percentages());
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get style() {
      return {
        [context.startEdge()]: `${offsetStart()}%`,
        [context.endEdge()]: `${offsetEnd()}%`,
        ...local.style
      };
    }
  }, () => context.dataset(), others));
}

function SliderThumb(props) {
  let ref;
  const context = useSliderContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId(`thumb-${createUniqueId()}`)
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "style", "onKeyDown", "onPointerDown", "onPointerMove", "onPointerUp", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      disabled: context.state.isDisabled(),
      key: fieldProps.id(),
      textValue: "",
      type: "item"
    })
  });
  const index = () => ref ? context.thumbs().findIndex(v => v.ref() === ref) : -1;
  const value = () => context.state.getThumbValue(index());
  const position = () => {
    return context.state.getThumbPercent(index());
  };
  const transform = () => {
    return context.state.orientation() === "vertical" ? "translateY(50%)" : "translateX(-50%)";
  };
  let startPosition = 0;
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    context.onStepKeyDown(e, index());
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    const target = e.currentTarget;
    e.preventDefault();
    e.stopPropagation();
    target.setPointerCapture(e.pointerId);
    target.focus();
    startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    if (value() !== undefined) {
      context.onSlideStart?.(index(), value());
    }
  };
  const onPointerMove = e => {
    e.stopPropagation();
    callHandler(e, local.onPointerMove);
    const target = e.currentTarget;
    if (target.hasPointerCapture(e.pointerId)) {
      const delta = {
        deltaX: e.clientX - startPosition,
        deltaY: e.clientY - startPosition
      };
      context.onSlideMove?.(delta);
      startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    }
  };
  const onPointerUp = e => {
    e.stopPropagation();
    callHandler(e, local.onPointerUp);
    const target = e.currentTarget;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
      context.onSlideEnd?.();
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    context.state.setFocusedThumb(index());
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.state.setFocusedThumb(undefined);
  };
  onMount(() => {
    context.state.setThumbEditable(index(), !context.state.isDisabled());
  });
  return createComponent(ThumbContext.Provider, {
    value: {
      index
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "span",
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "slider",
        get id() {
          return fieldProps.id();
        },
        get tabIndex() {
          return context.state.isDisabled() ? undefined : 0;
        },
        get style() {
          return {
            display: value() === undefined ? "none" : undefined,
            position: "absolute",
            [context.startEdge()]: `calc(${position() * 100}%)`,
            transform: transform(),
            "touch-action": "none",
            ...local.style
          };
        },
        get ["aria-valuetext"]() {
          return context.state.getThumbValueLabel(index());
        },
        get ["aria-valuemin"]() {
          return context.minValue();
        },
        get ["aria-valuenow"]() {
          return value();
        },
        get ["aria-valuemax"]() {
          return context.maxValue();
        },
        get ["aria-orientation"]() {
          return context.state.orientation();
        },
        get ["aria-label"]() {
          return fieldProps.ariaLabel();
        },
        get ["aria-labelledby"]() {
          return fieldProps.ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return fieldProps.ariaDescribedBy();
        },
        onKeyDown: onKeyDown,
        onPointerDown: onPointerDown,
        onPointerMove: onPointerMove,
        onPointerUp: onPointerUp,
        onFocus: onFocus,
        onBlur: onBlur
      }, () => context.dataset(), others));
    }
  });
}
const ThumbContext = createContext();
function useThumbContext() {
  const context = useContext(ThumbContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useThumbContext` must be used within a `Slider.Thumb` component");
  }
  return context;
}

const _tmpl$$4 = /*#__PURE__*/template(`<input type="range">`);
function SliderInput(props) {
  const formControlContext = useFormControlContext();
  const context = useSliderContext();
  const thumb = useThumbContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "style", "onChange"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const [valueText, setValueText] = createSignal("");
  const onChange = e => {
    callHandler(e, local.onChange);
    const target = e.target;
    context.state.setThumbValue(thumb.index(), parseFloat(target.value));
    target.value = String(context.state.values()[thumb.index()]) ?? "";
  };
  createEffect(() => {
    setValueText(thumb.index() === -1 ? "" : context.state.getThumbValueLabel(thumb.index()));
  });
  return (() => {
    const _el$ = _tmpl$$4();
    _el$.addEventListener("change", onChange);
    const _ref$ = mergeRefs(el => el, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$);
    spread(_el$, mergeProps$1({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get tabIndex() {
        return context.state.isDisabled() ? undefined : -1;
      },
      get min() {
        return context.state.getThumbMinValue(thumb.index());
      },
      get max() {
        return context.state.getThumbMaxValue(thumb.index());
      },
      get step() {
        return context.state.step();
      },
      get value() {
        return context.state.values()[thumb.index()];
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-orientation"]() {
        return context.state.orientation();
      },
      get ["aria-valuetext"]() {
        return valueText();
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => context.dataset(), others), false, false);
    return _el$;
  })();
}

function getNextSortedValues(prevValues, nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map(value => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  const closestIndex = distances.indexOf(closestDistance);
  return nextValue < values[closestIndex] ? closestIndex : distances.lastIndexOf(closestDistance);
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return value => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function stopEventDefaultAndPropagation(event) {
  event.preventDefault();
  event.stopPropagation();
}

function createSliderState(props) {
  const mergedProps = mergeDefaultProps({
    minValue: () => 0,
    maxValue: () => 100,
    step: () => 1,
    minStepsBetweenThumbs: () => 0,
    orientation: () => "horizontal",
    isDisabled: () => false
  }, props);
  const pageSize = createMemo(() => {
    let calcPageSize = (mergedProps.maxValue() - mergedProps.minValue()) / 10;
    calcPageSize = snapValueToStep(calcPageSize, 0, calcPageSize + mergedProps.step(), mergedProps.step());
    return Math.max(calcPageSize, mergedProps.step());
  });
  const defaultValue = createMemo(() => {
    return mergedProps.defaultValue() ?? [mergedProps.minValue()];
  });
  const [values, setValues] = createControllableArraySignal({
    value: () => mergedProps.value(),
    defaultValue,
    onChange: values => mergedProps.onChange?.(values)
  });
  const [isDragging, setIsDragging] = createSignal(new Array(values().length).fill(false));
  const [isEditables, setEditables] = createSignal(new Array(values().length).fill(false));
  const [focusedIndex, setFocusedIndex] = createSignal(undefined);
  const resetValues = () => {
    setValues(defaultValue());
  };
  const getValuePercent = value => {
    return (value - mergedProps.minValue()) / (mergedProps.maxValue() - mergedProps.minValue());
  };
  const getThumbMinValue = index => {
    return index === 0 ? props.minValue() : values()[index - 1] + props.minStepsBetweenThumbs() * props.step();
  };
  const getThumbMaxValue = index => {
    return index === values().length - 1 ? props.maxValue() : values()[index + 1] - props.minStepsBetweenThumbs() * props.step();
  };
  const isThumbEditable = index => {
    return isEditables()[index];
  };
  const setThumbEditable = index => {
    setEditables(p => {
      p[index] = true;
      return p;
    });
  };
  const updateValue = (index, value) => {
    if (mergedProps.isDisabled() || !isThumbEditable(index)) return;
    const snappedValue = snapValueToStep(value, getThumbMinValue(index), getThumbMaxValue(index), mergedProps.step());
    const nextValues = getNextSortedValues(values(), snappedValue, index);
    if (!hasMinStepsBetweenValues(nextValues, mergedProps.minStepsBetweenThumbs() * mergedProps.step())) {
      return;
    }
    setValues(prev => [...replaceIndex(prev, index, snappedValue)]);
  };
  const updateDragging = (index, dragging) => {
    if (mergedProps.isDisabled() || !isThumbEditable(index)) return;
    const wasDragging = isDragging()[index];
    setIsDragging(p => [...replaceIndex(p, index, dragging)]);
    if (wasDragging && !isDragging().some(Boolean)) {
      mergedProps.onChangeEnd?.(values());
    }
  };
  const getFormattedValue = value => {
    return mergedProps.numberFormatter.format(value);
  };
  const setThumbPercent = (index, percent) => {
    updateValue(index, getPercentValue(percent));
  };
  const getRoundedValue = value => {
    return Math.round((value - mergedProps.minValue()) / mergedProps.step()) * mergedProps.step() + mergedProps.minValue();
  };
  const getPercentValue = percent => {
    const val = percent * (mergedProps.maxValue() - mergedProps.minValue()) + mergedProps.minValue();
    return clamp(getRoundedValue(val), mergedProps.minValue(), mergedProps.maxValue());
  };
  const snapThumbValue = (index, value) => {
    const nextValue = values()[index] + value;
    const nextValues = getNextSortedValues(values(), nextValue, index);
    if (hasMinStepsBetweenValues(nextValues, mergedProps.minStepsBetweenThumbs() * mergedProps.step())) {
      updateValue(index, snapValueToStep(nextValue, mergedProps.minValue(), mergedProps.maxValue(), mergedProps.step()));
    }
  };
  const incrementThumb = (index, stepSize = 1) => {
    snapThumbValue(index, Math.max(stepSize, props.step()));
  };
  const decrementThumb = (index, stepSize = 1) => {
    snapThumbValue(index, -Math.max(stepSize, props.step()));
  };
  return {
    values,
    getThumbValue: index => values()[index],
    setThumbValue: updateValue,
    setThumbPercent,
    isThumbDragging: index => isDragging()[index],
    setThumbDragging: updateDragging,
    focusedThumb: focusedIndex,
    setFocusedThumb: setFocusedIndex,
    getThumbPercent: index => getValuePercent(values()[index]),
    getValuePercent,
    getThumbValueLabel: index => getFormattedValue(values()[index]),
    getFormattedValue,
    getThumbMinValue,
    getThumbMaxValue,
    getPercentValue,
    isThumbEditable,
    setThumbEditable,
    incrementThumb,
    decrementThumb,
    step: mergedProps.step,
    pageSize,
    orientation: mergedProps.orientation,
    isDisabled: mergedProps.isDisabled,
    setValues,
    resetValues
  };
}
function replaceIndex(array, index, value) {
  if (array[index] === value) {
    return array;
  }
  return [...array.slice(0, index), value, ...array.slice(index + 1)];
}

function SliderRoot(props) {
  let ref;
  const defaultId = `slider-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    minValue: 0,
    maxValue: 100,
    step: 1,
    minStepsBetweenThumbs: 0,
    orientation: "horizontal",
    disabled: false,
    inverted: false,
    getValueLabel: params => params.values.join(", ")
  }, props);
  const [local, formControlProps, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange", "onChangeEnd", "inverted", "minValue", "maxValue", "step", "minStepsBetweenThumbs", "getValueLabel", "orientation"], FORM_CONTROL_PROP_NAMES);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const defaultFormatter = createNumberFormatter(() => ({
    style: "decimal"
  }));
  const {
    direction
  } = useLocale();
  const state = createSliderState({
    value: () => local.value,
    defaultValue: () => local.defaultValue ?? [local.minValue],
    maxValue: () => local.maxValue,
    minValue: () => local.minValue,
    minStepsBetweenThumbs: () => local.minStepsBetweenThumbs,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    orientation: () => local.orientation,
    step: () => local.step,
    numberFormatter: defaultFormatter(),
    onChange: local.onChange,
    onChangeEnd: local.onChangeEnd
  });
  const [thumbs, setThumbs] = createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items: thumbs,
    onItemsChange: setThumbs
  });
  createFormResetListener(() => ref, () => state.resetValues());
  const isLTR = () => direction() === "ltr";
  const isSlidingFromLeft = () => {
    return isLTR() && !local.inverted || !isLTR() && local.inverted;
  };
  const isSlidingFromBottom = () => !local.inverted;
  const isVertical = () => state.orientation() === "vertical";
  const dataset = createMemo(() => {
    return {
      ...formControlContext.dataset(),
      "data-orientation": local.orientation
    };
  });
  const [trackRef, setTrackRef] = createSignal();
  let currentPosition = null;
  const onSlideStart = (index, value) => {
    state.setFocusedThumb(index);
    state.setThumbDragging(index, true);
    state.setThumbValue(index, value);
    currentPosition = null;
  };
  const onSlideMove = ({
    deltaX,
    deltaY
  }) => {
    const active = state.focusedThumb();
    if (active === undefined) {
      return;
    }
    const {
      width,
      height
    } = trackRef().getBoundingClientRect();
    const size = isVertical() ? height : width;
    if (currentPosition === null) {
      currentPosition = state.getThumbPercent(state.focusedThumb()) * size;
    }
    let delta = isVertical() ? deltaY : deltaX;
    if (!isVertical() && local.inverted || isVertical() && isSlidingFromBottom()) {
      delta = -delta;
    }
    currentPosition += delta;
    const percent = clamp(currentPosition / size, 0, 1);
    const nextValues = getNextSortedValues(state.values(), currentPosition, active);
    if (hasMinStepsBetweenValues(nextValues, local.minStepsBetweenThumbs * state.step())) {
      state.setThumbPercent(state.focusedThumb(), percent);
      local.onChange?.(state.values());
    }
  };
  const onSlideEnd = () => {
    const activeThumb = state.focusedThumb();
    if (activeThumb !== undefined) {
      state.setThumbDragging(activeThumb, false);
      thumbs()[activeThumb].ref().focus();
    }
  };
  const onHomeKeyDown = event => {
    const focusedThumb = state.focusedThumb();
    if (!formControlContext.isDisabled() && focusedThumb !== undefined) {
      stopEventDefaultAndPropagation(event);
      state.setThumbValue(focusedThumb, state.getThumbMinValue(focusedThumb));
    }
  };
  const onEndKeyDown = event => {
    const focusedThumb = state.focusedThumb();
    if (!formControlContext.isDisabled() && focusedThumb !== undefined) {
      stopEventDefaultAndPropagation(event);
      state.setThumbValue(focusedThumb, state.getThumbMaxValue(focusedThumb));
    }
  };
  const onStepKeyDown = (event, index) => {
    if (!formControlContext.isDisabled()) {
      switch (event.key) {
        case "Left":
        case "ArrowLeft":
        case "Down":
        case "ArrowDown":
          stopEventDefaultAndPropagation(event);
          if (!isLTR()) {
            state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          } else {
            state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          }
          break;
        case "Right":
        case "ArrowRight":
        case "Up":
        case "ArrowUp":
          stopEventDefaultAndPropagation(event);
          if (!isLTR()) {
            state.decrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          } else {
            state.incrementThumb(index, event.shiftKey ? state.pageSize() : state.step());
          }
          break;
        case "Home":
          onHomeKeyDown(event);
          break;
        case "End":
          onEndKeyDown(event);
          break;
        case "PageUp":
          stopEventDefaultAndPropagation(event);
          state.incrementThumb(index, state.pageSize());
          break;
        case "PageDown":
          stopEventDefaultAndPropagation(event);
          state.decrementThumb(index, state.pageSize());
          break;
      }
    }
  };
  const startEdge = createMemo(() => {
    if (isVertical()) {
      return isSlidingFromBottom() ? "bottom" : "top";
    }
    return isSlidingFromLeft() ? "left" : "right";
  });
  const endEdge = createMemo(() => {
    if (isVertical()) {
      return isSlidingFromBottom() ? "top" : "bottom";
    }
    return isSlidingFromLeft() ? "right" : "left";
  });
  const context = {
    dataset,
    state,
    thumbs,
    setThumbs,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onStepKeyDown,
    isSlidingFromLeft,
    isSlidingFromBottom,
    trackRef,
    minValue: () => local.minValue,
    maxValue: () => local.maxValue,
    inverted: () => local.inverted,
    startEdge,
    endEdge,
    registerTrack: ref => setTrackRef(ref),
    generateId: createGenerateId(() => access(formControlProps.id)),
    getValueLabel: local.getValueLabel
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(FormControlContext.Provider, {
        value: formControlContext,
        get children() {
          return createComponent(SliderContext.Provider, {
            value: context,
            get children() {
              return createComponent(Polymorphic, mergeProps$1({
                as: "div",
                ref(r$) {
                  const _ref$ = mergeRefs(el => ref = el, local.ref);
                  typeof _ref$ === "function" && _ref$(r$);
                },
                role: "group",
                get id() {
                  return access(formControlProps.id);
                }
              }, dataset, others));
            }
          });
        }
      });
    }
  });
}

function SliderTrack(props) {
  const context = useSliderContext();
  const [local, others] = splitProps(props, ["onPointerDown", "onPointerMove", "onPointerUp"]);
  const [sRect, setRect] = createSignal();
  function getValueFromPointer(pointerPosition) {
    const rect = sRect() || context.trackRef().getBoundingClientRect();
    const input = [0, context.state.orientation() === "vertical" ? rect.height : rect.width];
    let output = context.isSlidingFromLeft() ? [context.minValue(), context.maxValue()] : [context.maxValue(), context.minValue()];
    if (context.state.orientation() === "vertical") {
      output = context.isSlidingFromBottom() ? [context.maxValue(), context.minValue()] : [context.minValue(), context.maxValue()];
    }
    const value = linearScale(input, output);
    setRect(rect);
    return value(pointerPosition - (context.state.orientation() === "vertical" ? rect.top : rect.left));
  }
  let startPosition = 0;
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    const target = e.target;
    target.setPointerCapture(e.pointerId);
    e.preventDefault();
    const value = getValueFromPointer(context.state.orientation() === "horizontal" ? e.clientX : e.clientY);
    startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    const closestIndex = getClosestValueIndex(context.state.values(), value);
    context.onSlideStart?.(closestIndex, value);
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      context.onSlideMove?.({
        deltaX: e.clientX - startPosition,
        deltaY: e.clientY - startPosition
      });
      startPosition = context.state.orientation() === "horizontal" ? e.clientX : e.clientY;
    }
  };
  const onPointerUp = e => {
    callHandler(e, local.onPointerUp);
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
      setRect(undefined);
      context.onSlideEnd?.();
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(context.registerTrack, props.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    onPointerDown: onPointerDown,
    onPointerMove: onPointerMove,
    onPointerUp: onPointerUp
  }, () => context.dataset(), others));
}

function SliderValueLabel(props) {
  const context = useSliderContext();
  return createComponent(Polymorphic, mergeProps$1({
    as: "div"
  }, () => context.dataset(), props, {
    get children() {
      return context.getValueLabel?.({
        values: context.state.values(),
        max: context.maxValue(),
        min: context.minValue()
      });
    }
  }));
}

var index$6 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Fill: SliderFill,
	Input: SliderInput,
	Label: FormControlLabel,
	Root: SliderRoot,
	Thumb: SliderThumb,
	Track: SliderTrack,
	ValueLabel: SliderValueLabel
});

const SwitchContext = createContext();
function useSwitchContext() {
  const context = useContext(SwitchContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSwitchContext` must be used within a `Switch` component");
  }
  return context;
}

function SwitchControl(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(mergedProps, ["onClick", "onKeyDown"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.toggle();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.key === EventKey.Space) {
      context.toggle();
      context.inputRef()?.focus();
    }
  };
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => formControlContext.dataset(), () => context.dataset(), others));
}

function SwitchDescription(props) {
  const context = useSwitchContext();
  return createComponent(FormControlDescription, mergeProps$1(() => context.dataset(), props));
}

function SwitchErrorMessage(props) {
  const context = useSwitchContext();
  return createComponent(FormControlErrorMessage, mergeProps$1(() => context.dataset(), props));
}

const _tmpl$$3 = /*#__PURE__*/template(`<input type="checkbox" role="switch">`);
function SwitchInput(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["ref", "style", "onChange", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onChange = e => {
    callHandler(e, local.onChange);
    e.stopPropagation();
    const target = e.target;
    context.setIsChecked(target.checked);
    target.checked = context.checked();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    context.setIsFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.setIsFocused(false);
  };
  return (() => {
    const _el$ = _tmpl$$3();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = mergeRefs(context.setInputRef, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$);
    spread(_el$, mergeProps$1({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.checked();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-checked"]() {
        return context.checked();
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => formControlContext.dataset(), () => context.dataset(), others), false, false);
    return _el$;
  })();
}

function SwitchLabel(props) {
  const context = useSwitchContext();
  return createComponent(FormControlLabel, mergeProps$1(() => context.dataset(), props));
}

function SwitchRoot(props) {
  let ref;
  const defaultId = `switch-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = splitProps(mergedProps, ["ref", "children", "value", "checked", "defaultChecked", "onChange", "onPointerDown"], FORM_CONTROL_PROP_NAMES);
  const [inputRef, setInputRef] = createSignal();
  const [isFocused, setIsFocused] = createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => formControlContext.isDisabled(),
    isReadOnly: () => formControlContext.isReadOnly()
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultChecked ?? false));
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = createMemo(() => ({
    "data-checked": state.isSelected() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    checked: () => state.isSelected(),
    inputRef,
    generateId: createGenerateId(() => access(formControlProps.id)),
    toggle: () => state.toggle(),
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setInputRef
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(SwitchContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return access(formControlProps.id);
            },
            onPointerDown: onPointerDown
          }, () => formControlContext.dataset(), dataset, others, {
            get children() {
              return createComponent(SwitchRootChild, {
                state: context,
                get children() {
                  return local.children;
                }
              });
            }
          }));
        }
      });
    }
  });
}
function SwitchRootChild(props) {
  const resolvedChildren = children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
  return memo(resolvedChildren);
}

function SwitchThumb(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("thumb")
  }, props);
  return createComponent(Polymorphic, mergeProps$1({
    as: "div"
  }, () => formControlContext.dataset(), () => context.dataset(), mergedProps));
}

var index$5 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Control: SwitchControl,
	Description: SwitchDescription,
	ErrorMessage: SwitchErrorMessage,
	Input: SwitchInput,
	Label: SwitchLabel,
	Root: SwitchRoot,
	Thumb: SwitchThumb
});

const TabsContext = createContext();
function useTabsContext() {
  const context = useContext(TabsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTabsContext` must be used within a `Tabs` component");
  }
  return context;
}

function TabsContent(props) {
  let ref;
  const context = useTabsContext();
  const [local, others] = splitProps(props, ["ref", "id", "value", "forceMount"]);
  const [tabIndex, setTabIndex] = createSignal(0);
  const id = () => local.id ?? context.generateContentId(local.value);
  const isSelected = () => context.listState().selectedKey() === local.value;
  const presence = createPresence(() => local.forceMount || isSelected());
  createEffect(on([() => ref, () => presence.isPresent()], ([ref, isPresent]) => {
    if (ref == null || !isPresent) {
      return;
    }
    const updateTabIndex = () => {
      const walker = getFocusableTreeWalker(ref, {
        tabbable: true
      });
      setTabIndex(walker.nextNode() ? undefined : 0);
    };
    updateTabIndex();
    const observer = new MutationObserver(updateTabIndex);
    observer.observe(ref, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["tabindex", "disabled"]
    });
    onCleanup(() => {
      observer.disconnect();
    });
  }));
  createEffect(on([() => local.value, id], ([value, id]) => {
    context.contentIdsMap().set(value, id);
  }));
  return createComponent(Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps$1({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs(el => {
            presence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return id();
        },
        role: "tabpanel",
        get tabIndex() {
          return tabIndex();
        },
        get ["aria-labelledby"]() {
          return context.triggerIdsMap().get(local.value);
        },
        get ["data-orientation"]() {
          return context.orientation();
        },
        get ["data-selected"]() {
          return isSelected() ? "" : undefined;
        }
      }, others));
    }
  });
}

function TabsIndicator(props) {
  const context = useTabsContext();
  const [local, others] = splitProps(props, ["style"]);
  const [style, setStyle] = createSignal({
    width: undefined,
    height: undefined
  });
  const {
    direction
  } = useLocale();
  const computeStyle = () => {
    const selectedTab = context.selectedTab();
    if (selectedTab == null) {
      return;
    }
    const styleObj = {
      transform: undefined,
      width: undefined,
      height: undefined
    };
    const offset = direction() === "rtl" ? -1 * (selectedTab.offsetParent?.offsetWidth - selectedTab.offsetWidth - selectedTab.offsetLeft) : selectedTab.offsetLeft;
    styleObj.transform = context.orientation() === "vertical" ? `translateY(${selectedTab.offsetTop}px)` : `translateX(${offset}px)`;
    if (context.orientation() === "horizontal") {
      styleObj.width = `${selectedTab.offsetWidth}px`;
    } else {
      styleObj.height = `${selectedTab.offsetHeight}px`;
    }
    setStyle(styleObj);
  };
  onMount(() => {
    queueMicrotask(() => {
      computeStyle();
    });
  });
  createEffect(on([context.selectedTab, context.orientation, direction], () => {
    computeStyle();
  }, {
    defer: true
  }));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    role: "presentation",
    get style() {
      return {
        ...style(),
        ...local.style
      };
    },
    get ["data-orientation"]() {
      return context.orientation();
    }
  }, others));
}

class TabsKeyboardDelegate {
  constructor(collection, direction, orientation) {
    this.collection = collection;
    this.direction = direction;
    this.orientation = orientation;
  }
  flipDirection() {
    return this.direction() === "rtl" && this.orientation() === "horizontal";
  }
  getKeyLeftOf(key) {
    if (this.flipDirection()) {
      return this.getNextKey(key);
    }
    if (this.orientation() === "horizontal") {
      return this.getPreviousKey(key);
    }
    return undefined;
  }
  getKeyRightOf(key) {
    if (this.flipDirection()) {
      return this.getPreviousKey(key);
    }
    if (this.orientation() === "horizontal") {
      return this.getNextKey(key);
    }
    return undefined;
  }
  getKeyAbove(key) {
    if (this.orientation() === "vertical") {
      return this.getPreviousKey(key);
    }
    return undefined;
  }
  getKeyBelow(key) {
    if (this.orientation() === "vertical") {
      return this.getNextKey(key);
    }
    return undefined;
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.disabled) {
      key = this.getNextKey(key);
    }
    return key;
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.disabled) {
      key = this.getPreviousKey(key);
    }
    return key;
  }
  getNextKey(key) {
    let nextKey = key;
    let nextItem;
    do {
      nextKey = this.collection().getKeyAfter(nextKey) ?? this.collection().getFirstKey();
      if (nextKey == null) {
        return;
      }
      nextItem = this.collection().getItem(nextKey);
      if (nextItem == null) {
        return;
      }
    } while (nextItem.disabled);
    return nextKey;
  }
  getPreviousKey(key) {
    let previousKey = key;
    let previousItem;
    do {
      previousKey = this.collection().getKeyBefore(previousKey) ?? this.collection().getLastKey();
      if (previousKey == null) {
        return;
      }
      previousItem = this.collection().getItem(previousKey);
      if (previousItem == null) {
        return;
      }
    } while (previousItem.disabled);
    return previousKey;
  }
}

function TabsList(props) {
  let ref;
  const context = useTabsContext();
  const [local, others] = splitProps(props, ["ref", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const delegate = new TabsKeyboardDelegate(() => context.listState().collection(), direction, context.orientation);
  const selectableCollection = createSelectableCollection({
    selectionManager: () => context.listState().selectionManager(),
    keyboardDelegate: () => delegate,
    selectOnFocus: () => context.activationMode() === "automatic",
    shouldFocusWrap: false,
    disallowEmptySelection: true
  }, () => ref);
  createEffect(() => {
    if (ref == null) {
      return;
    }
    const selectedTab = ref.querySelector(`[data-key="${context.listState().selectedKey()}"]`);
    if (selectedTab != null) {
      context.setSelectedTab(selectedTab);
    }
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "tablist",
    get ["aria-orientation"]() {
      return context.orientation();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get onKeyDown() {
      return composeEventHandlers([local.onKeyDown, selectableCollection.onKeyDown]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableCollection.onMouseDown]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, selectableCollection.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, selectableCollection.onFocusOut]);
    }
  }, others));
}

function TabsRoot(props) {
  const defaultId = `tabs-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    orientation: "horizontal",
    activationMode: "automatic"
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "defaultValue", "onChange", "orientation", "activationMode", "disabled"]);
  const [items, setItems] = createSignal([]);
  const [selectedTab, setSelectedTab] = createSignal();
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createSingleSelectListState({
    selectedKey: () => local.value,
    defaultSelectedKey: () => local.defaultValue,
    onSelectionChange: key => local.onChange?.(String(key)),
    dataSource: items
  });
  let lastSelectedKey = listState.selectedKey();
  createEffect(on([() => listState.selectionManager(), () => listState.collection(), () => listState.selectedKey()], ([selectionManager, collection, currentSelectedKey]) => {
    let selectedKey = currentSelectedKey;
    if (selectionManager.isEmpty() || selectedKey == null || !collection.getItem(selectedKey)) {
      selectedKey = collection.getFirstKey();
      let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
      while (selectedItem?.disabled && selectedItem.key !== collection.getLastKey()) {
        selectedKey = collection.getKeyAfter(selectedItem.key);
        selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
      }
      if (selectedItem?.disabled && selectedKey === collection.getLastKey()) {
        selectedKey = collection.getFirstKey();
      }
      if (selectedKey != null) {
        selectionManager.setSelectedKeys([selectedKey]);
      }
    }
    if (selectionManager.focusedKey() == null || !selectionManager.isFocused() && selectedKey !== lastSelectedKey) {
      selectionManager.setFocusedKey(selectedKey);
    }
    lastSelectedKey = selectedKey;
  }));
  const triggerIdsMap = new Map();
  const contentIdsMap = new Map();
  const context = {
    isDisabled: () => local.disabled ?? false,
    orientation: () => local.orientation,
    activationMode: () => local.activationMode,
    triggerIdsMap: () => triggerIdsMap,
    contentIdsMap: () => contentIdsMap,
    listState: () => listState,
    selectedTab,
    setSelectedTab,
    generateTriggerId: value => `${others.id}-trigger-${value}`,
    generateContentId: value => `${others.id}-content-${value}`
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(TabsContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            get ["data-orientation"]() {
              return context.orientation();
            }
          }, others));
        }
      });
    }
  });
}

function TabsTrigger(props) {
  let ref;
  const context = useTabsContext();
  const mergedProps = mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "value", "disabled", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const id = () => local.id ?? context.generateTriggerId(local.value);
  const isHighlighted = () => context.listState().selectionManager().focusedKey() === local.value;
  const isDisabled = () => local.disabled || context.isDisabled();
  const contentId = () => context.contentIdsMap().get(local.value);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: local.value,
      textValue: "",
      disabled: isDisabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => local.value,
    selectionManager: () => context.listState().selectionManager(),
    disabled: isDisabled
  }, () => ref);
  const onClick = e => {
    if (isWebKit()) {
      focusWithoutScrolling(e.currentTarget);
    }
  };
  createEffect(on([() => local.value, id], ([value, id]) => {
    context.triggerIdsMap().set(value, id);
  }));
  return createComponent(Polymorphic, mergeProps$1({
    as: "button",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return id();
    },
    role: "tab",
    get tabIndex() {
      return memo(() => !!!isDisabled())() ? selectableItem.tabIndex() : undefined;
    },
    get disabled() {
      return isDisabled();
    },
    get ["aria-selected"]() {
      return selectableItem.isSelected();
    },
    get ["aria-disabled"]() {
      return isDisabled() || undefined;
    },
    get ["aria-controls"]() {
      return memo(() => !!selectableItem.isSelected())() ? contentId() : undefined;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get ["data-selected"]() {
      return selectableItem.isSelected() ? "" : undefined;
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return isDisabled() ? "" : undefined;
    },
    get onPointerDown() {
      return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return composeEventHandlers([local.onClick, selectableItem.onClick, onClick]);
    },
    get onKeyDown() {
      return composeEventHandlers([local.onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    }
  }, others));
}

var index$4 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Content: TabsContent,
	Indicator: TabsIndicator,
	List: TabsList,
	Root: TabsRoot,
	Trigger: TabsTrigger
});

const TextFieldContext = createContext();
function useTextFieldContext() {
  const context = useContext(TextFieldContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTextFieldContext` must be used within a `TextField` component");
  }
  return context;
}

function TextFieldInput(props) {
  return createComponent(TextFieldInputBase, mergeProps$1({
    type: "text"
  }, props));
}
function TextFieldInputBase(props) {
  const formControlContext = useFormControlContext();
  const context = useTextFieldContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(mergedProps, ["onInput"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  return createComponent(Polymorphic, mergeProps$1({
    as: "input",
    get id() {
      return fieldProps.id();
    },
    get name() {
      return formControlContext.name();
    },
    get value() {
      return context.value();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    get onInput() {
      return composeEventHandlers([local.onInput, context.onInput]);
    }
  }, () => formControlContext.dataset(), others));
}

function TextFieldRoot(props) {
  let ref;
  const defaultId = `textfield-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, formControlProps, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onChange"], FORM_CONTROL_PROP_NAMES);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setValue(local.defaultValue ?? ""));
  const onInput = e => {
    if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
      return;
    }
    const target = e.target;
    setValue(target.value);
    target.value = value() ?? "";
  };
  const context = {
    value,
    generateId: createGenerateId(() => access(formControlProps.id)),
    onInput
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(TextFieldContext.Provider, {
        value: context,
        get children() {
          return createComponent(Polymorphic, mergeProps$1({
            as: "div",
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return access(formControlProps.id);
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

function TextFieldTextArea(props) {
  let ref;
  const context = useTextFieldContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("textarea")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "autoResize", "submitOnEnter", "onKeyPress"]);
  createEffect(on([() => ref, () => local.autoResize, () => context.value()], ([ref, autoResize]) => {
    if (!ref || !autoResize) {
      return;
    }
    adjustHeight(ref);
  }));
  const onKeyPress = event => {
    if (ref && local.submitOnEnter && event.key === "Enter" && !event.shiftKey) {
      if (ref.form) {
        ref.form.requestSubmit();
        event.preventDefault();
      }
    }
  };
  return createComponent(TextFieldInputBase, mergeProps$1({
    as: "textarea",
    get ["aria-multiline"]() {
      return local.submitOnEnter ? "false" : undefined;
    },
    get onKeyPress() {
      return composeEventHandlers([local.onKeyPress, onKeyPress]);
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}
function adjustHeight(el) {
  const prevAlignment = el.style.alignSelf;
  const prevOverflow = el.style.overflow;
  const isFirefox = ("MozAppearance" in el.style);
  if (!isFirefox) {
    el.style.overflow = "hidden";
  }
  el.style.alignSelf = "start";
  el.style.height = "auto";
  el.style.height = `${el.scrollHeight + (el.offsetHeight - el.clientHeight)}px`;
  el.style.overflow = prevOverflow;
  el.style.alignSelf = prevAlignment;
}

var index$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Description: FormControlDescription,
	ErrorMessage: FormControlErrorMessage,
	Input: TextFieldInput,
	Label: FormControlLabel,
	Root: TextFieldRoot,
	TextArea: TextFieldTextArea
});

const ToastContext = createContext();
function useToastContext() {
  const context = useContext(ToastContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useToastContext` must be used within a `Toast.Root` component");
  }
  return context;
}

function ToastCloseButton(props) {
  const context = useToastContext();
  const [local, others] = splitProps(props, ["aria-label", "onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    context.close();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-label"]() {
      return local["aria-label"] || context.translations().close;
    },
    onClick: onClick
  }, others));
}

function ToastDescription(props) {
  const context = useToastContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get id() {
      return local.id;
    }
  }, others));
}

const ToastRegionContext = createContext();
function useToastRegionContext() {
  const context = useContext(ToastRegionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useToastRegionContext` must be used within a `Toast.Region` component");
  }
  return context;
}

const _tmpl$$2 = /*#__PURE__*/template(`<ol tabindex="-1">`);
function ToastList(props) {
  let ref;
  const context = useToastRegionContext();
  const [local, others] = splitProps(props, ["ref", "onFocusIn", "onFocusOut", "onPointerMove", "onPointerLeave"]);
  const onFocusIn = e => {
    callHandler(e, local.onFocusIn);
    if (context.pauseOnInteraction() && !context.isPaused()) {
      context.pauseAllTimer();
    }
  };
  const onFocusOut = e => {
    callHandler(e, local.onFocusOut);
    if (!contains(ref, e.relatedTarget)) {
      context.resumeAllTimer();
    }
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (context.pauseOnInteraction() && !context.isPaused()) {
      context.pauseAllTimer();
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (!contains(ref, getDocument(ref).activeElement)) {
      context.resumeAllTimer();
    }
  };
  createEffect(on([() => ref, () => context.hotkey()], ([ref, hotkey]) => {
    if (isServer) {
      return;
    }
    if (!ref) {
      return;
    }
    const doc = getDocument(ref);
    const onKeyDown = event => {
      const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);
      if (isHotkeyPressed) {
        focusWithoutScrolling(ref);
      }
    };
    doc.addEventListener("keydown", onKeyDown);
    onCleanup(() => doc.removeEventListener("keydown", onKeyDown));
  }));
  createEffect(() => {
    if (!context.pauseOnPageIdle()) {
      return;
    }
    const win = getWindow(ref);
    win.addEventListener("blur", context.pauseAllTimer);
    win.addEventListener("focus", context.resumeAllTimer);
    onCleanup(() => {
      win.removeEventListener("blur", context.pauseAllTimer);
      win.removeEventListener("focus", context.resumeAllTimer);
    });
  });
  return (() => {
    const _el$ = _tmpl$$2();
    _el$.addEventListener("pointerleave", onPointerLeave);
    _el$.$$pointermove = onPointerMove;
    _el$.$$focusout = onFocusOut;
    _el$.$$focusin = onFocusIn;
    const _ref$ = mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$);
    spread(_el$, others, false, true);
    insert(_el$, createComponent(For, {
      get each() {
        return context.toasts();
      },
      children: toast => toast.toastComponent({
        get toastId() {
          return toast.id;
        }
      })
    }));
    return _el$;
  })();
}
delegateEvents(["focusin", "focusout", "pointermove"]);

function ToastProgressFill(props) {
  const rootContext = useToastRegionContext();
  const context = useToastContext();
  const [local, others] = splitProps(props, ["style"]);
  const [lifeTime, setLifeTime] = createSignal(100);
  let totalElapsedTime = 0;
  createEffect(() => {
    if (rootContext.isPaused() || context.isPersistent()) {
      return;
    }
    const intervalId = setInterval(() => {
      const elapsedTime = new Date().getTime() - context.closeTimerStartTime() + totalElapsedTime;
      const life = Math.trunc(100 - elapsedTime / context.duration() * 100);
      setLifeTime(life < 0 ? 0 : life);
    });
    onCleanup(() => {
      totalElapsedTime += new Date().getTime() - context.closeTimerStartTime();
      clearInterval(intervalId);
    });
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get style() {
      return {
        "--kb-toast-progress-fill-width": `${lifeTime()}%`,
        ...local.style
      };
    }
  }, others));
}

function ToastProgressTrack(props) {
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    "aria-hidden": "true",
    role: "presentation"
  }, props));
}

const TOAST_HOTKEY_PLACEHOLDER = "{hotkey}";
const TOAST_INTL_TRANSLATIONS = {
  close: "Close"
};
const TOAST_REGION_INTL_TRANSLATIONS = {
  notifications: hotkeyPlaceholder => `Notifications (${hotkeyPlaceholder})`
};

const _tmpl$$1 = /*#__PURE__*/template(`<div role="region" tabindex="-1">`);
function ToastRegion(props) {
  const defaultId = `toast-region-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    hotkey: ["altKey", "KeyT"],
    duration: 5000,
    limit: 3,
    swipeDirection: "right",
    swipeThreshold: 50,
    pauseOnInteraction: true,
    pauseOnPageIdle: true,
    topLayer: true,
    translations: TOAST_REGION_INTL_TRANSLATIONS
  }, props);
  const [local, others] = splitProps(mergedProps, ["translations", "style", "hotkey", "duration", "limit", "swipeDirection", "swipeThreshold", "pauseOnInteraction", "pauseOnPageIdle", "topLayer", "aria-label", "regionId"]);
  const toasts = createMemo(() => toastStore.toasts().filter(toast => toast.region === local.regionId).slice(0, local.limit));
  const [isPaused, setIsPaused] = createSignal(false);
  const hasToasts = () => toasts().length > 0;
  const hotkeyLabel = () => {
    return local.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
  };
  const ariaLabel = () => {
    const label = local["aria-label"] || local.translations.notifications(TOAST_HOTKEY_PLACEHOLDER);
    return label.replace(TOAST_HOTKEY_PLACEHOLDER, hotkeyLabel());
  };
  const topLayerAttr = () => ({
    [DATA_TOP_LAYER_ATTR]: local.topLayer ? "" : undefined
  });
  const context = {
    isPaused,
    toasts,
    hotkey: () => local.hotkey,
    duration: () => local.duration,
    swipeDirection: () => local.swipeDirection,
    swipeThreshold: () => local.swipeThreshold,
    pauseOnInteraction: () => local.pauseOnInteraction,
    pauseOnPageIdle: () => local.pauseOnPageIdle,
    pauseAllTimer: () => setIsPaused(true),
    resumeAllTimer: () => setIsPaused(false),
    generateId: createGenerateId(() => others.id)
  };
  return createComponent(ToastRegionContext.Provider, {
    value: context,
    get children() {
      const _el$ = _tmpl$$1();
      spread(_el$, mergeProps$1({
        get ["aria-label"]() {
          return ariaLabel();
        },
        get style() {
          return {
            "pointer-events": hasToasts() ? local.topLayer ? "auto" : undefined : "none",
            ...local.style
          };
        }
      }, topLayerAttr, others), false, false);
      return _el$;
    }
  });
}

const _tmpl$ = /*#__PURE__*/template(`<li role="status" tabindex="0" aria-atomic="true">`);
const TOAST_SWIPE_START_EVENT = "toast.swipeStart";
const TOAST_SWIPE_MOVE_EVENT = "toast.swipeMove";
const TOAST_SWIPE_CANCEL_EVENT = "toast.swipeCancel";
const TOAST_SWIPE_END_EVENT = "toast.swipeEnd";
function ToastRoot(props) {
  const defaultId = `toast-${createUniqueId()}`;
  const rootContext = useToastRegionContext();
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    priority: "high",
    translations: TOAST_INTL_TRANSLATIONS
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "translations", "toastId", "style", "priority", "duration", "persistent", "onPause", "onResume", "onSwipeStart", "onSwipeMove", "onSwipeCancel", "onSwipeEnd", "onEscapeKeyDown", "onKeyDown", "onPointerDown", "onPointerMove", "onPointerUp"]);
  const [isOpen, setIsOpen] = createSignal(true);
  const [titleId, setTitleId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [isAnimationEnabled, setIsAnimationEnabled] = createSignal(true);
  const presence = createPresence(isOpen);
  const duration = createMemo(() => local.duration || rootContext.duration());
  let closeTimerId;
  let closeTimerStartTime = 0;
  let closeTimerRemainingTime = duration();
  let pointerStart = null;
  let swipeDelta = null;
  const close = () => {
    setIsOpen(false);
    setIsAnimationEnabled(true);
  };
  const deleteToast = () => {
    toastStore.remove(local.toastId);
  };
  const startTimer = duration => {
    if (!duration || local.persistent) {
      return;
    }
    window.clearTimeout(closeTimerId);
    closeTimerStartTime = new Date().getTime();
    closeTimerId = window.setTimeout(close, duration);
  };
  const resumeTimer = () => {
    startTimer(closeTimerRemainingTime);
    local.onResume?.();
  };
  const pauseTimer = () => {
    const elapsedTime = new Date().getTime() - closeTimerStartTime;
    closeTimerRemainingTime = closeTimerRemainingTime - elapsedTime;
    window.clearTimeout(closeTimerId);
    local.onPause?.();
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (e.key !== "Escape") {
      return;
    }
    local.onEscapeKeyDown?.(e);
    if (!e.defaultPrevented) {
      close();
    }
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    if (e.button !== 0) {
      return;
    }
    pointerStart = {
      x: e.clientX,
      y: e.clientY
    };
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (!pointerStart) {
      return;
    }
    const x = e.clientX - pointerStart.x;
    const y = e.clientY - pointerStart.y;
    const hasSwipeMoveStarted = Boolean(swipeDelta);
    const isHorizontalSwipe = ["left", "right"].includes(rootContext.swipeDirection());
    const clamp = ["left", "up"].includes(rootContext.swipeDirection()) ? Math.min : Math.max;
    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
    const moveStartBuffer = e.pointerType === "touch" ? 10 : 2;
    const delta = {
      x: clampedX,
      y: clampedY
    };
    const eventDetail = {
      originalEvent: e,
      delta
    };
    if (hasSwipeMoveStarted) {
      swipeDelta = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE_EVENT, local.onSwipeMove, eventDetail);
      const {
        x,
        y
      } = delta;
      e.currentTarget.setAttribute("data-swipe", "move");
      e.currentTarget.style.setProperty("--kb-toast-swipe-move-x", `${x}px`);
      e.currentTarget.style.setProperty("--kb-toast-swipe-move-y", `${y}px`);
    } else if (isDeltaInDirection(delta, rootContext.swipeDirection(), moveStartBuffer)) {
      swipeDelta = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_START_EVENT, local.onSwipeStart, eventDetail);
      e.currentTarget.setAttribute("data-swipe", "start");
      e.target.setPointerCapture(e.pointerId);
    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
      pointerStart = null;
    }
  };
  const onPointerUp = e => {
    callHandler(e, local.onPointerUp);
    const delta = swipeDelta;
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    swipeDelta = null;
    pointerStart = null;
    if (delta) {
      const toast = e.currentTarget;
      const eventDetail = {
        originalEvent: e,
        delta
      };
      if (isDeltaInDirection(delta, rootContext.swipeDirection(), rootContext.swipeThreshold())) {
        handleAndDispatchCustomEvent(TOAST_SWIPE_END_EVENT, local.onSwipeEnd, eventDetail);
        const {
          x,
          y
        } = delta;
        e.currentTarget.setAttribute("data-swipe", "end");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
        e.currentTarget.style.setProperty("--kb-toast-swipe-end-x", `${x}px`);
        e.currentTarget.style.setProperty("--kb-toast-swipe-end-y", `${y}px`);
        close();
      } else {
        handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL_EVENT, local.onSwipeCancel, eventDetail);
        e.currentTarget.setAttribute("data-swipe", "cancel");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-end-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-end-y");
      }
      toast.addEventListener("click", event => event.preventDefault(), {
        once: true
      });
    }
  };
  onMount(() => {
    if (rootContext.toasts().find(toast => toast.id === local.toastId && toast.update)) {
      setIsAnimationEnabled(false);
    }
  });
  createEffect(on(() => rootContext.isPaused(), isPaused => {
    if (isPaused) {
      pauseTimer();
    } else {
      resumeTimer();
    }
  }, {
    defer: true
  }));
  createEffect(on([isOpen, duration], ([isOpen, duration]) => {
    if (isOpen && !rootContext.isPaused()) {
      startTimer(duration);
    }
  }));
  createEffect(on(() => toastStore.get(local.toastId)?.dismiss, dismiss => dismiss && close()));
  createEffect(on(() => presence.isPresent(), isPresent => !isPresent && deleteToast()));
  const context = {
    translations: () => local.translations,
    close,
    duration,
    isPersistent: () => local.persistent ?? false,
    closeTimerStartTime: () => closeTimerStartTime,
    generateId: createGenerateId(() => others.id),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return createComponent(ToastContext.Provider, {
        value: context,
        get children() {
          const _el$ = _tmpl$();
          _el$.$$pointerup = onPointerUp;
          _el$.$$pointermove = onPointerMove;
          _el$.$$pointerdown = onPointerDown;
          _el$.$$keydown = onKeyDown;
          const _ref$ = mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && use(_ref$, _el$);
          spread(_el$, mergeProps$1({
            get style() {
              return {
                animation: isAnimationEnabled() ? undefined : "none",
                "user-select": "none",
                "touch-action": "none",
                ...local.style
              };
            },
            get ["aria-live"]() {
              return local.priority === "high" ? "assertive" : "polite";
            },
            get ["aria-labelledby"]() {
              return titleId();
            },
            get ["aria-describedby"]() {
              return descriptionId();
            },
            get ["data-opened"]() {
              return isOpen() ? "" : undefined;
            },
            get ["data-closed"]() {
              return !isOpen() ? "" : undefined;
            },
            get ["data-swipe-direction"]() {
              return rootContext.swipeDirection();
            }
          }, others), false, false);
          return _el$;
        }
      });
    }
  });
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  }
  return !isDeltaX && deltaY > threshold;
}
function handleAndDispatchCustomEvent(name, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, {
    bubbles: true,
    cancelable: true,
    detail
  });
  if (handler) {
    currentTarget.addEventListener(name, handler, {
      once: true
    });
  }
  currentTarget.dispatchEvent(event);
}
delegateEvents(["keydown", "pointerdown", "pointermove", "pointerup"]);

function ToastTitle(props) {
  const context = useToastContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerTitleId(local.id)));
  return createComponent(Polymorphic, mergeProps$1({
    as: "div",
    get id() {
      return local.id;
    }
  }, others));
}

var index$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CloseButton: ToastCloseButton,
	Description: ToastDescription,
	List: ToastList,
	ProgressFill: ToastProgressFill,
	ProgressTrack: ToastProgressTrack,
	Region: ToastRegion,
	Root: ToastRoot,
	Title: ToastTitle
});

function ToggleButtonRoot(props) {
  const [local, others] = splitProps(props, ["children", "pressed", "defaultPressed", "onChange", "onClick"]);
  const state = createToggleState({
    isSelected: () => local.pressed,
    defaultIsSelected: () => local.defaultPressed,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => others.disabled
  });
  const onClick = e => {
    callHandler(e, local.onClick);
    state.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-pressed"]() {
      return state.isSelected();
    },
    get ["data-pressed"]() {
      return state.isSelected() ? "" : undefined;
    },
    onClick: onClick
  }, others, {
    get children() {
      return createComponent(ToggleButtonRootChild, {
        get state() {
          return {
            pressed: state.isSelected
          };
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
function ToggleButtonRootChild(props) {
  const resolvedChildren = children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
  return memo(resolvedChildren);
}

var index$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Root: ToggleButtonRoot
});

const TooltipContext = createContext();
function useTooltipContext() {
  const context = useContext(TooltipContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTooltipContext` must be used within a `Tooltip` component");
  }
  return context;
}

function TooltipContent(props) {
  const context = useTooltipContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style"]);
  createEffect(() => onCleanup(context.registerContentId(others.id)));
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "tooltip",
            disableOutsidePointerEvents: false,
            get style() {
              return {
                "--kb-tooltip-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            onDismiss: () => context.hideTooltip(true)
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function TooltipPortal(props) {
  const context = useTooltipContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

function getTooltipSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

const tooltips = {};
let tooltipsCounter = 0;
let globalWarmedUp = false;
let globalWarmUpTimeout;
let globalCoolDownTimeout;
function TooltipRoot(props) {
  const defaultId = `tooltip-${createUniqueId()}`;
  const tooltipId = `${++tooltipsCounter}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = splitProps(mergedProps, ["id", "open", "defaultOpen", "onOpenChange", "disabled", "triggerOnFocusOnly", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let closeTimeoutId;
  const [contentId, setContentId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [currentPlacement, setCurrentPlacement] = createSignal(others.placement);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const ensureTooltipEntry = () => {
    tooltips[tooltipId] = hideTooltip;
  };
  const closeOpenTooltips = () => {
    for (const hideTooltipId in tooltips) {
      if (hideTooltipId !== tooltipId) {
        tooltips[hideTooltipId](true);
        delete tooltips[hideTooltipId];
      }
    }
  };
  const hideTooltip = (immediate = false) => {
    if (isServer) {
      return;
    }
    if (immediate || local.closeDelay && local.closeDelay <= 0) {
      window.clearTimeout(closeTimeoutId);
      closeTimeoutId = undefined;
      disclosureState.close();
    } else if (!closeTimeoutId) {
      closeTimeoutId = window.setTimeout(() => {
        closeTimeoutId = undefined;
        disclosureState.close();
      }, local.closeDelay);
    }
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    if (globalWarmedUp) {
      window.clearTimeout(globalCoolDownTimeout);
      globalCoolDownTimeout = window.setTimeout(() => {
        delete tooltips[tooltipId];
        globalCoolDownTimeout = undefined;
        globalWarmedUp = false;
      }, local.closeDelay);
    }
  };
  const showTooltip = () => {
    if (isServer) {
      return;
    }
    clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
    closeOpenTooltips();
    ensureTooltipEntry();
    globalWarmedUp = true;
    disclosureState.open();
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    window.clearTimeout(globalCoolDownTimeout);
    globalCoolDownTimeout = undefined;
  };
  const warmupTooltip = () => {
    if (isServer) {
      return;
    }
    closeOpenTooltips();
    ensureTooltipEntry();
    if (!disclosureState.isOpen() && !globalWarmUpTimeout && !globalWarmedUp) {
      globalWarmUpTimeout = window.setTimeout(() => {
        globalWarmUpTimeout = undefined;
        globalWarmedUp = true;
        showTooltip();
      }, local.openDelay);
    } else if (!disclosureState.isOpen()) {
      showTooltip();
    }
  };
  const openTooltip = (immediate = false) => {
    if (isServer) {
      return;
    }
    if (!immediate && local.openDelay && local.openDelay > 0 && !closeTimeoutId) {
      warmupTooltip();
    } else {
      showTooltip();
    }
  };
  const cancelOpening = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    globalWarmedUp = false;
  };
  const cancelClosing = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnTooltip = target => {
    return contains(triggerRef(), target) || contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getTooltipSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;
    if (isTargetOnTooltip(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());
      if (polygon && isPointInPolygon(getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }
    if (closeTimeoutId) {
      return;
    }
    hideTooltip();
  };
  createEffect(() => {
    if (isServer) {
      return;
    }
    if (!disclosureState.isOpen()) {
      return;
    }
    const doc = getDocument();
    doc.addEventListener("pointermove", onHoverOutside, true);
    onCleanup(() => {
      doc.removeEventListener("pointermove", onHoverOutside, true);
    });
  });
  createEffect(() => {
    const trigger = triggerRef();
    if (!trigger || !disclosureState.isOpen()) {
      return;
    }
    const handleScroll = event => {
      const target = event.target;
      if (contains(target, trigger)) {
        hideTooltip(true);
      }
    };
    const win = getWindow();
    win.addEventListener("scroll", handleScroll, {
      capture: true
    });
    onCleanup(() => {
      win.removeEventListener("scroll", handleScroll, {
        capture: true
      });
    });
  });
  onCleanup(() => {
    clearTimeout(closeTimeoutId);
    const tooltip = tooltips[tooltipId];
    if (tooltip) {
      delete tooltips[tooltipId];
    }
  });
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => local.disabled ?? false,
    triggerOnFocusOnly: () => local.triggerOnFocusOnly ?? false,
    contentId,
    contentPresence,
    openTooltip,
    hideTooltip,
    cancelOpening,
    generateId: createGenerateId(() => mergedProps.id),
    registerContentId: createRegisterId(setContentId),
    isTargetOnTooltip,
    setTriggerRef,
    setContentRef
  };
  return createComponent(TooltipContext.Provider, {
    value: context,
    get children() {
      return createComponent(PopperRoot, mergeProps$1({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
}

function TooltipTrigger(props) {
  let ref;
  const context = useTooltipContext();
  const [local, others] = splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onPointerDown", "onClick", "onFocus", "onBlur", "onTouchStart"]);
  let isPointerDown = false;
  let isHovered = false;
  let isFocused = false;
  const handlePointerUp = () => {
    isPointerDown = false;
  };
  const handleShow = () => {
    if (!context.isOpen() && (isHovered || isFocused)) {
      context.openTooltip(isFocused);
    }
  };
  const handleHide = immediate => {
    if (context.isOpen() && !isHovered && !isFocused) {
      context.hideTooltip(immediate);
    }
  };
  const onPointerEnter = e => {
    callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || context.triggerOnFocusOnly() || context.isDisabled() || e.defaultPrevented) {
      return;
    }
    isHovered = true;
    handleShow();
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }
    isHovered = false;
    isFocused = false;
    if (context.isOpen()) {
      handleHide();
    } else {
      context.cancelOpening();
    }
  };
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);
    isPointerDown = true;
    getDocument(ref).addEventListener("pointerup", handlePointerUp, {
      once: true
    });
  };
  const onClick = e => {
    callHandler(e, local.onClick);
    isHovered = false;
    isFocused = false;
    handleHide(true);
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (context.isDisabled() || e.defaultPrevented || isPointerDown) {
      return;
    }
    isFocused = true;
    handleShow();
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnTooltip(relatedTarget)) {
      return;
    }
    isHovered = false;
    isFocused = false;
    handleHide(true);
  };
  onCleanup(() => {
    if (isServer) {
      return;
    }
    getDocument(ref).removeEventListener("pointerup", handlePointerUp);
  });
  return createComponent(Polymorphic, mergeProps$1({
    as: "button",
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["aria-describedby"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onPointerDown: onPointerDown,
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), others));
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Arrow: PopperArrow,
	Content: TooltipContent,
	Portal: TooltipPortal,
	Root: TooltipRoot,
	Trigger: TooltipTrigger
});

export { index$u as Accordion, index$t as Alert, index$r as AlertDialog, As, index$p as Breadcrumbs, index$w as Button, COLOR_MODE_STORAGE_KEY, index$o as Calendar, index$n as Checkbox, index$v as Collapsible, ColorModeContext, ColorModeProvider, ColorModeScript, index$l as Combobox, index$j as ContextMenu, DATA_LIVE_ANNOUNCER_ATTR, index$i as DatePicker, index$s as Dialog, index$h as DropdownMenu, FORM_CONTROL_FIELD_PROP_NAMES, FORM_CONTROL_PROP_NAMES, FormControlContext, FormControlDescription, FormControlErrorMessage, FormControlLabel, index$g as HoverCard, I18nProvider, index$f as Image, index$q as Link, ListCollection, ListKeyboardDelegate, index$m as Listbox, index$e as Menubar, index$d as NumberField, index$c as Pagination, Polymorphic, index$b as Popover, index$a as Progress, RTL_LANGS, index$9 as RadioGroup, index$8 as Select, Selection, SelectionManager, index$k as Separator, index$7 as Skeleton, index$6 as Slider, index$5 as Switch, index$4 as Tabs, index$3 as TextField, index$2 as Toast, index$1 as ToggleButton, index as Tooltip, announce, ariaHideOutside, clearAnnouncer, cookieStorageManager, cookieStorageManagerSSR, createCollator, createCollection, createControllableArraySignal, createControllableBooleanSignal, createControllableSetSignal, createControllableSignal, createCookieStorageManager, createDateFormatter, createDefaultLocale, createDisclosureState, createEscapeKeyDown, createFilter, createFocusScope, createFormControl, createFormControlField, createFormResetListener, createHideOutside, createInteractOutside, createListState, createLocalStorageManager, createMultipleSelectionState, createNumberFormatter, createPresence, createRegisterId, createSelectableCollection, createSelectableItem, createSelectableList, createSingleSelectListState, createTagName, createToggleState, createTransition, createTypeSelect, destroyAnnouncer, getDefaultLocale, getItemCount, getReadingDirection, isRTL, localStorageManager, toaster, useColorMode, useColorModeValue, useFormControlContext, useLocale };
//# sourceMappingURL=index.js.map
