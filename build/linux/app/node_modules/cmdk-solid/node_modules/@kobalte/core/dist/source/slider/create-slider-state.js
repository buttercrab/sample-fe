/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/1ddcde7b4fef9af7f08e11bb78d71fe60bbcc64b/packages/@react-stately/slider/src/useSliderState.ts
 */
import { clamp, mergeDefaultProps, snapValueToStep } from "@kobalte/utils";
import { createMemo, createSignal } from "solid-js";
import { createControllableArraySignal } from "../primitives";
import { getNextSortedValues, hasMinStepsBetweenValues } from "./utils";
export function createSliderState(props) {
    const mergedProps = mergeDefaultProps({
        minValue: () => 0,
        maxValue: () => 100,
        step: () => 1,
        minStepsBetweenThumbs: () => 0,
        orientation: () => "horizontal",
        isDisabled: () => false,
    }, props);
    const pageSize = createMemo(() => {
        let calcPageSize = (mergedProps.maxValue() - mergedProps.minValue()) / 10;
        calcPageSize = snapValueToStep(calcPageSize, 0, calcPageSize + mergedProps.step(), mergedProps.step());
        return Math.max(calcPageSize, mergedProps.step());
    });
    const defaultValue = createMemo(() => {
        return mergedProps.defaultValue() ?? [mergedProps.minValue()];
    });
    const [values, setValues] = createControllableArraySignal({
        value: () => mergedProps.value(),
        defaultValue,
        onChange: (values) => mergedProps.onChange?.(values),
    });
    const [isDragging, setIsDragging] = createSignal(new Array(values().length).fill(false));
    const [isEditables, setEditables] = createSignal(new Array(values().length).fill(false));
    const [focusedIndex, setFocusedIndex] = createSignal(undefined);
    const resetValues = () => {
        setValues(defaultValue());
    };
    const getValuePercent = (value) => {
        return ((value - mergedProps.minValue()) /
            (mergedProps.maxValue() - mergedProps.minValue()));
    };
    const getThumbMinValue = (index) => {
        return index === 0
            ? props.minValue()
            : values()[index - 1] + props.minStepsBetweenThumbs() * props.step();
    };
    const getThumbMaxValue = (index) => {
        return index === values().length - 1
            ? props.maxValue()
            : values()[index + 1] - props.minStepsBetweenThumbs() * props.step();
    };
    const isThumbEditable = (index) => {
        return isEditables()[index];
    };
    const setThumbEditable = (index) => {
        setEditables((p) => {
            p[index] = true;
            return p;
        });
    };
    const updateValue = (index, value) => {
        if (mergedProps.isDisabled() || !isThumbEditable(index))
            return;
        const snappedValue = snapValueToStep(value, getThumbMinValue(index), getThumbMaxValue(index), mergedProps.step());
        const nextValues = getNextSortedValues(values(), snappedValue, index);
        if (!hasMinStepsBetweenValues(nextValues, mergedProps.minStepsBetweenThumbs() * mergedProps.step())) {
            return;
        }
        setValues((prev) => [...replaceIndex(prev, index, snappedValue)]);
    };
    const updateDragging = (index, dragging) => {
        if (mergedProps.isDisabled() || !isThumbEditable(index))
            return;
        const wasDragging = isDragging()[index];
        setIsDragging((p) => [...replaceIndex(p, index, dragging)]);
        if (wasDragging && !isDragging().some(Boolean)) {
            mergedProps.onChangeEnd?.(values());
        }
    };
    const getFormattedValue = (value) => {
        return mergedProps.numberFormatter.format(value);
    };
    const setThumbPercent = (index, percent) => {
        updateValue(index, getPercentValue(percent));
    };
    const getRoundedValue = (value) => {
        return (Math.round((value - mergedProps.minValue()) / mergedProps.step()) *
            mergedProps.step() +
            mergedProps.minValue());
    };
    const getPercentValue = (percent) => {
        const val = percent * (mergedProps.maxValue() - mergedProps.minValue()) +
            mergedProps.minValue();
        return clamp(getRoundedValue(val), mergedProps.minValue(), mergedProps.maxValue());
    };
    const snapThumbValue = (index, value) => {
        const nextValue = values()[index] + value;
        const nextValues = getNextSortedValues(values(), nextValue, index);
        if (hasMinStepsBetweenValues(nextValues, mergedProps.minStepsBetweenThumbs() * mergedProps.step())) {
            updateValue(index, snapValueToStep(nextValue, mergedProps.minValue(), mergedProps.maxValue(), mergedProps.step()));
        }
    };
    const incrementThumb = (index, stepSize = 1) => {
        snapThumbValue(index, Math.max(stepSize, props.step()));
    };
    const decrementThumb = (index, stepSize = 1) => {
        snapThumbValue(index, -Math.max(stepSize, props.step()));
    };
    return {
        values,
        getThumbValue: (index) => values()[index],
        setThumbValue: updateValue,
        setThumbPercent,
        isThumbDragging: (index) => isDragging()[index],
        setThumbDragging: updateDragging,
        focusedThumb: focusedIndex,
        setFocusedThumb: setFocusedIndex,
        getThumbPercent: (index) => getValuePercent(values()[index]),
        getValuePercent,
        getThumbValueLabel: (index) => getFormattedValue(values()[index]),
        getFormattedValue,
        getThumbMinValue,
        getThumbMaxValue,
        getPercentValue,
        isThumbEditable,
        setThumbEditable,
        incrementThumb,
        decrementThumb,
        step: mergedProps.step,
        pageSize,
        orientation: mergedProps.orientation,
        isDisabled: mergedProps.isDisabled,
        setValues,
        resetValues,
    };
}
function replaceIndex(array, index, value) {
    if (array[index] === value) {
        return array;
    }
    return [...array.slice(0, index), value, ...array.slice(index + 1)];
}
