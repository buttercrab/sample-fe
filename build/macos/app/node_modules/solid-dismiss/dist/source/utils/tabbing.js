const _tabbableSelectors = [
    "a[href]",
    "area[href]",
    "input:not([disabled])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "iframe",
    "[tabindex]",
    "[contentEditable=true]",
].reduce((a, c, idx) => `${a}${idx ? "," : ""}${c}:not([tabindex="-1"])`, "");
let willWrap = false;
let originalFrom = null;
export const getNextTabbableElement = ({ from: _from, stopAtRootElement: stopAtRootElement, ignoreElement = [], allowSelectors, direction = "forwards", wrap, }) => {
    let fromResult;
    let _isFromElIframe = false;
    if (!(_from instanceof Element)) {
        if (_from === "activeElement") {
            const activeElement = document.activeElement;
            _isFromElIframe = isIframe(activeElement);
            fromResult = getActiveElement(activeElement);
        }
        if (typeof _from === "object") {
            if (_from.getActiveElement) {
                fromResult = getActiveElement(_from.el);
            }
            _isFromElIframe = _from.isIframe;
        }
    }
    else {
        _isFromElIframe = isIframe(_from);
        fromResult = _from;
    }
    const from = fromResult;
    const parent = from.parentElement;
    const isFromElIframe = _isFromElIframe;
    const visitedElement = from;
    const tabbableSelectors = _tabbableSelectors + (allowSelectors ? "," + allowSelectors.join(",") : "");
    if (!visitedElement)
        return null;
    const traverseNextSiblingsThenUp = (parent, visitedElement) => {
        let hasPassedVisitedElement = false;
        const children = parent.children;
        const childrenCount = children.length;
        if (willWrap) {
            hasPassedVisitedElement = true;
        }
        if (direction === "forwards") {
            for (let i = 0; i < childrenCount; i++) {
                const child = children[i];
                if (hasPassedVisitedElement) {
                    const el = queryTabbableElement(child, tabbableSelectors, direction, ignoreElement);
                    if (el) {
                        return el;
                    }
                    continue;
                }
                if (child === stopAtRootElement) {
                    return null;
                }
                if (child === visitedElement) {
                    hasPassedVisitedElement = true;
                    continue;
                }
            }
        }
        else {
            for (let i = childrenCount - 1; i >= 0; i--) {
                const child = children[i];
                if (hasPassedVisitedElement) {
                    const el = queryTabbableElement(child, tabbableSelectors, direction, ignoreElement);
                    if (el)
                        return el;
                    continue;
                }
                if (child === stopAtRootElement) {
                    return null;
                }
                if (child === visitedElement) {
                    hasPassedVisitedElement = true;
                    continue;
                }
            }
        }
        visitedElement = parent;
        parent = parent.parentElement;
        if (!parent && isFromElIframe) {
            // TODO: only get's top level iframe, should get correct iframe
            const iframe = document.activeElement;
            if (iframe && isIframe(iframe)) {
                visitedElement = iframe;
                parent = iframe.parentElement;
            }
        }
        if (!parent) {
            return null;
        }
        return traverseNextSiblingsThenUp(parent, visitedElement);
    };
    let result = traverseNextSiblingsThenUp(parent, visitedElement);
    if (!result && wrap && stopAtRootElement) {
        willWrap = true;
        originalFrom = from;
        result = getNextTabbableElement({
            from: stopAtRootElement,
            allowSelectors,
            direction,
            ignoreElement,
            // stopAtElement,
            wrap: false,
        });
    }
    willWrap = false;
    originalFrom = null;
    return result;
};
const getIframeWindow = (iframe) => {
    try {
        return iframe.contentWindow;
    }
    catch (e) {
        return null;
    }
};
const getIframeDocument = (iframe) => {
    const iframeWindow = getIframeWindow(iframe);
    if (!iframeWindow)
        return null;
    return iframeWindow.document;
};
const getActiveElement = (el) => {
    // TODO: only goes one depth, should go infinitly
    if (!isIframe(el))
        return el;
    const iframeDocument = getIframeDocument(el);
    if (!iframeDocument)
        return el;
    return iframeDocument.activeElement || el;
};
const isHidden = (el, windowContext = window) => {
    const checkByStyle = (style) => style.display === "none" || style.visibility === "hidden";
    if ((el.style && checkByStyle(el.style)) || el.hidden)
        return true;
    const style = windowContext.getComputedStyle(el);
    if (!style || checkByStyle(style))
        return true;
    return false;
};
export const queryTabbableElement = (el, selectors = _tabbableSelectors, iterationDirection = "forwards", ignoreElement = [], windowContext = window, init = true) => {
    const queryChild = (el) => {
        if (!el.matches(selectors))
            return {
                el,
                matched: false,
            };
        const tabindex = el.getAttribute("tabindex");
        if (isIframe(el) && (!tabindex || tabindex === "-1")) {
            const iframeWindow = getIframeWindow(el);
            if (!iframeWindow) {
                return { el, matched: true };
            }
            el = iframeWindow.document.documentElement;
            windowContext = iframeWindow;
            return { el, matched: false, windowContext: iframeWindow };
        }
        return {
            el,
            matched: true,
        };
    };
    if (init) {
        if (ignoreElement.some((item) => item === el) ||
            isHidden(el, windowContext))
            return null;
        const { el: elResult, matched, windowContext: windowContextResult, } = queryChild(el);
        el = elResult;
        if (matched)
            return el;
        windowContext = windowContextResult || windowContext;
        return queryTabbableElement(el, selectors, iterationDirection, ignoreElement, windowContext, false);
    }
    const shadowRoot = el.shadowRoot;
    if (shadowRoot)
        el = shadowRoot;
    const children = el.children;
    const childrenLength = children.length;
    const iterateChild = (el) => {
        if (ignoreElement.some((item) => item === el) ||
            isHidden(el, windowContext))
            return {
                continue: true,
            };
        const { el: elResult, matched, windowContext: windowContextResult, } = queryChild(el);
        el = elResult;
        windowContext = windowContextResult || windowContext;
        if (matched) {
            return { returnVal: el };
        }
        const foundChild = queryTabbableElement(el, selectors, iterationDirection, ignoreElement, windowContext, false);
        if (foundChild)
            return { returnVal: foundChild };
        return null;
    };
    if (iterationDirection === "forwards") {
        for (let i = 0; i < childrenLength; i++) {
            let child = children[i];
            const result = iterateChild(child);
            if (result) {
                if (result.continue)
                    continue;
                if (result.returnVal)
                    return result.returnVal;
            }
        }
    }
    else {
        for (let i = childrenLength - 1; i >= 0; i--) {
            let child = children[i];
            const result = iterateChild(child);
            if (result) {
                if (result.continue)
                    continue;
                if (result.returnVal)
                    return result.returnVal;
            }
        }
    }
    return null;
};
const isIframe = (el) => el.tagName === "IFRAME";
