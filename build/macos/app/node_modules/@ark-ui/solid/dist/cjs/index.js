'use strict';

var solidJs = require('solid-js');
var web = require('solid-js/web');
var solid = require('@zag-js/solid');
var collapsible$1 = require('@zag-js/collapsible');
var accordion$1 = require('@zag-js/accordion');
var avatar$1 = require('@zag-js/avatar');
var carousel$1 = require('@zag-js/carousel');
var checkbox$1 = require('@zag-js/checkbox');
var clipboard$1 = require('@zag-js/clipboard');
var colorPicker$1 = require('@zag-js/color-picker');
var presence = require('@zag-js/presence');
var combobox$1 = require('@zag-js/combobox');
var datePicker$1 = require('@zag-js/date-picker');
var dialog$1 = require('@zag-js/dialog');
var editable$1 = require('@zag-js/editable');
var domQuery = require('@zag-js/dom-query');
var anatomy = require('@zag-js/anatomy');
var fileUpload$1 = require('@zag-js/file-upload');
var i18nUtils = require('@zag-js/i18n-utils');
var hoverCard$1 = require('@zag-js/hover-card');
var menu$1 = require('@zag-js/menu');
var numberInput$1 = require('@zag-js/number-input');
var pagination$1 = require('@zag-js/pagination');
var pinInput$1 = require('@zag-js/pin-input');
var popover$1 = require('@zag-js/popover');
var progress$1 = require('@zag-js/progress');
var qrCode$1 = require('@zag-js/qr-code');
var radio = require('@zag-js/radio-group');
var rating = require('@zag-js/rating-group');
var select$1 = require('@zag-js/select');
var signaturePad$1 = require('@zag-js/signature-pad');
var slider$1 = require('@zag-js/slider');
var splitter$1 = require('@zag-js/splitter');
var zagSwitch = require('@zag-js/switch');
var tabs$1 = require('@zag-js/tabs');
var tagsInput$1 = require('@zag-js/tags-input');
var date = require('@internationalized/date');
var timePicker$1 = require('@zag-js/time-picker');
var toast$1 = require('@zag-js/toast');
var toggleGroup$1 = require('@zag-js/toggle-group');
var tooltip$1 = require('@zag-js/tooltip');
var treeView$1 = require('@zag-js/tree-view');
var timer$1 = require('@zag-js/timer');
var steps$1 = require('@zag-js/steps');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var collapsible__namespace = /*#__PURE__*/_interopNamespaceDefault(collapsible$1);
var accordion__namespace = /*#__PURE__*/_interopNamespaceDefault(accordion$1);
var avatar__namespace = /*#__PURE__*/_interopNamespaceDefault(avatar$1);
var carousel__namespace = /*#__PURE__*/_interopNamespaceDefault(carousel$1);
var checkbox__namespace = /*#__PURE__*/_interopNamespaceDefault(checkbox$1);
var clipboard__namespace = /*#__PURE__*/_interopNamespaceDefault(clipboard$1);
var colorPicker__namespace = /*#__PURE__*/_interopNamespaceDefault(colorPicker$1);
var presence__namespace = /*#__PURE__*/_interopNamespaceDefault(presence);
var combobox__namespace = /*#__PURE__*/_interopNamespaceDefault(combobox$1);
var datePicker__namespace = /*#__PURE__*/_interopNamespaceDefault(datePicker$1);
var dialog__namespace = /*#__PURE__*/_interopNamespaceDefault(dialog$1);
var editable__namespace = /*#__PURE__*/_interopNamespaceDefault(editable$1);
var fileUpload__namespace = /*#__PURE__*/_interopNamespaceDefault(fileUpload$1);
var hoverCard__namespace = /*#__PURE__*/_interopNamespaceDefault(hoverCard$1);
var menu__namespace = /*#__PURE__*/_interopNamespaceDefault(menu$1);
var numberInput__namespace = /*#__PURE__*/_interopNamespaceDefault(numberInput$1);
var pagination__namespace = /*#__PURE__*/_interopNamespaceDefault(pagination$1);
var pinInput__namespace = /*#__PURE__*/_interopNamespaceDefault(pinInput$1);
var popover__namespace = /*#__PURE__*/_interopNamespaceDefault(popover$1);
var progress__namespace = /*#__PURE__*/_interopNamespaceDefault(progress$1);
var qrCode__namespace = /*#__PURE__*/_interopNamespaceDefault(qrCode$1);
var radio__namespace = /*#__PURE__*/_interopNamespaceDefault(radio);
var rating__namespace = /*#__PURE__*/_interopNamespaceDefault(rating);
var select__namespace = /*#__PURE__*/_interopNamespaceDefault(select$1);
var signaturePad__namespace = /*#__PURE__*/_interopNamespaceDefault(signaturePad$1);
var slider__namespace = /*#__PURE__*/_interopNamespaceDefault(slider$1);
var splitter__namespace = /*#__PURE__*/_interopNamespaceDefault(splitter$1);
var zagSwitch__namespace = /*#__PURE__*/_interopNamespaceDefault(zagSwitch);
var tabs__namespace = /*#__PURE__*/_interopNamespaceDefault(tabs$1);
var tagsInput__namespace = /*#__PURE__*/_interopNamespaceDefault(tagsInput$1);
var timePicker__namespace = /*#__PURE__*/_interopNamespaceDefault(timePicker$1);
var toast__namespace = /*#__PURE__*/_interopNamespaceDefault(toast$1);
var toggleGroup__namespace = /*#__PURE__*/_interopNamespaceDefault(toggleGroup$1);
var tooltip__namespace = /*#__PURE__*/_interopNamespaceDefault(tooltip$1);
var treeView__namespace = /*#__PURE__*/_interopNamespaceDefault(treeView$1);
var timer__namespace = /*#__PURE__*/_interopNamespaceDefault(timer$1);
var steps__namespace = /*#__PURE__*/_interopNamespaceDefault(steps$1);

function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    strict = true,
    hookName = 'useContext',
    providerName = 'Provider',
    errorMessage,
    defaultValue
  } = options;
  const Context = solidJs.createContext(defaultValue);
  function useContext() {
    const context = solidJs.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = 'ContextError';
      Error.captureStackTrace?.(error, useContext);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext, Context];
}

const [AccordionProvider, useAccordionContext] = createContext({
  hookName: 'useAccordionContext',
  providerName: '<AccordionProvider />'
});

const AccordionContext = props => props.children(useAccordionContext());

const createSplitProps = () => (props, keys) => solidJs.splitProps(props, keys);

const [RenderStrategyProvider, useRenderStrategyContext] = createContext({
  hookName: 'useRenderStrategyContext',
  providerName: '<RenderStrategyProvider />'
});
const splitRenderStrategyProps = props => createSplitProps()(props, ['lazyMount', 'unmountOnExit']);

const withAsProp = Component => {
  const ArkComponent = props => {
    const [localProps, parentProps] = solidJs.splitProps(props, ['asChild']);
    if (localProps.asChild) {
      // @ts-expect-error
      const propsFn = userProps => {
        const [, restProps] = solidJs.splitProps(parentProps, ['ref']);
        return solid.mergeProps(restProps, userProps);
      };
      return localProps.asChild(propsFn);
    }
    // @ts-expect-error
    return web.createComponent(web.Dynamic, web.mergeProps({
      component: Component
    }, parentProps));
  };
  return ArkComponent;
};
function jsxFactory() {
  const cache = new Map();
  return new Proxy(withAsProp, {
    apply(_target, _thisArg, argArray) {
      return withAsProp(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache.has(asElement)) {
        cache.set(asElement, withAsProp(asElement));
      }
      return cache.get(asElement);
    }
  });
}
const ark = jsxFactory();

const [CollapsibleProvider, useCollapsibleContext] = createContext({
  hookName: 'useCollapsibleContext',
  providerName: '<CollapsibleProvider />'
});

const CollapsibleContent = props => {
  const api = useCollapsibleContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !api().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const CollapsibleContext = props => props.children(useCollapsibleContext());

const isFunction = value => typeof value === 'function';
const runIfFn = (valueOrFn, ...args) => isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;

const [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  hookName: 'useEnvironmentContext',
  providerName: '<EnvironmentProvider />',
  strict: false,
  defaultValue: () => ({
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  })
});

var _tmpl$$6 = /*#__PURE__*/web.template(`<span hidden>`);
const EnvironmentProvider = props => {
  const [spanRef, setSpanRef] = solidJs.createSignal();
  const getRootNode = () => runIfFn(props.value) ?? spanRef()?.ownerDocument ?? document;
  const environment = solidJs.createMemo(() => ({
    getRootNode,
    getDocument: () => domQuery.getDocument(getRootNode()),
    getWindow: () => domQuery.getWindow(getRootNode())
  }));
  return web.createComponent(EnvironmentContextProvider, {
    value: environment,
    get children() {
      return [web.memo(() => props.children), web.createComponent(solidJs.Show, {
        get when() {
          return !props.value;
        },
        get children() {
          var _el$ = _tmpl$$6();
          web.use(setSpanRef, _el$);
          return _el$;
        }
      })];
    }
  });
};

const [LocaleContextProvider, useLocaleContext] = createContext({
  hookName: 'useEnvironmentContext',
  providerName: '<EnvironmentProvider />',
  strict: false,
  defaultValue: () => ({
    dir: 'ltr',
    locale: 'en-US'
  })
});

const LocaleProvider = props => {
  const context = solidJs.createMemo(() => ({
    locale: props.locale,
    dir: i18nUtils.isRTL(props.locale) ? 'rtl' : 'ltr'
  }));
  return web.createComponent(LocaleContextProvider, {
    value: context,
    get children() {
      return props.children;
    }
  });
};

const useCollapsible = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const [renderStrategyProps, collapsibleProps] = splitRenderStrategyProps(props);
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...collapsibleProps
  }));
  const [state, send] = solid.useMachine(collapsible__namespace.machine(context()), {
    context
  });
  const [wasVisible, setWasVisible] = solidJs.createSignal(false);
  solidJs.createEffect(() => {
    const isPresent = api().visible;
    if (isPresent) setWasVisible(true);
  });
  const api = solidJs.createMemo(() => collapsible__namespace.connect(state, send, solid.normalizeProps));
  return solidJs.createMemo(() => ({
    ...api(),
    unmounted: !api().visible && !wasVisible() && renderStrategyProps.lazyMount || renderStrategyProps.unmountOnExit && !api().visible && wasVisible()
  }));
};

const CollapsibleRoot = props => {
  const [useCollapsibleProps, localProps] = createSplitProps()(props, ['defaultOpen', 'disabled', 'id', 'ids', 'lazyMount', 'onExitComplete', 'onOpenChange', 'open', 'unmountOnExit']);
  const api = useCollapsible(useCollapsibleProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(CollapsibleProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const CollapsibleRootProvider = props => {
  const [{
    value: collapsible
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => collapsible().getRootProps(), localProps);
  return web.createComponent(CollapsibleProvider, {
    value: collapsible,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const CollapsibleTrigger = props => {
  const api = useCollapsibleContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var collapsible = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: CollapsibleContent,
  Context: CollapsibleContext,
  Root: CollapsibleRoot,
  RootProvider: CollapsibleRootProvider,
  Trigger: CollapsibleTrigger
});

const [AccordionItemProvider, useAccordionItemContext] = createContext({
  hookName: 'useAccordionItemContext',
  providerName: '<AccordionItemProvider />'
});

const [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext({
  hookName: 'useAccordionItemPropsContext',
  providerName: '<AccordionItemPropsProvider />'
});

const AccordionItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'disabled']);
  const accordion = useAccordionContext();
  const renderStrategyProps = useRenderStrategyContext();
  const mergedProps = solid.mergeProps(() => accordion().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => accordion().getItemState(itemProps));
  const itemContentProps = accordion().getItemContentProps(itemProps);
  return web.createComponent(AccordionItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(AccordionItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(CollapsibleRoot, web.mergeProps({
            get open() {
              return itemState().expanded;
            },
            get ids() {
              return {
                content: itemContentProps.id
              };
            }
          }, renderStrategyProps, mergedProps));
        }
      });
    }
  });
};

const splitVisibilityProps = createSplitProps();
const AccordionItemContent = props => {
  const accordion = useAccordionContext();
  const itemProps = useAccordionItemPropsContext();
  const itemContentProps = solidJs.createMemo(() => {
    const contentProps = accordion().getItemContentProps(itemProps);
    const [, ownProps] = splitVisibilityProps(contentProps, ['hidden', 'data-state']);
    return ownProps;
  });
  const mergedProps = solid.mergeProps(itemContentProps, props);
  return web.createComponent(CollapsibleContent, mergedProps);
};

const AccordionItemContext = props => props.children(useAccordionItemContext());

const AccordionItemIndicator = props => {
  const accordion = useAccordionContext();
  const itemProps = useAccordionItemPropsContext();
  const mergedProps = solid.mergeProps(() => accordion().getItemIndicatorProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const AccordionItemTrigger = props => {
  const accordion = useAccordionContext();
  const itemProps = useAccordionItemPropsContext();
  const collapsible = useCollapsibleContext();
  const mergedProps = solid.mergeProps(() => accordion().getItemTriggerProps(itemProps), props);
  const [ariaControls, buttonProps] = solidJs.splitProps(mergedProps, ['aria-controls']);
  return web.createComponent(ark.button, web.mergeProps(buttonProps, () => !collapsible().unmounted && ariaControls));
};

const useAccordion = props => {
  const id = solidJs.createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    value: props.defaultValue,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(accordion__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => accordion__namespace.connect(state, send, solid.normalizeProps));
};

const AccordionRoot = props => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props);
  const [useAccordionProps, localProps] = createSplitProps()(accordionProps, ['collapsible', 'defaultValue', 'disabled', 'id', 'ids', 'multiple', 'onFocusChange', 'onValueChange', 'orientation', 'value']);
  const api = useAccordion(useAccordionProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(AccordionProvider, {
    value: api,
    get children() {
      return web.createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const AccordionRootProvider = props => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props);
  const [{
    value: accordion
  }, localProps] = createSplitProps()(accordionProps, ['value']);
  const mergedProps = solid.mergeProps(() => accordion().getRootProps(), localProps);
  return web.createComponent(AccordionProvider, {
    value: accordion,
    get children() {
      return web.createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

var accordion = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: AccordionContext,
  Item: AccordionItem,
  ItemContent: AccordionItemContent,
  ItemContext: AccordionItemContext,
  ItemIndicator: AccordionItemIndicator,
  ItemTrigger: AccordionItemTrigger,
  Root: AccordionRoot,
  RootProvider: AccordionRootProvider
});

const [AvatarProvider, useAvatarContext] = createContext({
  hookName: 'useAvatarContext',
  providerName: '<AvatarProvider />'
});

const AvatarContext = props => props.children(useAvatarContext());

const AvatarFallback = props => {
  const context = useAvatarContext();
  const mergedProps = solid.mergeProps(() => context().getFallbackProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const AvatarImage = props => {
  const context = useAvatarContext();
  const mergedProps = solid.mergeProps(() => context().getImageProps(), props);
  return web.createComponent(ark.img, mergedProps);
};

const useAvatar = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(avatar__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => avatar__namespace.connect(state, send, solid.normalizeProps));
};

const AvatarRoot = props => {
  const [useAvatarProps, localProps] = createSplitProps()(props, ['id', 'ids', 'onStatusChange']);
  const context = useAvatar(useAvatarProps);
  const mergedProps = solid.mergeProps(() => context().getRootProps(), localProps);
  return web.createComponent(AvatarProvider, {
    value: context,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const AvatarRootProvider = props => {
  const [{
    value: avatar
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => avatar().getRootProps(), localProps);
  return web.createComponent(AvatarProvider, {
    value: avatar,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var avatar = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: AvatarContext,
  Fallback: AvatarFallback,
  Image: AvatarImage,
  Root: AvatarRoot,
  RootProvider: AvatarRootProvider
});

const [CarouselProvider, useCarouselContext] = createContext({
  hookName: 'useCarouselContext',
  providerName: '<CarouselProvider />'
});

const CarouselContext = props => props.children(useCarouselContext());

const carouselAnatomy = carousel$1.anatomy.extendWith('control');

const CarouselControl = props => {
  const mergedProps = solid.mergeProps(() => carouselAnatomy.build().control.attrs, props);
  return web.createComponent(ark.div, mergedProps);
};

const CarouselIndicator = props => {
  const [indicatorProps, localProps] = createSplitProps()(props, ['index', 'readOnly']);
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getIndicatorProps(indicatorProps), localProps);
  return web.createComponent(ark.button, mergedProps);
};

const CarouselIndicatorGroup = props => {
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getIndicatorGroupProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const CarouselItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getItemProps(itemProps), localProps);
  return web.createComponent(ark.div, mergedProps);
};

const CarouselItemGroup = props => {
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getItemGroupProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const CarouselNextTrigger = props => {
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getNextTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const CarouselPrevTrigger = props => {
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getPrevTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const useCarousel = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    index: props.defaultIndex,
    ...props
  }));
  const [state, send] = solid.useMachine(carousel__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => carousel__namespace.connect(state, send, solid.normalizeProps));
};

const CarouselRoot = props => {
  const [useCarouselProps, localProps] = createSplitProps()(props, ['align', 'defaultIndex', 'id', 'ids', 'index', 'loop', 'onIndexChange', 'orientation', 'slidesPerView', 'spacing']);
  const api = useCarousel(useCarouselProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(CarouselProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const CarouselRootProvider = props => {
  const [{
    value: carousel
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => carousel().getRootProps(), localProps);
  return web.createComponent(CarouselProvider, {
    value: carousel,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const CarouselViewport = props => {
  const api = useCarouselContext();
  const mergedProps = solid.mergeProps(() => api().getViewportProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

var carousel = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: CarouselContext,
  Control: CarouselControl,
  Indicator: CarouselIndicator,
  IndicatorGroup: CarouselIndicatorGroup,
  Item: CarouselItem,
  ItemGroup: CarouselItemGroup,
  NextTrigger: CarouselNextTrigger,
  PrevTrigger: CarouselPrevTrigger,
  Root: CarouselRoot,
  RootProvider: CarouselRootProvider,
  Viewport: CarouselViewport
});

const [CheckboxProvider, useCheckboxContext] = createContext({
  hookName: 'useCheckboxContext',
  providerName: '<CheckboxProvider />'
});

const CheckboxContext = props => props.children(useCheckboxContext());

const CheckboxControl = props => {
  const checkbox = useCheckboxContext();
  const mergedProps = solid.mergeProps(() => checkbox().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const checkboxAnatomy = checkbox$1.anatomy.extendWith('group');

function useControllableState(props) {
  const [uncontrolledValue, setUncontrolledValue] = solidJs.createSignal(runIfFn(props.defaultValue));
  const controlled = solidJs.createMemo(() => props.value?.() !== undefined);
  const currentValue = solidJs.createMemo(() => controlled() ? props.value?.() : uncontrolledValue());
  const setValue = next => {
    solidJs.untrack(() => {
      const nextValue = runIfFn(next, currentValue());
      if (controlled()) {
        return props.onChange?.(nextValue);
      }
      setUncontrolledValue(nextValue);
      return props.onChange?.(nextValue);
    });
  };
  return [currentValue, setValue];
}

function useCheckboxGroup(props = {}) {
  const interative = solidJs.createMemo(() => !(props.disabled || props.readOnly));
  const [value, setValue] = useControllableState({
    value: props.value,
    defaultValue: props.defaultValue || [],
    onChange: props.onValueChange
  });
  return solidJs.createMemo(() => {
    const isChecked = val => {
      return value().some(v => String(v) === String(val));
    };
    const toggleValue = val => {
      isChecked(val) ? removeValue(val) : addValue(val);
    };
    const addValue = val => {
      if (!interative()) return;
      if (isChecked(val)) return;
      setValue(value().concat(val));
    };
    const removeValue = val => {
      if (!interative()) return;
      setValue(value().filter(v => String(v) !== String(val)));
    };
    const getItemProps = itemProps => {
      return {
        checked: itemProps.value != null ? isChecked(itemProps.value) : undefined,
        onCheckedChange() {
          if (itemProps.value != null) {
            toggleValue(itemProps.value);
          }
        },
        name: props.name,
        disabled: props.disabled,
        readOnly: props.readOnly,
        invalid: props.invalid
      };
    };
    return {
      isChecked,
      value,
      name: props.name,
      disabled: props.disabled,
      readOnly: props.readOnly,
      invalid: props.invalid,
      setValue,
      addValue,
      toggleValue,
      getItemProps
    };
  });
}

const [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext({
  hookName: 'useCheckboxGroupContext',
  providerName: '<CheckboxGroupProvider />',
  strict: false
});

const CheckboxGroup = props => {
  const [checkboxGroupProps, localProps] = createSplitProps()(props, ['defaultValue', 'value', 'onValueChange', 'disabled', 'invalid', 'readOnly', 'name']);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return web.createComponent(CheckboxGroupContextProvider, {
    value: checkboxGroup,
    get children() {
      return web.createComponent(ark.div, web.mergeProps({
        role: "group"
      }, localProps, () => checkboxAnatomy.build().group.attrs));
    }
  });
};

const [FieldProvider, useFieldContext] = createContext({
  hookName: 'useFieldContext',
  providerName: '<FieldProvider />',
  strict: false
});

const FieldContext = props => props.children(useFieldContext());

const FieldErrorText = props => {
  const field = useFieldContext();
  const mergedProps = solid.mergeProps(() => field().getErrorTextProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return field?.().invalid;
    },
    get children() {
      return web.createComponent(ark.span, mergedProps);
    }
  });
};

const FieldHelperText = props => {
  const field = useFieldContext();
  const mergedProps = solid.mergeProps(() => field().getHelperTextProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const FieldInput = props => {
  const field = useFieldContext();
  const mergedProps = solid.mergeProps(() => field?.().getInputProps(), props);
  return web.createComponent(ark.input, mergedProps);
};

const FieldLabel = props => {
  const field = useFieldContext();
  const mergedProps = solid.mergeProps(() => field?.().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const FieldSelect = props => {
  const field = useFieldContext();
  const mergedProps = solid.mergeProps(() => field?.().getSelectProps(), props);
  return web.createComponent(ark.select, mergedProps);
};

const [FieldsetProvider, useFieldsetContext] = createContext({
  hookName: 'useFieldsetContext',
  providerName: '<FieldsetProvider />',
  strict: false
});

const FieldsetContext = props => props.children(useFieldsetContext());

const FieldsetErrorText = props => {
  const fieldset = useFieldsetContext();
  const mergedProps = solid.mergeProps(() => fieldset().getErrorTextProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return fieldset().invalid;
    },
    get children() {
      return web.createComponent(ark.span, mergedProps);
    }
  });
};

const FieldsetHelperText = props => {
  const fieldset = useFieldsetContext();
  const mergedProps = solid.mergeProps(() => fieldset().getHelperTextProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const fieldsetAnatomy = anatomy.createAnatomy('fieldset').parts('root', 'errorText', 'helperText', 'legend');
const parts$2 = fieldsetAnatomy.build();

const useFieldset = props => {
  const {
    disabled = false,
    invalid = false
  } = props;
  let rootRef;
  const id = props.id ?? solidJs.createUniqueId();
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  const [hasErrorText, setHasErrorText] = solidJs.createSignal(false);
  const [hasHelperText, setHasHelperText] = solidJs.createSignal(false);
  solidJs.createEffect(() => {
    return;
  });
  const labelIds = [];
  if (hasErrorText() && invalid) labelIds.push(errorTextId);
  if (hasHelperText()) labelIds.push(helperTextId);
  const getRootProps = () => ({
    ...parts$2.root.attrs,
    disabled,
    'data-disabled': dataAttr(disabled),
    'data-invalid': dataAttr(invalid),
    'aria-describedby': labelIds.join(' ') || undefined
  });
  const getLegendProps = () => ({
    ...parts$2.legend.attrs,
    'data-disabled': dataAttr(disabled),
    'data-invalid': dataAttr(invalid)
  });
  const getHelperTextProps = () => ({
    id: helperTextId,
    ...parts$2.helperText.attrs
  });
  const getErrorTextProps = () => ({
    id: errorTextId,
    ...parts$2.errorText.attrs,
    'aria-live': 'polite'
  });
  return solidJs.createMemo(() => ({
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  }));
};
const dataAttr = condition => condition ? '' : undefined;

const FieldsetRoot = props => {
  const [useFieldsetProps, localProps] = createSplitProps()(props, ['id', 'disabled', 'invalid']);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = solid.mergeProps(() => fieldset().getRootProps(), localProps);
  return web.createComponent(FieldsetProvider, {
    value: fieldset,
    get children() {
      return web.createComponent(ark.fieldset, mergedProps);
    }
  });
};
FieldsetRoot.displayName = 'FieldsetRoot';

const FieldsetRootProvider = props => {
  const [{
    value: fieldset
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => fieldset().getRootProps(), localProps);
  return web.createComponent(FieldsetProvider, {
    value: fieldset,
    get children() {
      return web.createComponent(ark.fieldset, mergedProps);
    }
  });
};

const FieldsetLegend = props => {
  const fieldset = useFieldsetContext();
  const mergedProps = solid.mergeProps(() => fieldset().getLegendProps(), props);
  return web.createComponent(ark.legend, mergedProps);
};

var fieldset = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: FieldsetContext,
  ErrorText: FieldsetErrorText,
  HelperText: FieldsetHelperText,
  Legend: FieldsetLegend,
  Root: FieldsetRoot,
  RootProvider: FieldsetRootProvider
});

const fieldAnatomy = anatomy.createAnatomy('field').parts('root', 'errorText', 'helperText', 'input', 'label', 'select', 'textarea');
const parts$1 = fieldAnatomy.build();

const useField = props => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset?.().disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props;
  const [hasErrorText, setHasErrorText] = solidJs.createSignal(false);
  const [hasHelperText, setHasHelperText] = solidJs.createSignal(false);
  const id = props.id ?? solidJs.createUniqueId();
  let rootRef;
  const rootId = ids?.control ?? `field::${id}`;
  const errorTextId = ids?.errorText ?? `field::${id}::error-text`;
  const helperTextId = ids?.helperText ?? `field::${id}::helper-text`;
  const labelId = ids?.label ?? `field::${id}::label`;
  solidJs.createEffect(() => {
    return;
  });
  const getRootProps = () => ({
    ...parts$1.root.attrs,
    id: rootId,
    role: 'group',
    'data-disabled': domQuery.dataAttr(disabled),
    'data-invalid': domQuery.dataAttr(invalid),
    'data-readonly': domQuery.dataAttr(readOnly)
  });
  const getLabelProps = () => ({
    ...parts$1.label.attrs,
    id: labelId,
    'data-disabled': domQuery.dataAttr(disabled),
    'data-invalid': domQuery.dataAttr(invalid),
    'data-readonly': domQuery.dataAttr(readOnly),
    htmlFor: id
  });
  const labelIds = [];
  if (hasErrorText() && invalid) labelIds.push(errorTextId);
  if (hasHelperText()) labelIds.push(helperTextId);
  const getControlProps = () => ({
    'aria-describedby': labelIds.join(' ') || undefined,
    'aria-invalid': domQuery.ariaAttr(invalid),
    'data-invalid': domQuery.dataAttr(invalid),
    'data-required': domQuery.dataAttr(required),
    'data-readonly': domQuery.dataAttr(readOnly),
    id,
    required,
    disabled,
    readOnly
  });
  const getInputProps = () => ({
    ...getControlProps(),
    ...parts$1.input.attrs
  });
  const getTextareaProps = () => ({
    ...getControlProps(),
    ...parts$1.textarea.attrs
  });
  const getSelectProps = () => ({
    ...getControlProps(),
    ...parts$1.select.attrs
  });
  const getHelperTextProps = () => ({
    id: helperTextId,
    ...parts$1.helperText.attrs
  });
  const getErrorTextProps = () => ({
    id: errorTextId,
    ...parts$1.errorText.attrs,
    'aria-live': 'polite'
  });
  return solidJs.createMemo(() => ({
    ariaDescribedby: labelIds.join(' '),
    ids: {
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps
  }));
};

const FieldRoot = props => {
  const [useFieldProps, localProps] = createSplitProps()(props, ['id', 'ids', 'disabled', 'invalid', 'readOnly', 'required']);
  const field = useField(useFieldProps);
  const mergedProps = solid.mergeProps(() => field().getRootProps(), localProps);
  return web.createComponent(FieldProvider, {
    value: field,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const FieldRootProvider = props => {
  const [{
    value: field
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => field().getRootProps(), localProps);
  return web.createComponent(FieldProvider, {
    value: field,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const FieldTextarea = props => {
  const field = useFieldContext();
  const mergedProps = solid.mergeProps(() => field?.().getTextareaProps(), props);
  return web.createComponent(ark.textarea, mergedProps);
};

var field = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: FieldContext,
  ErrorText: FieldErrorText,
  HelperText: FieldHelperText,
  Input: FieldInput,
  Label: FieldLabel,
  Root: FieldRoot,
  RootProvider: FieldRootProvider,
  Select: FieldSelect,
  Textarea: FieldTextarea
});

const CheckboxHiddenInput = props => {
  const checkbox = useCheckboxContext();
  const mergedProps = solid.mergeProps(() => checkbox().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const CheckboxIndicator = props => {
  const [indicatorProps, localProps] = createSplitProps()(props, ['indeterminate']);
  const checkbox = useCheckboxContext();
  const mergedProps = solid.mergeProps(() => checkbox().getIndicatorProps(), localProps);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get hidden() {
      return !(indicatorProps.indeterminate ? checkbox().indeterminate : checkbox().checked);
    }
  }));
};

const CheckboxLabel = props => {
  const checkbox = useCheckboxContext();
  const mergedProps = solid.mergeProps(() => checkbox().getLabelProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const useCheckbox = ownProps => {
  const checkboxGroup = useCheckboxGroupContext();
  const props = solidJs.createMemo(() => {
    return solid.mergeProps(ownProps, checkboxGroup?.().getItemProps({
      value: ownProps.value
    }) ?? {});
  }, [ownProps, checkboxGroup]);
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    invalid: field?.().invalid,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    checked: props().defaultChecked,
    ...props()
  }));
  const [state, send] = solid.useMachine(checkbox__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => checkbox__namespace.connect(state, send, solid.normalizeProps));
};

const CheckboxRoot = props => {
  const [useCheckboxProps, labelprops] = createSplitProps()(props, ['checked', 'defaultChecked', 'disabled', 'form', 'id', 'ids', 'invalid', 'name', 'onCheckedChange', 'readOnly', 'required', 'value']);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = solid.mergeProps(() => checkbox().getRootProps(), labelprops);
  return web.createComponent(CheckboxProvider, {
    value: checkbox,
    get children() {
      return web.createComponent(ark.label, mergedProps);
    }
  });
};

const CheckboxRootProvider = props => {
  const [{
    value: checkbox
  }, labelprops] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => checkbox().getRootProps(), labelprops);
  return web.createComponent(CheckboxProvider, {
    value: checkbox,
    get children() {
      return web.createComponent(ark.label, mergedProps);
    }
  });
};

var checkbox = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: CheckboxContext,
  Control: CheckboxControl,
  Group: CheckboxGroup,
  HiddenInput: CheckboxHiddenInput,
  Indicator: CheckboxIndicator,
  Label: CheckboxLabel,
  Root: CheckboxRoot,
  RootProvider: CheckboxRootProvider
});

const [ClipboardProvider, useClipboardContext] = createContext({
  hookName: 'useClipboardContext',
  providerName: '<ClipboardProvider />'
});

const ClipboardContext = props => props.children(useClipboardContext());

const ClipboardControl = props => {
  const api = useClipboardContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const ClipboardIndicator = props => {
  const [indicatorProps, localProps] = createSplitProps()(props, ['copied']);
  const api = useClipboardContext();
  const mergedProps = solid.mergeProps(api().getIndicatorProps({
    copied: api().copied
  }), localProps);
  const getChildren = solidJs.children(() => localProps.children);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get children() {
      return web.createComponent(solidJs.Show, {
        get when() {
          return api().copied;
        },
        get fallback() {
          return getChildren();
        },
        get children() {
          return indicatorProps.copied;
        }
      });
    }
  }));
};

const ClipboardInput = props => {
  const api = useClipboardContext();
  const mergedProps = solid.mergeProps(() => api().getInputProps(), props);
  return web.createComponent(ark.input, mergedProps);
};

const ClipboardLabel = props => {
  const api = useClipboardContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useClipboard = props => {
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(clipboard__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => clipboard__namespace.connect(state, send, solid.normalizeProps));
};

const ClipboardRoot = props => {
  const [useClipboardProps, localProps] = createSplitProps()(props, ['id', 'ids', 'onStatusChange', 'timeout', 'value']);
  const api = useClipboard(useClipboardProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(ClipboardProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ClipboardRootProvider = props => {
  const [{
    value: clipboard
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => clipboard().getRootProps(), localProps);
  return web.createComponent(ClipboardProvider, {
    value: clipboard,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ClipboardTrigger = props => {
  const api = useClipboardContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var clipboard = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: ClipboardContext,
  Control: ClipboardControl,
  Indicator: ClipboardIndicator,
  Input: ClipboardInput,
  Label: ClipboardLabel,
  Root: ClipboardRoot,
  RootProvider: ClipboardRootProvider,
  Trigger: ClipboardTrigger
});

const [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext({
  hookName: 'useColorPickerAreaContext',
  providerName: '<ColorPickerAreaProvider />'
});

const [ColorPickerProvider, useColorPickerContext] = createContext({
  hookName: 'useColorPickerContext',
  providerName: '<ColorPickerProvider />'
});

const ColorPickerArea = props => {
  const [channelProps, divprops] = createSplitProps()(props, ['xChannel', 'yChannel']);
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getAreaProps(channelProps), divprops);
  return web.createComponent(ColorPickerAreaPropsProvider, {
    value: channelProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerAreaBackground = props => {
  const api = useColorPickerContext();
  const areaProps = useColorPickerAreaPropsContext();
  const mergedProps = solid.mergeProps(() => api().getAreaBackgroundProps(areaProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerAreaThumb = props => {
  const api = useColorPickerContext();
  const areaProps = useColorPickerAreaPropsContext();
  const mergedProps = solid.mergeProps(() => api().getAreaThumbProps(areaProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerChannelInput = props => {
  const [channelProps, inputProps] = createSplitProps()(props, ['channel', 'orientation']);
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getChannelInputProps(channelProps), inputProps);
  return web.createComponent(ark.input, mergedProps);
};

const [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext({
  hookName: 'useColorPickerChannelSliderContext',
  providerName: '<ColorPickerChannelSliderProvider />'
});

const [ColorPickerFormatPropsProvider, useColorPickerFormatPropsContext] = createContext({
  hookName: 'useColorPickerFormatPropsContext',
  providerName: '<ColorPickerFormatPropsProvider />',
  strict: false
});

const ColorPickerChannelSlider = props => {
  const [channelProps, localProps] = createSplitProps()(props, ['channel', 'orientation']);
  const api = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = solid.mergeProps(channelProps, formatProps);
  const mergedProps = solid.mergeProps(() => api().getChannelSliderProps(channelSliderProps), localProps);
  return web.createComponent(ColorPickerChannelPropsProvider, {
    value: channelProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerChannelSliderLabel = props => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = solid.mergeProps(() => colorPicker().getChannelSliderLabelProps(channelProps), props);
  return web.createComponent(ark.label, mergedProps);
};

const ColorPickerChannelSliderThumb = props => {
  const api = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelProps = useColorPickerChannelPropsContext();
  const channelSliderProps = solid.mergeProps(channelProps, formatProps);
  const mergedProps = solid.mergeProps(() => api().getChannelSliderThumbProps(channelSliderProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerChannelSliderTrack = props => {
  const api = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelProps = useColorPickerChannelPropsContext();
  const channelSliderProps = solid.mergeProps(channelProps, formatProps);
  const mergedProps = solid.mergeProps(() => api().getChannelSliderTrackProps(channelSliderProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerChannelSliderValueText = props => {
  const colorPicker = useColorPickerContext();
  const localeContext = useLocaleContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = solid.mergeProps(() => colorPicker().getChannelSliderValueTextProps(channelProps), props);
  return web.createComponent(ark.span, web.mergeProps(mergedProps, {
    get children() {
      return props.children || colorPicker().getChannelValueText(channelProps.channel, localeContext().locale);
    }
  }));
};

const splitPresenceProps = props => createSplitProps()(props, ['immediate', 'lazyMount', 'onExitComplete', 'present', 'unmountOnExit']);

const usePresence = props => {
  const [renderStrategyProps, context] = splitRenderStrategyProps(props);
  const [wasEverPresent, setWasEverPresent] = solidJs.createSignal(false);
  const [state, send] = solid.useMachine(presence__namespace.machine(context), {
    context
  });
  const api = solidJs.createMemo(() => presence__namespace.connect(state, send, solid.normalizeProps));
  solidJs.createEffect(() => {
    const present = api().present;
    if (present) setWasEverPresent(true);
  });
  return solidJs.createMemo(() => ({
    unmounted: !api().present && !wasEverPresent() && renderStrategyProps.lazyMount || renderStrategyProps.unmountOnExit && !api().present && wasEverPresent(),
    present: api().present,
    presenceProps: {
      ref: api().setNode,
      hidden: !api().present,
      'data-state': context.present ? 'open' : 'closed'
    }
  }));
};

const Presence = props => {
  const [presenceProps, localProps] = splitPresenceProps(props);
  const api = usePresence(presenceProps);
  const mergedProps = solid.mergeProps(() => api().presenceProps, localProps);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !api().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, web.mergeProps(mergedProps, {
        "data-scope": "presence",
        "data-part": "root"
      }));
    }
  });
};

const [PresenceProvider, usePresenceContext] = createContext({
  hookName: 'usePresenceContext',
  providerName: '<PresenceProvider />'
});

const ColorPickerContent = props => {
  const api = useColorPickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerContext = props => props.children(useColorPickerContext());

const ColorPickerControl = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerEyeDropperTrigger = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getEyeDropperTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const ColorPickerFormatSelect = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getFormatSelectProps(), props);
  return web.createComponent(ark.select, web.mergeProps(mergedProps, {
    get children() {
      return web.createComponent(solidJs.Index, {
        each: ['rgba', 'hsla', 'hsba'],
        children: format => web.createComponent(ark.option, {
          get value() {
            return format();
          },
          get children() {
            return format();
          }
        })
      });
    }
  }));
};

const ColorPickerFormatTrigger = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getFormatTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const ColorPickerHiddenInput = props => {
  const colorPicker = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => colorPicker().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const ColorPickerLabel = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const ColorPickerPositioner = props => {
  const api = useColorPickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useColorPicker = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props,
    value: props.value ? colorPicker__namespace.parse(props.value) : props.defaultValue ? colorPicker__namespace.parse(props.defaultValue) : undefined
  }));
  const [state, send] = solid.useMachine(colorPicker__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => colorPicker__namespace.connect(state, send, solid.normalizeProps));
};

const ColorPickerRoot = props => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props);
  const [useColorPickerProps, localProps] = createSplitProps()(colorPickerProps, ['closeOnSelect', 'defaultOpen', 'defaultValue', 'disabled', 'format', 'id', 'ids', 'initialFocusEl', 'name', 'name', 'onFocusOutside', 'onFormatChange', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'onValueChange', 'onValueChangeEnd', 'open', 'positioning', 'readOnly', 'required', 'value']);
  const api = useColorPicker(useColorPickerProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(ColorPickerProvider, {
    value: api,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ColorPickerRootProvider = props => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props);
  const [{
    value: colorPicker
  }, localProps] = createSplitProps()(colorPickerProps, ['value']);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: colorPicker().open
  })));
  const mergedProps = solid.mergeProps(() => colorPicker().getRootProps(), localProps);
  return web.createComponent(ColorPickerProvider, {
    value: colorPicker,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext({
  hookName: 'useColorPickerSwatchContext',
  providerName: '<ColorPickerSwatchProvider />'
});

const ColorPickerSwatch = props => {
  const [swatchProps, localProps] = createSplitProps()(props, ['respectAlpha', 'value']);
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getSwatchProps(swatchProps), localProps);
  return web.createComponent(ColorPickerSwatchPropsProvider, {
    value: swatchProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerSwatchGroup = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getSwatchGroupProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerSwatchIndicator = props => {
  const api = useColorPickerContext();
  const swatchProps = useColorPickerSwatchPropsContext();
  const mergedProps = solid.mergeProps(() => api().getSwatchIndicatorProps(swatchProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerSwatchTrigger = props => {
  const [triggerProps, localProps] = createSplitProps()(props, ['value', 'disabled']);
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getSwatchTriggerProps(triggerProps), localProps);
  return web.createComponent(ark.button, mergedProps);
};

const ColorPickerTransparencyGrid = props => {
  const [gridProps, localProps] = createSplitProps()(props, ['size']);
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getTransparencyGridProps(gridProps), localProps);
  return web.createComponent(ark.div, mergedProps);
};

const ColorPickerTrigger = props => {
  const api = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const ColorPickerValueSwatch = props => {
  const [{
    respectAlpha
  }, localProps] = createSplitProps()(props, ['respectAlpha']);
  const colorPicker = useColorPickerContext();
  const swatchProps = solidJs.createMemo(() => ({
    respectAlpha,
    value: colorPicker().value
  }));
  const mergedProps = solid.mergeProps(() => colorPicker().getSwatchProps(swatchProps()), localProps);
  return web.createComponent(ColorPickerSwatchPropsProvider, {
    get value() {
      return swatchProps();
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerValueText = props => {
  const colorPicker = useColorPickerContext();
  const mergedProps = solid.mergeProps(() => colorPicker().getValueTextProps(), props);
  return web.createComponent(ark.span, web.mergeProps(mergedProps, {
    get children() {
      return colorPicker().valueAsString || props.children;
    }
  }));
};

const colorPickerAnatomy = colorPicker$1.anatomy.extendWith('view');

const ColorPickerView = props => {
  const api = useColorPickerContext();
  const [formatProps, localProps] = createSplitProps()(props, ['format']);
  const mergedProps = solid.mergeProps(() => colorPickerAnatomy.build().view.attrs, localProps);
  return web.createComponent(ColorPickerFormatPropsProvider, {
    value: formatProps,
    get children() {
      return web.createComponent(solidJs.Show, {
        get when() {
          return api().format === props.format;
        },
        get children() {
          return web.createComponent(ark.div, web.mergeProps({
            get ["data-format"]() {
              return props.format;
            }
          }, mergedProps));
        }
      });
    }
  });
};

var colorPicker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Area: ColorPickerArea,
  AreaBackground: ColorPickerAreaBackground,
  AreaThumb: ColorPickerAreaThumb,
  ChannelInput: ColorPickerChannelInput,
  ChannelSlider: ColorPickerChannelSlider,
  ChannelSliderLabel: ColorPickerChannelSliderLabel,
  ChannelSliderThumb: ColorPickerChannelSliderThumb,
  ChannelSliderTrack: ColorPickerChannelSliderTrack,
  ChannelSliderValueText: ColorPickerChannelSliderValueText,
  Content: ColorPickerContent,
  Context: ColorPickerContext,
  Control: ColorPickerControl,
  EyeDropperTrigger: ColorPickerEyeDropperTrigger,
  FormatSelect: ColorPickerFormatSelect,
  FormatTrigger: ColorPickerFormatTrigger,
  HiddenInput: ColorPickerHiddenInput,
  Label: ColorPickerLabel,
  Positioner: ColorPickerPositioner,
  Root: ColorPickerRoot,
  RootProvider: ColorPickerRootProvider,
  Swatch: ColorPickerSwatch,
  SwatchGroup: ColorPickerSwatchGroup,
  SwatchIndicator: ColorPickerSwatchIndicator,
  SwatchTrigger: ColorPickerSwatchTrigger,
  TransparencyGrid: ColorPickerTransparencyGrid,
  Trigger: ColorPickerTrigger,
  ValueSwatch: ColorPickerValueSwatch,
  ValueText: ColorPickerValueText,
  View: ColorPickerView
});

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
const [ComboboxProvider, useComboboxContext] = createContext({
  hookName: 'useComboboxContext',
  providerName: '<ComboboxProvider />'
});

const ComboboxClearTrigger = props => {
  const combobox = useComboboxContext();
  const mergedProps = solid.mergeProps(() => combobox().getClearTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const ComboboxContent = props => {
  const api = useComboboxContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ComboboxContext = props => props.children(useComboboxContext());

const ComboboxControl = props => {
  const combobox = useComboboxContext();
  const mergedProps = solid.mergeProps(() => combobox().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const ComboboxInput = props => {
  const combobox = useComboboxContext();
  const mergedProps = solid.mergeProps(() => combobox().getInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const [ComboboxItemProvider, useComboboxItemContext] = createContext({
  hookName: 'useComboboxItemContext',
  providerName: '<ComboboxItemProvider />'
});

const [ComboboxItemPropsProvider, useComboboxItemPropsContext] = createContext({
  hookName: 'useComboboxItemPropsContext',
  providerName: '<ComboboxItemPropsProvider />'
});

const ComboboxItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['item', 'persistFocus']);
  const api = useComboboxContext();
  const mergedProps = solid.mergeProps(() => api().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => api().getItemState(itemProps));
  return web.createComponent(ComboboxItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(ComboboxItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ComboboxItemContext = props => props.children(useComboboxItemContext());

const [ComboboxItemGroupPropsProvider, useComboboxItemGroupPropsContext] = createContext({
  hookName: 'useComboboxItemGroupPropsContext',
  providerName: '<ComboboxItemGroupPropsProvider />'
});

const ComboboxItemGroup = props => {
  const [_itemGroupProps, localProps] = createSplitProps()(props, ['id']);
  const combobox = useComboboxContext();
  const itemGroupProps = solid.mergeProps({
    id: solidJs.createUniqueId()
  }, _itemGroupProps);
  const mergedProps = solid.mergeProps(() => combobox().getItemGroupProps(itemGroupProps), localProps);
  return web.createComponent(ComboboxItemGroupPropsProvider, {
    value: itemGroupProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ComboboxItemGroupLabel = props => {
  const combobox = useComboboxContext();
  const itemGroupProps = useComboboxItemGroupPropsContext();
  const mergedProps = solid.mergeProps(() => combobox().getItemGroupLabelProps({
    htmlFor: itemGroupProps.id
  }), props);
  return web.createComponent(ark.div, mergedProps);
};

const ComboboxItemIndicator = props => {
  const combobox = useComboboxContext();
  const itemProps = useComboboxItemPropsContext();
  const mergedProps = solid.mergeProps(() => combobox().getItemIndicatorProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const ComboboxItemText = props => {
  const api = useComboboxContext();
  const itemProps = useComboboxItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemTextProps(itemProps), props);
  return web.createComponent(ark.span, mergedProps);
};

const ComboboxLabel = props => {
  const combobox = useComboboxContext();
  const mergedProps = solid.mergeProps(() => combobox().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const ComboboxList = props => {
  const combobox = useComboboxContext();
  const mergedProps = solid.mergeProps(() => combobox().getListProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const ComboboxPositioner = props => {
  const api = useComboboxContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useCombobox = props => {
  const [collectionOptions, comboboxProps] = createSplitProps()(props, ['isItemDisabled', 'itemToValue', 'itemToString', 'items']);
  const collection = () => combobox__namespace.collection({
    ...collectionOptions
  });
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    collection: collection(),
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    value: props.defaultValue,
    'open.controlled': props.open !== undefined,
    ...comboboxProps
  }));
  const [state, send] = solid.useMachine(combobox__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => combobox__namespace.connect(state, send, solid.normalizeProps));
};

const ComboboxRoot = props => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props);
  const [useComboboxProps, localProps] = createSplitProps()(comboboxProps, ['allowCustomValue', 'autoFocus', 'closeOnSelect', 'composite', 'defaultOpen', 'defaultValue', 'disabled', 'disableLayer', 'form', 'getSelectionValue', 'highlightedValue', 'id', 'ids', 'inputBehavior', 'inputValue', 'invalid', 'isItemDisabled', 'items', 'itemToString', 'itemToValue', 'loopFocus', 'multiple', 'name', 'onFocusOutside', 'onHighlightChange', 'onInputValueChange', 'onInteractOutside', 'onOpenChange', 'onOpenChange', 'onPointerDownOutside', 'onValueChange', 'open', 'openOnChange', 'openOnClick', 'openOnKeyPress', 'placeholder', 'positioning', 'readOnly', 'required', 'scrollToIndexFn', 'selectionBehavior', 'translations', 'value']);
  const api = useCombobox(useComboboxProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(ComboboxProvider, {
    value: api,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ComboboxRootProvider = props => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props);
  const [{
    value: combobox
  }, localProps] = createSplitProps()(comboboxProps, ['value']);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: combobox().open
  })));
  const mergedProps = solid.mergeProps(() => combobox().getRootProps(), localProps);
  return web.createComponent(ComboboxProvider, {
    value: combobox,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ComboboxTrigger = props => {
  const [triggerProps, localProps] = createSplitProps()(props, ['focusable']);
  const combobox = useComboboxContext();
  const mergedProps = solid.mergeProps(() => combobox().getTriggerProps(triggerProps), localProps);
  return web.createComponent(ark.button, mergedProps);
};

var combobox = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: ComboboxClearTrigger,
  Content: ComboboxContent,
  Context: ComboboxContext,
  Control: ComboboxControl,
  Input: ComboboxInput,
  Item: ComboboxItem,
  ItemContext: ComboboxItemContext,
  ItemGroup: ComboboxItemGroup,
  ItemGroupLabel: ComboboxItemGroupLabel,
  ItemIndicator: ComboboxItemIndicator,
  ItemText: ComboboxItemText,
  Label: ComboboxLabel,
  List: ComboboxList,
  Positioner: ComboboxPositioner,
  Root: ComboboxRoot,
  RootProvider: ComboboxRootProvider,
  Trigger: ComboboxTrigger
});

const [DatePickerProvider, useDatePickerContext] = createContext({
  hookName: 'useDatePickerContext',
  providerName: '<DatePickerProvider />'
});

const DatePickerClearTrigger = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getClearTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const DatePickerContent = props => {
  const api = useDatePickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const DatePickerContext = props => props.children(useDatePickerContext());

const DatePickerControl = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const DatePickerInput = props => {
  const [inputProps, localProps] = createSplitProps()(props, ['index']);
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getInputProps(inputProps), localProps);
  return web.createComponent(ark.input, mergedProps);
};

const DatePickerLabel = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

var _tmpl$$5 = /*#__PURE__*/web.template(`<option>`);
const DatePickerMonthSelect = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getMonthSelectProps(), props);
  return web.createComponent(ark.select, web.mergeProps(mergedProps, {
    get children() {
      return web.createComponent(solidJs.For, {
        get each() {
          return api().getMonths();
        },
        children: month => (() => {
          var _el$ = _tmpl$$5();
          web.insert(_el$, () => month.label);
          web.effect(() => _el$.value = month.value);
          return _el$;
        })()
      });
    }
  }));
};

const [DatePickerViewProvider, useDatePickerViewContext] = createContext({
  hookName: 'useDatePickerViewContext',
  providerName: '<DatePickerViewProvider />',
  strict: false,
  defaultValue: {
    view: 'day'
  }
});

const DatePickerNextTrigger = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = solid.mergeProps(() => api().getNextTriggerProps(viewProps), props);
  return web.createComponent(ark.button, mergedProps);
};

const DatePickerPositioner = props => {
  const api = useDatePickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const DatePickerPresetTrigger = props => {
  const [presetTriggerProps, localProps] = createSplitProps()(props, ['value']);
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getPresetTriggerProps(presetTriggerProps), localProps);
  return web.createComponent(ark.button, mergedProps);
};

const DatePickerPrevTrigger = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = solid.mergeProps(() => api().getPrevTriggerProps(viewProps), props);
  return web.createComponent(ark.button, mergedProps);
};

const DatePickerRangeText = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getRangeTextProps(), props);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get children() {
      return api().visibleRangeText.start;
    }
  }));
};

const useDatePicker = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    'open.controlled': props.open !== undefined,
    open: props.defaultOpen,
    ...props,
    focusedValue: props.focusedValue ? datePicker__namespace.parse(props.focusedValue) : undefined,
    value: props.value ? datePicker__namespace.parse(props.value) : props.defaultValue ? datePicker__namespace.parse(props.defaultValue) : undefined,
    max: props.max ? datePicker__namespace.parse(props.max) : undefined,
    min: props.min ? datePicker__namespace.parse(props.min) : undefined
  }));
  const [state, send] = solid.useMachine(datePicker__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => datePicker__namespace.connect(state, send, solid.normalizeProps));
};

const DatePickerRoot = props => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props);
  const [useDatePickerProps, localProps] = createSplitProps()(datePickerProps, ['closeOnSelect', 'defaultOpen', 'defaultValue', 'disabled', 'fixedWeeks', 'focusedValue', 'format', 'id', 'ids', 'isDateUnavailable', 'isDateUnavailable', 'locale', 'max', 'min', 'modal', 'name', 'numOfMonths', 'onFocusChange', 'onOpenChange', 'onValueChange', 'onViewChange', 'open', 'positioning', 'readOnly', 'selectionMode', 'startOfWeek', 'timeZone', 'translations', 'value', 'view']);
  const api = useDatePicker(useDatePickerProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(DatePickerProvider, {
    value: api,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const DatePickerRootProvider = props => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props);
  const [{
    value: datePicker
  }, localProps] = createSplitProps()(datePickerProps, ['value']);
  const presence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: datePicker().open
  })));
  const mergedProps = solid.mergeProps(() => datePicker().getRootProps(), localProps);
  return web.createComponent(DatePickerProvider, {
    value: datePicker,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const [DatePickerTableProvider, useDatePickerTableContext] = createContext({
  hookName: 'useDatePickerTableContext',
  providerName: '<DatePickerTableProvider />'
});

const DatePickerTable = props => {
  const [{
    columns
  }, localProps] = createSplitProps()(props, ['columns']);
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const tableProps = {
    columns,
    id: solidJs.createUniqueId(),
    ...viewProps
  };
  const mergedProps = solid.mergeProps(() => api().getTableProps(tableProps), localProps);
  return web.createComponent(DatePickerTableProvider, {
    value: tableProps,
    get children() {
      return web.createComponent(ark.table, mergedProps);
    }
  });
};

const DatePickerTableBody = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = solid.mergeProps(() => api().getTableBodyProps(tableProps), props);
  return web.createComponent(ark.tbody, mergedProps);
};

const [DatePickerTableCellProvider, useDatePickerTableCellContext] = createContext({
  hookName: 'useDatePickerTableCellContext',
  providerName: '<DatePickerTableCellProvider />'
});

const DatePickerTableCell = props => {
  const [cellProps, localProps] = createSplitProps()(props, ['disabled', 'value', 'visibleRange', 'columns']);
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const tableCellProps = solidJs.createMemo(() => {
    const viewMap = {
      day: api().getDayTableCellProps,
      month: api().getMonthTableCellProps,
      year: api().getYearTableCellProps
    };
    const viewFn = viewMap[viewProps.view];

    // @ts-expect-error
    return viewFn(cellProps);
  });
  const mergedProps = solid.mergeProps(tableCellProps, localProps);
  return web.createComponent(DatePickerTableCellProvider, {
    value: cellProps,
    get children() {
      return web.createComponent(ark.td, mergedProps);
    }
  });
};

const DatePickerTableCellTrigger = props => {
  const api = useDatePickerContext();
  const cellProps = useDatePickerTableCellContext();
  const viewProps = useDatePickerViewContext();
  const triggerProps = solidJs.createMemo(() => {
    const viewMap = {
      day: api().getDayTableCellTriggerProps,
      month: api().getMonthTableCellTriggerProps,
      year: api().getYearTableCellTriggerProps
    };
    const viewFn = viewMap[viewProps.view];

    // @ts-expect-error
    return viewFn(cellProps);
  });
  const mergedProps = solid.mergeProps(triggerProps, props);
  return web.createComponent(ark.div, mergedProps);
};

const DatePickerTableHead = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = solid.mergeProps(() => api().getTableHeadProps(tableProps), props);
  return web.createComponent(ark.thead, mergedProps);
};

const DatePickerTableHeader = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = solid.mergeProps(() => api().getTableHeaderProps(tableProps), props);
  return web.createComponent(ark.th, mergedProps);
};

const DatePickerTableRow = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = solid.mergeProps(() => api().getTableRowProps(tableProps), props);
  return web.createComponent(ark.tr, mergedProps);
};

const DatePickerTrigger = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const datePickerAnatomy = datePicker$1.anatomy.extendWith('view');

const DatePickerView = props => {
  const [viewProps, localProps] = createSplitProps()(props, ['view']);
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => datePickerAnatomy.build().view.attrs, localProps);
  return web.createComponent(DatePickerViewProvider, {
    value: viewProps,
    get children() {
      return web.createComponent(ark.div, web.mergeProps(mergedProps, {
        get hidden() {
          return api().view !== viewProps.view;
        }
      }));
    }
  });
};

const DatePickerViewControl = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = solid.mergeProps(() => api().getViewControlProps(viewProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const DatePickerViewTrigger = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = solid.mergeProps(() => api().getViewTriggerProps(viewProps), props);
  return web.createComponent(ark.button, mergedProps);
};

var _tmpl$$4 = /*#__PURE__*/web.template(`<option>`);
const DatePickerYearSelect = props => {
  const api = useDatePickerContext();
  const mergedProps = solid.mergeProps(() => api().getYearSelectProps(), props);
  return web.createComponent(ark.select, web.mergeProps(mergedProps, {
    get children() {
      return web.createComponent(solidJs.For, {
        get each() {
          return getYearsRange({
            from: 1_000,
            to: 4_000
          });
        },
        children: year => (() => {
          var _el$ = _tmpl$$4();
          _el$.value = year;
          web.insert(_el$, year);
          return _el$;
        })()
      });
    }
  }));
};
function getYearsRange(range) {
  const years = [];
  for (let year = range.from; year <= range.to; year += 1) {
    years.push(year);
  }
  return years;
}

var datePicker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: DatePickerClearTrigger,
  Content: DatePickerContent,
  Context: DatePickerContext,
  Control: DatePickerControl,
  Input: DatePickerInput,
  Label: DatePickerLabel,
  MonthSelect: DatePickerMonthSelect,
  NextTrigger: DatePickerNextTrigger,
  Positioner: DatePickerPositioner,
  PresetTrigger: DatePickerPresetTrigger,
  PrevTrigger: DatePickerPrevTrigger,
  RangeText: DatePickerRangeText,
  Root: DatePickerRoot,
  RootProvider: DatePickerRootProvider,
  Table: DatePickerTable,
  TableBody: DatePickerTableBody,
  TableCell: DatePickerTableCell,
  TableCellTrigger: DatePickerTableCellTrigger,
  TableHead: DatePickerTableHead,
  TableHeader: DatePickerTableHeader,
  TableRow: DatePickerTableRow,
  Trigger: DatePickerTrigger,
  View: DatePickerView,
  ViewControl: DatePickerViewControl,
  ViewTrigger: DatePickerViewTrigger,
  YearSelect: DatePickerYearSelect
});

const [DialogProvider, useDialogContext] = createContext({
  hookName: 'useDialogContext',
  providerName: '<DialogProvider />'
});

const DialogBackdrop = props => {
  const api = useDialogContext();
  const renderStrategyProps = useRenderStrategyContext();
  const presenceApi = usePresence(solid.mergeProps(renderStrategyProps, () => ({
    present: api().open
  })));
  const mergedProps = solid.mergeProps(() => api().getBackdropProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const DialogCloseTrigger = props => {
  const dialog = useDialogContext();
  const mergedProps = solid.mergeProps(() => dialog().getCloseTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const DialogContent = props => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const DialogContext = props => props.children(useDialogContext());

const DialogDescription = props => {
  const dialog = useDialogContext();
  const mergedProps = solid.mergeProps(() => dialog().getDescriptionProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const DialogPositioner = props => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useDialog = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = solid.useMachine(dialog__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => dialog__namespace.connect(state, send, solid.normalizeProps));
};

const DialogRoot = props => {
  const [presenceProps, dialogProps] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const [useDialogProps, localProps] = createSplitProps()(dialogProps, ['aria-label', 'closeOnEscape', 'closeOnInteractOutside', 'defaultOpen', 'finalFocusEl', 'id', 'ids', 'initialFocusEl', 'modal', 'onEscapeKeyDown', 'onFocusOutside', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'open', 'persistentElements', 'preventScroll', 'restoreFocus', 'role', 'trapFocus']);
  const api = useDialog(useDialogProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  return web.createComponent(DialogProvider, {
    value: api,
    get children() {
      return web.createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return web.createComponent(PresenceProvider, {
            value: apiPresence,
            get children() {
              return localProps.children;
            }
          });
        }
      });
    }
  });
};

const DialogRootProvider = props => {
  const [presenceProps, dialogProps] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: dialogProps.value().open
  })));
  return web.createComponent(DialogProvider, {
    get value() {
      return dialogProps.value;
    },
    get children() {
      return web.createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return web.createComponent(PresenceProvider, {
            value: apiPresence,
            get children() {
              return dialogProps.children;
            }
          });
        }
      });
    }
  });
};

const DialogTitle = props => {
  const dialog = useDialogContext();
  const mergedProps = solid.mergeProps(() => dialog().getTitleProps(), props);
  return web.createComponent(ark.h2, mergedProps);
};

const DialogTrigger = props => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), () => ({
    'aria-controls': presenceApi().unmounted && null
  }), props);
  return web.createComponent(ark.button, mergedProps);
};

var dialog = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Backdrop: DialogBackdrop,
  CloseTrigger: DialogCloseTrigger,
  Content: DialogContent,
  Context: DialogContext,
  Description: DialogDescription,
  Positioner: DialogPositioner,
  Root: DialogRoot,
  RootProvider: DialogRootProvider,
  Title: DialogTitle,
  Trigger: DialogTrigger
});

const [EditableProvider, useEditableContext] = createContext({
  hookName: 'useEditableContext',
  providerName: '<EditableProvider />'
});

const EditableArea = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getAreaProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const EditableCancelTrigger = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getCancelTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const EditableContext = props => props.children(useEditableContext());

const EditableControl = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const EditableEditTrigger = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getEditTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const EditableInput = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const EditableLabel = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const EditablePreview = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getPreviewProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const useEditable = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    invalid: field?.().invalid,
    readOnly: field?.().readOnly,
    required: field?.().required,
    getRootNode: environment().getRootNode,
    edit: props.defaultEdit,
    value: props.defaultValue,
    'edit.controlled': props.edit !== undefined,
    ...props
  }));
  const [state, send] = solid.useMachine(editable__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => editable__namespace.connect(state, send, solid.normalizeProps));
};

const EditableRoot = props => {
  const [useEditableProps, localProps] = createSplitProps()(props, ['activationMode', 'autoResize', 'defaultEdit', 'defaultValue', 'disabled', 'edit', 'finalFocusEl', 'form', 'id', 'ids', 'invalid', 'maxLength', 'name', 'onEditChange', 'onFocusOutside', 'onInteractOutside', 'onPointerDownOutside', 'onValueChange', 'onValueCommit', 'onValueRevert', 'placeholder', 'readOnly', 'required', 'selectOnFocus', 'submitMode', 'translations', 'value']);
  const api = useEditable(useEditableProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(EditableProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const EditableRootProvider = props => {
  const [{
    value: editable
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => editable().getRootProps(), localProps);
  return web.createComponent(EditableProvider, {
    value: editable,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const EditableSubmitTrigger = props => {
  const api = useEditableContext();
  const mergedProps = solid.mergeProps(() => api().getSubmitTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var editable = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Area: EditableArea,
  CancelTrigger: EditableCancelTrigger,
  Context: EditableContext,
  Control: EditableControl,
  EditTrigger: EditableEditTrigger,
  Input: EditableInput,
  Label: EditableLabel,
  Preview: EditablePreview,
  Root: EditableRoot,
  RootProvider: EditableRootProvider,
  SubmitTrigger: EditableSubmitTrigger
});

const [FileUploadProvider, useFileUploadContext] = createContext({
  hookName: 'useFileUploadContext',
  providerName: '<FileUploadProvider />'
});

const FileUploadContext = props => props.children(useFileUploadContext());

const FileUploadDropzone = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getDropzoneProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const FileUploadHiddenInput = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext({
  hookName: 'useFileUploadItemPropsContext',
  providerName: '<FileUploadItemPropsProvider />'
});

const FileUploadItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['file']);
  const fileUpload = useFileUploadContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getItemProps(itemProps), localProps);
  return web.createComponent(FileUploadItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(ark.li, mergedProps);
    }
  });
};

const FileUploadItemDeleteTrigger = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getItemDeleteTriggerProps(itemProps), props);
  return web.createComponent(ark.button, mergedProps);
};

const FileUploadItemGroup = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getItemGroupProps(), props);
  return web.createComponent(ark.ul, mergedProps);
};

const FileUploadItemName = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getItemNameProps(itemProps), props);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get children() {
      return props.children || itemProps.file.name;
    }
  }));
};

const FileUploadItemPreview = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getItemPreviewProps(itemProps), props);
  if (!itemProps.file.type.match(props.type ?? '.*')) return null;
  return web.createComponent(ark.div, mergedProps);
};

const FileUploadItemPreviewImage = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const [url, setUrl] = solidJs.createSignal('');
  fileUpload().createFileUrl(itemProps.file, url => setUrl(url));
  const mergedProps = solid.mergeProps(fileUpload().getItemPreviewImageProps({
    ...itemProps,
    url: url()
  }), props);
  return web.createComponent(ark.img, mergedProps);
};

const FileUploadItemSizeText = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getItemSizeTextProps(itemProps), props);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get children() {
      return props.children || fileUpload().getFileSize(itemProps.file);
    }
  }));
};

const FileUploadLabel = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useFileUpload = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    required: field?.().required,
    invalid: field?.().invalid,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(fileUpload__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => fileUpload__namespace.connect(state, send, solid.normalizeProps));
};

const FileUploadRoot = props => {
  const [fileUploadProps, localProps] = createSplitProps()(props, ['accept', 'allowDrop', 'capture', 'directory', 'disabled', 'id', 'ids', 'invalid', 'locale', 'maxFiles', 'maxFileSize', 'minFileSize', 'name', 'onFileAccept', 'onFileChange', 'onFileReject', 'required', 'translations', 'validate']);
  const fileUpload = useFileUpload(fileUploadProps);
  const mergedProps = solid.mergeProps(() => fileUpload().getRootProps(), localProps);
  return web.createComponent(FileUploadProvider, {
    value: fileUpload,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const FileUploadRootProvider = props => {
  const [{
    value: fileUpload
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => fileUpload().getRootProps(), localProps);
  return web.createComponent(FileUploadProvider, {
    value: fileUpload,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const FileUploadTrigger = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = solid.mergeProps(() => fileUpload().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var fileUpload = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: FileUploadContext,
  Dropzone: FileUploadDropzone,
  HiddenInput: FileUploadHiddenInput,
  Item: FileUploadItem,
  ItemDeleteTrigger: FileUploadItemDeleteTrigger,
  ItemGroup: FileUploadItemGroup,
  ItemName: FileUploadItemName,
  ItemPreview: FileUploadItemPreview,
  ItemPreviewImage: FileUploadItemPreviewImage,
  ItemSizeText: FileUploadItemSizeText,
  Label: FileUploadLabel,
  Root: FileUploadRoot,
  RootProvider: FileUploadRootProvider,
  Trigger: FileUploadTrigger
});

const FormatByte = props => {
  const [valueProps, intlProps] = solidJs.splitProps(props, ['value']);
  const ctx = useLocaleContext();
  const text = solidJs.createMemo(() => i18nUtils.formatBytes(valueProps.value, ctx().locale, intlProps));
  return text;
};

const FormatNumber = props => {
  const [valueProps, intlProps] = solidJs.splitProps(props, ['value']);
  const ctx = useLocaleContext();
  const text = solidJs.createMemo(() => i18nUtils.formatNumber(valueProps.value, ctx().locale, intlProps));
  return text;
};

var format = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Byte: FormatByte,
  Number: FormatNumber
});

const escapeRegexp = term => term.replace(/[|\\{}()[\]^$+*?.-]/g, char => `\\${char}`);
const buildRegex = (queryProp, flags) => {
  const query = queryProp.filter(Boolean).map(text => escapeRegexp(text));
  return new RegExp(`(${query.join('|')})`, flags);
};
const getRegexFlags = (ignoreCase = true, matchAll = true) => `${ignoreCase ? 'i' : ''}${matchAll ? 'g' : ''}`;
const normalizeSpan = (spans, len) => {
  const result = [];
  const append = (start, end, match) => {
    if (end - start > 0) result.push({
      start,
      end,
      match
    });
  };
  if (spans.length === 0) {
    append(0, len, false);
  } else {
    let lastIndex = 0;
    for (const chunk of spans) {
      append(lastIndex, chunk.start, false);
      append(chunk.start, chunk.end, true);
      lastIndex = chunk.end;
    }
    append(lastIndex, len, false);
  }
  return result;
};
const highlightWords = props => {
  const flags = getRegexFlags(props.ignoreCase, props.matchAll);
  const regex = buildRegex(Array.isArray(props.query) ? props.query : [props.query], flags);
  const spans = [...props.text.matchAll(regex)].map(match => ({
    start: match.index || 0,
    end: (match.index || 0) + match[0].length
  }));
  return normalizeSpan(spans, props.text.length).map(chunk => ({
    text: props.text.slice(chunk.start, chunk.end),
    match: !!chunk.match
  }));
};
const useHighlight = props => {
  return solidJs.createMemo(() => highlightWords(props));
};

var _tmpl$$3 = /*#__PURE__*/web.template(`<mark>`);
const Highlight = props => {
  if (typeof props.text !== 'string') {
    throw new Error('[ark-ui/highlight] text must be a string');
  }
  const [highlightProps, localProps] = createSplitProps()(props, ['query', 'text', 'ignoreCase', 'matchAll']);
  const chunks = useHighlight(highlightProps);
  return web.createComponent(solidJs.For, {
    get each() {
      return chunks();
    },
    children: chunk => web.createComponent(solidJs.Show, {
      get when() {
        return chunk.match;
      },
      get fallback() {
        return chunk.text;
      },
      get children() {
        var _el$ = _tmpl$$3();
        web.spread(_el$, localProps, false, true);
        web.insert(_el$, () => chunk.text);
        return _el$;
      }
    })
  });
};

const [HoverCardProvider, useHoverCardContext] = createContext({
  hookName: 'useHoverCardContext',
  providerName: '<HoverCardProvider />'
});

const HoverCardArrow = props => {
  const hoverCard = useHoverCardContext();
  const mergedProps = solid.mergeProps(() => hoverCard().getArrowProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const HoverCardArrowTip = props => {
  const hoverCard = useHoverCardContext();
  const mergedProps = solid.mergeProps(() => hoverCard().getArrowTipProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const HoverCardContent = props => {
  const api = useHoverCardContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const HoverCardContext = props => props.children(useHoverCardContext());

const HoverCardPositioner = props => {
  const api = useHoverCardContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useHoverCard = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = solid.useMachine(hoverCard__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => hoverCard__namespace.connect(state, send, solid.normalizeProps));
};

const HoverCardRoot = props => {
  const [presenceProps, hoverCardProps] = splitPresenceProps(props);
  const [useHoverCardProps, localProps] = createSplitProps()(hoverCardProps, ['closeDelay', 'defaultOpen', 'id', 'ids', 'onOpenChange', 'open', 'openDelay', 'positioning']);
  const api = useHoverCard(useHoverCardProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  return web.createComponent(HoverCardProvider, {
    value: api,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return localProps.children;
        }
      });
    }
  });
};

const HoverCardRootProvider = props => {
  const [presenceProps, hoverCardProps] = splitPresenceProps(props);
  const presence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: hoverCardProps.value().open
  })));
  return web.createComponent(HoverCardProvider, {
    get value() {
      return hoverCardProps.value;
    },
    get children() {
      return web.createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return hoverCardProps.children;
        }
      });
    }
  });
};

const HoverCardTrigger = props => {
  const hoverCard = useHoverCardContext();
  const mergedProps = solid.mergeProps(() => hoverCard().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var hoverCard = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: HoverCardArrow,
  ArrowTip: HoverCardArrowTip,
  Content: HoverCardContent,
  Context: HoverCardContext,
  Positioner: HoverCardPositioner,
  Root: HoverCardRoot,
  RootProvider: HoverCardRootProvider,
  Trigger: HoverCardTrigger
});

const [MenuProvider, useMenuContext] = createContext({
  hookName: 'useMenuContext',
  providerName: '<MenuProvider />',
  strict: false
});

const MenuArrow = props => {
  const context = useMenuContext();
  const mergedProps = solid.mergeProps(() => context().getArrowProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const MenuArrowTip = props => {
  const context = useMenuContext();
  const mergedProps = solid.mergeProps(() => context().getArrowTipProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const [MenuItemProvider, useMenuItemContext] = createContext({
  hookName: 'useMenuItemContext',
  providerName: '<MenuItemProvider />'
});

const [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext({
  hookName: 'useMenuOptionItemPropsContext',
  providerName: '<MenuOptionItemPropsProvider />'
});

const MenuCheckboxItem = props => {
  const [partialOptionItemProps, localProps] = createSplitProps()(props, ['checked', 'closeOnSelect', 'disabled', 'onCheckedChange', 'value', 'valueText']);
  const optionItemProps = solid.mergeProps(partialOptionItemProps, {
    type: 'checkbox'
  });
  const context = useMenuContext();
  const mergedProps = solid.mergeProps(() => context().getOptionItemProps(optionItemProps), localProps);
  const optionItemState = solidJs.createMemo(() => context().getItemState(optionItemProps));
  return web.createComponent(MenuOptionItemPropsProvider, {
    value: optionItemProps,
    get children() {
      return web.createComponent(MenuItemProvider, {
        value: optionItemState,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const MenuContent = props => {
  const context = useMenuContext();
  const presenceContext = usePresenceContext();
  const mergedProps = solid.mergeProps(() => context().getContentProps(), () => presenceContext().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceContext().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const MenuContext = props => props.children(useMenuContext());

const MenuContextTrigger = props => {
  const context = useMenuContext();
  const mergedProps = solid.mergeProps(() => context().getContextTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const MenuIndicator = props => {
  const context = useMenuContext();
  const mergedProps = solid.mergeProps(() => context().getIndicatorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const MenuItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['closeOnSelect', 'disabled', 'value', 'valueText']);
  const context = useMenuContext();
  const mergedProps = solid.mergeProps(() => context().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => context().getItemState(itemProps));
  return web.createComponent(MenuItemProvider, {
    value: itemState,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const MenuItemContext = props => props.children(useMenuItemContext());

const [MenuItemGroupProvider, useMenuItemGroupContext] = createContext({
  hookName: 'useMenuItemGroupContext',
  providerName: '<MenuItemGroupProvider />'
});

const MenuItemGroup = props => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props, ['id']);
  const itemGroupProps = solid.mergeProps({
    id: solidJs.createUniqueId()
  }, optionalItemGroupProps);
  const menu = useMenuContext();
  const mergedProps = solid.mergeProps(() => menu().getItemGroupProps(itemGroupProps), localProps);
  return web.createComponent(MenuItemGroupProvider, {
    value: itemGroupProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const MenuItemGroupLabel = props => {
  const context = useMenuContext();
  const itemGroupContext = useMenuItemGroupContext();
  const mergedProps = solid.mergeProps(context().getItemGroupLabelProps({
    htmlFor: itemGroupContext.id
  }), props);
  return web.createComponent(ark.div, mergedProps);
};

const MenuItemIndicator = props => {
  const context = useMenuContext();
  const optionItemProps = useMenuOptionItemPropsContext();
  const mergedProps = solid.mergeProps(() => context().getItemIndicatorProps(optionItemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const MenuItemText = props => {
  const context = useMenuContext();
  const optionItemProps = useMenuOptionItemPropsContext();
  const mergedProps = solid.mergeProps(() => context().getItemTextProps(optionItemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const MenuPositioner = props => {
  const context = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = solid.mergeProps(() => context().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presence().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const MenuRadioItem = props => {
  const [partialItemProps, localProps] = createSplitProps()(props, ['closeOnSelect', 'disabled', 'value', 'valueText']);
  const context = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps = solid.mergeProps(partialItemProps, () => ({
    type: 'radio',
    checked: itemGroup.value === partialItemProps.value,
    onCheckedChange: () => itemGroup.onValueChange?.({
      value: partialItemProps.value
    })
  }));
  const mergedProps = solid.mergeProps(() => context().getOptionItemProps(optionItemProps), localProps);
  const optionItemState = solidJs.createMemo(() => context().getOptionItemState(optionItemProps));
  return web.createComponent(MenuOptionItemPropsProvider, {
    value: optionItemProps,
    get children() {
      return web.createComponent(MenuItemProvider, {
        value: optionItemState,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const MenuRadioItemGroup = props => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props, ['id', 'onValueChange', 'value']);
  const context = useMenuContext();
  const itemGroupProps = solid.mergeProps({
    id: solidJs.createUniqueId()
  }, optionalItemGroupProps);
  const mergedProps = solid.mergeProps(() => context().getItemGroupProps(itemGroupProps), localProps);
  return web.createComponent(MenuItemGroupProvider, {
    value: itemGroupProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useMenu = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send, machine] = solid.useMachine(menu__namespace.machine(context()), {
    context
  });
  const api = solidJs.createMemo(() => menu__namespace.connect(state, send, solid.normalizeProps));
  return {
    api,
    machine
  };
};

const [MenuMachineProvider, useMenuMachineContext] = createContext({
  hookName: 'useMenuMachineContext',
  providerName: '<MenuMachineProvider />',
  strict: false
});

const [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext({
  hookName: 'useMenuMachineContext',
  providerName: '<MenuMachineProvider />',
  strict: false
});

const MenuRoot = props => {
  const [presenceProps, menuProps] = splitPresenceProps(props);
  const [useMenuProps, localProps] = createSplitProps()(menuProps, ['anchorPoint', 'aria-label', 'closeOnSelect', 'composite', 'defaultOpen', 'highlightedValue', 'id', 'ids', 'loopFocus', 'onEscapeKeyDown', 'onFocusOutside', 'onHighlightChange', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'onSelect', 'open', 'positioning', 'typeahead']);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const menu = useMenu(useMenuProps);
  const presenceApi = usePresence(solid.mergeProps(presenceProps, () => ({
    present: menu.api().open
  })));
  solidJs.createEffect(() => {
    if (!parentMachine) return;
    parentApi?.().setChild(menu.machine);
    menu.api().setParent(parentMachine);
  });
  const triggerItemContext = () => parentApi?.().getTriggerItemProps(menu.api());
  return web.createComponent(MenuTriggerItemProvider, {
    value: triggerItemContext,
    get children() {
      return web.createComponent(MenuMachineProvider, {
        get value() {
          return menu.machine;
        },
        get children() {
          return web.createComponent(MenuProvider, {
            get value() {
              return menu.api;
            },
            get children() {
              return web.createComponent(PresenceProvider, {
                value: presenceApi,
                get children() {
                  return localProps.children;
                }
              });
            }
          });
        }
      });
    }
  });
};

const MenuRootProvider = props => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, menuProps] = splitPresenceProps(props);
  const presenceApi = usePresence(solid.mergeProps(presenceProps, () => ({
    present: menuProps.value.api().open
  })));
  solidJs.createEffect(() => {
    if (!parentMachine) return;
    parentApi?.().setChild(menuProps.value.machine);
    menuProps.value.api().setParent(parentMachine);
  });
  const triggerItemContext = () => parentApi?.().getTriggerItemProps(menuProps.value.api());
  return web.createComponent(MenuTriggerItemProvider, {
    value: triggerItemContext,
    get children() {
      return web.createComponent(MenuMachineProvider, {
        get value() {
          return menuProps.value.machine;
        },
        get children() {
          return web.createComponent(MenuProvider, {
            get value() {
              return menuProps.value.api;
            },
            get children() {
              return web.createComponent(PresenceProvider, {
                value: presenceApi,
                get children() {
                  return menuProps.children;
                }
              });
            }
          });
        }
      });
    }
  });
};

const MenuSeparator = props => {
  const menu = useMenuContext();
  const mergedProps = solid.mergeProps(() => menu().getSeparatorProps(), props);
  return web.createComponent(ark.hr, mergedProps);
};

const MenuTrigger = props => {
  const api = useMenuContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), () => ({
    'aria-controls': presenceApi().unmounted && null
  }), props);
  return web.createComponent(ark.button, mergedProps);
};

const MenuTriggerItem = props => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = solid.mergeProps(() => getTriggerItemProps?.(), props);
  return web.createComponent(ark.div, mergedProps);
};

var menu = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: MenuArrow,
  ArrowTip: MenuArrowTip,
  CheckboxItem: MenuCheckboxItem,
  Content: MenuContent,
  Context: MenuContext,
  ContextTrigger: MenuContextTrigger,
  Indicator: MenuIndicator,
  Item: MenuItem,
  ItemContext: MenuItemContext,
  ItemGroup: MenuItemGroup,
  ItemGroupLabel: MenuItemGroupLabel,
  ItemIndicator: MenuItemIndicator,
  ItemText: MenuItemText,
  Positioner: MenuPositioner,
  RadioItem: MenuRadioItem,
  RadioItemGroup: MenuRadioItemGroup,
  Root: MenuRoot,
  RootProvider: MenuRootProvider,
  Separator: MenuSeparator,
  Trigger: MenuTrigger,
  TriggerItem: MenuTriggerItem
});

const [NumberInputProvider, useNumberInputContext] = createContext({
  hookName: 'useNumberInputContext',
  providerName: '<NumberInputProvider />'
});

const NumberInputContext = props => props.children(useNumberInputContext());

const NumberInputControl = props => {
  const api = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const NumberInputDecrementTrigger = props => {
  const api = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => api().getDecrementTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const NumberInputIncrementTrigger = props => {
  const api = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => api().getIncrementTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const NumberInputInput = props => {
  const api = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => api().getInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const NumberInputLabel = props => {
  const api = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useNumberInput = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(numberInput__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => numberInput__namespace.connect(state, send, solid.normalizeProps));
};

const NumberInputRoot = props => {
  const [useNumberInputProps, localProps] = createSplitProps()(props, ['allowMouseWheel', 'allowOverflow', 'clampValueOnBlur', 'defaultValue', 'disabled', 'focusInputOnChange', 'form', 'formatOptions', 'id', 'ids', 'inputMode', 'invalid', 'locale', 'max', 'min', 'name', 'onFocusChange', 'onValueChange', 'onValueInvalid', 'pattern', 'readOnly', 'required', 'spinOnPress', 'step', 'translations', 'value']);
  const api = useNumberInput(useNumberInputProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(NumberInputProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const NumberInputRootProvider = props => {
  const [{
    value: numberInput
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => numberInput().getRootProps(), localProps);
  return web.createComponent(NumberInputProvider, {
    value: numberInput,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const NumberInputScrubber = props => {
  const api = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => api().getScrubberProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const NumberInputValueText = props => {
  const numberInput = useNumberInputContext();
  const mergedProps = solid.mergeProps(() => numberInput().getValueTextProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

var numberInput = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: NumberInputContext,
  Control: NumberInputControl,
  DecrementTrigger: NumberInputDecrementTrigger,
  IncrementTrigger: NumberInputIncrementTrigger,
  Input: NumberInputInput,
  Label: NumberInputLabel,
  Root: NumberInputRoot,
  RootProvider: NumberInputRootProvider,
  Scrubber: NumberInputScrubber,
  ValueText: NumberInputValueText
});

const [PaginationProvider, usePaginationContext] = createContext({
  hookName: 'usePaginationContext',
  providerName: '<PaginationProvider />'
});

const PaginationContext = props => props.children(usePaginationContext());

const PaginationEllipsis = props => {
  const [ellipsisProps, localProps] = createSplitProps()(props, ['index']);
  const api = usePaginationContext();
  const mergedProps = solid.mergeProps(() => api().getEllipsisProps(ellipsisProps), localProps);
  return web.createComponent(ark.div, mergedProps);
};

const PaginationItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'type']);
  const api = usePaginationContext();
  const mergedProps = solid.mergeProps(() => api().getItemProps(itemProps), localProps);
  return web.createComponent(ark.button, mergedProps);
};

const PaginationNextTrigger = props => {
  const api = usePaginationContext();
  const mergedProps = solid.mergeProps(() => api().getNextTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const PaginationPrevTrigger = props => {
  const api = usePaginationContext();
  const mergedProps = solid.mergeProps(() => api().getPrevTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const usePagination = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    page: props.defaultPage,
    ...props
  }));
  const [state, send] = solid.useMachine(pagination__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => pagination__namespace.connect(state, send, solid.normalizeProps));
};

const PaginationRoot = props => {
  const [usePaginationProps, localProps] = createSplitProps()(props, ['count', 'defaultPage', 'id', 'ids', 'onPageChange', 'onPageSizeChange', 'page', 'pageSize', 'siblingCount', 'translations', 'type']);
  const api = usePagination(usePaginationProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(PaginationProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.nav, mergedProps);
    }
  });
};

const PaginationRootProvider = props => {
  const [{
    value: pagination
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => pagination().getRootProps(), localProps);
  return web.createComponent(PaginationProvider, {
    value: pagination,
    get children() {
      return web.createComponent(ark.nav, mergedProps);
    }
  });
};

var pagination = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: PaginationContext,
  Ellipsis: PaginationEllipsis,
  Item: PaginationItem,
  NextTrigger: PaginationNextTrigger,
  PrevTrigger: PaginationPrevTrigger,
  Root: PaginationRoot,
  RootProvider: PaginationRootProvider
});

const [PinInputProvider, usePinInputContext] = createContext({
  hookName: 'usePinInputContext',
  providerName: '<PinInputProvider />'
});

const PinInputContext = props => props.children(usePinInputContext());

const PinInputControl = props => {
  const api = usePinInputContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PinInputHiddenInput = props => {
  const pinInput = usePinInputContext();
  const mergedProps = solid.mergeProps(() => pinInput().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const PinInputInput = props => {
  const [inputProps, localProps] = createSplitProps()(props, ['index']);
  const api = usePinInputContext();
  const mergedProps = solid.mergeProps(() => api().getInputProps(inputProps), localProps);
  return web.createComponent(ark.input, mergedProps);
};

const PinInputLabel = props => {
  const api = usePinInputContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const usePinInput = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(pinInput__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => pinInput__namespace.connect(state, send, solid.normalizeProps));
};

const PinInputRoot = props => {
  const [usePinInputProps, localProps] = createSplitProps()(props, ['autoFocus', 'blurOnComplete', 'defaultValue', 'disabled', 'form', 'id', 'ids', 'invalid', 'mask', 'name', 'onValueChange', 'onValueComplete', 'onValueInvalid', 'otp', 'pattern', 'placeholder', 'readOnly', 'required', 'selectOnFocus', 'translations', 'type', 'value']);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = solid.mergeProps(() => pinInput().getRootProps(), localProps);
  return web.createComponent(PinInputProvider, {
    value: pinInput,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const PinInputRootProvider = props => {
  const [{
    value: pinInput
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => pinInput().getRootProps(), localProps);
  return web.createComponent(PinInputProvider, {
    value: pinInput,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var pinInput = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: PinInputContext,
  Control: PinInputControl,
  HiddenInput: PinInputHiddenInput,
  Input: PinInputInput,
  Label: PinInputLabel,
  Root: PinInputRoot,
  RootProvider: PinInputRootProvider
});

const [PopoverProvider, usePopoverContext] = createContext({
  hookName: 'usePopoverContext',
  providerName: '<PopoverProvider />'
});

const PopoverAnchor = props => {
  const api = usePopoverContext();
  const mergedProps = solid.mergeProps(() => api().getAnchorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PopoverArrow = props => {
  const popover = usePopoverContext();
  const mergedProps = solid.mergeProps(() => popover().getArrowProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PopoverArrowTip = props => {
  const popover = usePopoverContext();
  const mergedProps = solid.mergeProps(() => popover().getArrowTipProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PopoverCloseTrigger = props => {
  const api = usePopoverContext();
  const mergedProps = solid.mergeProps(() => api().getCloseTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const PopoverContent = props => {
  const api = usePopoverContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const PopoverContext = props => props.children(usePopoverContext());

const PopoverDescription = props => {
  const api = usePopoverContext();
  const mergedProps = solid.mergeProps(() => api().getDescriptionProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PopoverIndicator = props => {
  const popover = usePopoverContext();
  const mergedProps = solid.mergeProps(() => popover().getIndicatorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PopoverPositioner = props => {
  const api = usePopoverContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const usePopover = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = solid.useMachine(popover__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => popover__namespace.connect(state, send, solid.normalizeProps));
};

const PopoverRoot = props => {
  const [presenceProps, popoverProps] = splitPresenceProps(props);
  const [usePopoverProps, localProps] = createSplitProps()(popoverProps, ['autoFocus', 'closeOnEscape', 'closeOnInteractOutside', 'defaultOpen', 'id', 'ids', 'initialFocusEl', 'modal', 'onEscapeKeyDown', 'onFocusOutside', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'open', 'persistentElements', 'portalled', 'positioning']);
  const api = usePopover(usePopoverProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  return web.createComponent(PopoverProvider, {
    value: api,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return localProps.children;
        }
      });
    }
  });
};

const PopoverRootProvider = props => {
  const [presenceProps, popoverProps] = splitPresenceProps(props);
  const presence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: popoverProps.value().open
  })));
  return web.createComponent(PopoverProvider, {
    get value() {
      return popoverProps.value;
    },
    get children() {
      return web.createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return popoverProps.children;
        }
      });
    }
  });
};

const PopoverTitle = props => {
  const api = usePopoverContext();
  const mergedProps = solid.mergeProps(() => api().getTitleProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const PopoverTrigger = props => {
  const api = usePopoverContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), () => ({
    'aria-controls': presenceApi().unmounted && null
  }), props);
  return web.createComponent(ark.button, mergedProps);
};

var popover = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Anchor: PopoverAnchor,
  Arrow: PopoverArrow,
  ArrowTip: PopoverArrowTip,
  CloseTrigger: PopoverCloseTrigger,
  Content: PopoverContent,
  Context: PopoverContext,
  Description: PopoverDescription,
  Indicator: PopoverIndicator,
  Positioner: PopoverPositioner,
  Root: PopoverRoot,
  RootProvider: PopoverRootProvider,
  Title: PopoverTitle,
  Trigger: PopoverTrigger
});

const [ProgressProvider, useProgressContext] = createContext({
  hookName: 'useProgressContext',
  providerName: '<ProgressProvider />'
});

const ProgressCircle = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getCircleProps(), props);
  return web.createComponent(ark.svg, mergedProps);
};

const ProgressCircleRange = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getCircleRangeProps(), props);
  return web.createComponent(ark.circle, mergedProps);
};

const ProgressCircleTrack = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getCircleTrackProps(), props);
  return web.createComponent(ark.circle, mergedProps);
};

const ProgressContext = props => props.children(useProgressContext());

const ProgressLabel = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const ProgressRange = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getRangeProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const useProgress = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(progress__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => progress__namespace.connect(state, send, solid.normalizeProps));
};

const ProgressRoot = props => {
  const [progressProps, localProps] = createSplitProps()(props, ['id', 'ids', 'max', 'min', 'orientation', 'translations', 'value']);
  const api = useProgress(progressProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(ProgressProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ProgressRootProvider = props => {
  const [{
    value: progress
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => progress().getRootProps(), localProps);
  return web.createComponent(ProgressProvider, {
    value: progress,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ProgressTrack = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getTrackProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const ProgressValueText = props => {
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getValueTextProps(), props);
  return web.createComponent(ark.span, web.mergeProps(mergedProps, {
    get children() {
      return props.children || api().percentAsString;
    }
  }));
};

const ProgressView = props => {
  const [state, localProps] = createSplitProps()(props, ['state']);
  const api = useProgressContext();
  const mergedProps = solid.mergeProps(() => api().getViewProps(state), localProps);
  return web.createComponent(ark.span, mergedProps);
};

var progress = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Circle: ProgressCircle,
  CircleRange: ProgressCircleRange,
  CircleTrack: ProgressCircleTrack,
  Context: ProgressContext,
  Label: ProgressLabel,
  Range: ProgressRange,
  Root: ProgressRoot,
  RootProvider: ProgressRootProvider,
  Track: ProgressTrack,
  ValueText: ProgressValueText,
  View: ProgressView
});

const [QrCodeProvider, useQrCodeContext] = createContext({
  hookName: 'useQrCodeContext',
  providerName: '<QrCodeProvider />'
});

const QrCodeContext = props => props.children(useQrCodeContext());

const QrCodeFrame = props => {
  const qrCode = useQrCodeContext();
  const mergedProps = solid.mergeProps(() => qrCode().getFrameProps(), props);
  return web.createComponent(ark.svg, mergedProps);
};

const QrCodeOverlay = props => {
  const qrCode = useQrCodeContext();
  const mergedProps = solid.mergeProps(() => qrCode().getOverlayProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const QrCodePattern = props => {
  const qrCode = useQrCodeContext();
  const mergedProps = solid.mergeProps(() => qrCode().getPatternProps(), props);
  return web.createComponent(ark.path, mergedProps);
};

const useQrCode = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(qrCode__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => qrCode__namespace.connect(state, send, solid.normalizeProps));
};

const QrCodeRoot = props => {
  const [useQrCodeProps, restProps] = createSplitProps()(props, ['encoding', 'id', 'ids', 'value']);
  const api = useQrCode(useQrCodeProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), restProps);
  return web.createComponent(QrCodeProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const QrCodeRootProvider = props => {
  const [{
    value: qrCode
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => qrCode().getRootProps(), localProps);
  return web.createComponent(QrCodeProvider, {
    value: qrCode,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var qrCode = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Frame: QrCodeFrame,
  Overlay: QrCodeOverlay,
  Pattern: QrCodePattern,
  QrCodeContext: QrCodeContext,
  Root: QrCodeRoot,
  RootProvider: QrCodeRootProvider
});

const [RadioGroupProvider, useRadioGroupContext] = createContext({
  hookName: 'useRadioGroupContext',
  providerName: '<RadioGroupProvider />'
});

const RadioGroupContext = props => props.children(useRadioGroupContext());

const RadioGroupIndicator = props => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = solid.mergeProps(() => radioGroup().getIndicatorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const [RadioGroupItemProvider, useRadioGroupItemContext] = createContext({
  hookName: 'useRadioGroupItemContext',
  providerName: '<RadioGroupItemProvider />'
});

const [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext({
  hookName: 'useRadioGroupItemPropsContext',
  providerName: '<RadioGroupItemPropsProvider />'
});

const RadioGroupItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'disabled', 'invalid']);
  const radioGroup = useRadioGroupContext();
  const mergedProps = solid.mergeProps(() => radioGroup().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => radioGroup().getItemState(itemProps));
  return web.createComponent(RadioGroupItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(RadioGroupItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.label, mergedProps);
        }
      });
    }
  });
};

const RadioGroupItemContext = props => props.children(useRadioGroupItemContext());

const RadioGroupItemControl = props => {
  const radioGroup = useRadioGroupContext();
  const itemProps = useRadioGroupItemPropsContext();
  const mergedProps = solid.mergeProps(() => radioGroup().getItemControlProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const RadioGroupItemHiddenInput = props => {
  const radioGroup = useRadioGroupContext();
  const itemProps = useRadioGroupItemPropsContext();
  const mergedProps = solid.mergeProps(() => radioGroup().getItemHiddenInputProps(itemProps), props);
  return web.createComponent(ark.input, mergedProps);
};

const RadioGroupItemText = props => {
  const radioGroup = useRadioGroupContext();
  const itemProps = useRadioGroupItemPropsContext();
  const mergedProps = solid.mergeProps(() => radioGroup().getItemTextProps(itemProps), props);
  return web.createComponent(ark.span, mergedProps);
};

const RadioGroupLabel = props => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = solid.mergeProps(() => radioGroup().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useRadioGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(radio__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => radio__namespace.connect(state, send, solid.normalizeProps));
};

const RadioGroupRoot = props => {
  const [useRadioGroupProps, localProps] = createSplitProps()(props, ['defaultValue', 'disabled', 'form', 'id', 'ids', 'name', 'onValueChange', 'orientation', 'readOnly', 'value']);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = solid.mergeProps(() => radioGroup().getRootProps(), localProps);
  return web.createComponent(RadioGroupProvider, {
    value: radioGroup,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const RadioGroupRootProvider = props => {
  const [{
    value: radioGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => radioGroup().getRootProps(), localProps);
  return web.createComponent(RadioGroupProvider, {
    value: radioGroup,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var radioGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: RadioGroupContext,
  Indicator: RadioGroupIndicator,
  Item: RadioGroupItem,
  ItemContext: RadioGroupItemContext,
  ItemControl: RadioGroupItemControl,
  ItemHiddenInput: RadioGroupItemHiddenInput,
  ItemText: RadioGroupItemText,
  Label: RadioGroupLabel,
  Root: RadioGroupRoot,
  RootProvider: RadioGroupRootProvider
});

const [RatingGroupProvider, useRatingGroupContext] = createContext({
  hookName: 'useRatingGroupContext',
  providerName: '<RatingGroupProvider />'
});

const RatingGroupContext = props => props.children(useRatingGroupContext());

const RatingGroupControl = props => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = solid.mergeProps(() => ratingGroup().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const RatingGroupHiddenInput = props => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = solid.mergeProps(() => ratingGroup().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const [RatingGroupItemProvider, useRatingGroupItemContext] = createContext({
  hookName: 'useRatingGroupItemContext',
  providerName: '<RatingGroupItemProvider />'
});

const RatingGroupItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const api = useRatingGroupContext();
  const mergedProps = solid.mergeProps(() => api().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => api().getItemState(itemProps));
  return web.createComponent(RatingGroupItemProvider, {
    value: itemState,
    get children() {
      return web.createComponent(ark.span, mergedProps);
    }
  });
};

const RatingGroupItemContext = props => props.children(useRatingGroupItemContext());

const RatingGroupLabel = props => {
  const api = useRatingGroupContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useRatingGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(rating__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => rating__namespace.connect(state, send, solid.normalizeProps));
};

const RatingGroupRoot = props => {
  const [useRatingProps, localProps] = createSplitProps()(props, ['allowHalf', 'autoFocus', 'count', 'defaultValue', 'disabled', 'form', 'id', 'ids', 'name', 'onHoverChange', 'onValueChange', 'readOnly', 'required', 'translations', 'value']);
  const api = useRatingGroup(useRatingProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(RatingGroupProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const RatingGroupRootProvider = props => {
  const [{
    value: ratingGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => ratingGroup().getRootProps(), localProps);
  return web.createComponent(RatingGroupProvider, {
    value: ratingGroup,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var ratingGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: RatingGroupContext,
  Control: RatingGroupControl,
  HiddenInput: RatingGroupHiddenInput,
  Item: RatingGroupItem,
  ItemContext: RatingGroupItemContext,
  Label: RatingGroupLabel,
  Root: RatingGroupRoot,
  RootProvider: RatingGroupRootProvider
});

const [SegmentGroupProvider, useSegmentGroupContext] = createContext({
  hookName: 'useSegmentGroupContext',
  providerName: '<SegmentGroupProvider />'
});

const SegmentGroupContext = props => props.children(useSegmentGroupContext());

const segmentGroupAnatomy = radio.anatomy.rename('segment-group');
const parts = segmentGroupAnatomy.build();

const SegmentGroupIndicator = props => {
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = solid.mergeProps(() => segmentGroup().getIndicatorProps(), parts.indicator.attrs, props);
  return web.createComponent(ark.div, mergedProps);
};

const [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext({
  hookName: 'useSegmentGroupItemContext',
  providerName: '<SegmentGroupItemProvider />'
});

const [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext({
  hookName: 'useSegmentGroupItemPropsContext',
  providerName: '<SegmentGroupItemPropsProvider />'
});

const SegmentGroupItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'disabled', 'invalid']);
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = solid.mergeProps(() => segmentGroup().getItemProps(itemProps), parts.item.attrs, localProps);
  const itemState = solidJs.createMemo(() => segmentGroup().getItemState(itemProps));
  return web.createComponent(SegmentGroupItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(SegmentGroupItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.label, mergedProps);
        }
      });
    }
  });
};

const SegmentGroupItemContext = props => props.children(useSegmentGroupItemContext());

const SegmentGroupItemControl = props => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps = useSegmentGroupItemPropsContext();
  const mergedProps = solid.mergeProps(() => segmentGroup().getItemControlProps(itemProps), parts.itemControl.attrs, props);
  return web.createComponent(ark.div, mergedProps);
};

const SegmentGroupItemHiddenInput = props => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps = useSegmentGroupItemPropsContext();
  const mergedProps = solid.mergeProps(() => segmentGroup().getItemHiddenInputProps(itemProps), props);
  return web.createComponent(ark.input, mergedProps);
};

const SegmentGroupItemText = props => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps = useSegmentGroupItemPropsContext();
  const mergedProps = solid.mergeProps(() => segmentGroup().getItemTextProps(itemProps), parts.itemText.attrs, props);
  return web.createComponent(ark.span, mergedProps);
};

const SegmentGroupLabel = props => {
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = solid.mergeProps(() => segmentGroup().getLabelProps(), parts.label.attrs, props);
  return web.createComponent(ark.label, mergedProps);
};

const useSegmentGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(radio__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => radio__namespace.connect(state, send, solid.normalizeProps));
};

const SegmentGroupRoot = props => {
  const [useSegmentGroupProps, localProps] = createSplitProps()(props, ['defaultValue', 'disabled', 'form', 'id', 'ids', 'name', 'onValueChange', 'orientation', 'readOnly', 'value']);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = solid.mergeProps(() => segmentGroup().getRootProps(), parts.root.attrs, localProps);
  return web.createComponent(SegmentGroupProvider, {
    value: segmentGroup,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SegmentGroupRootProvider = props => {
  const [{
    value: segmentGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => segmentGroup().getRootProps(), parts.root.attrs, localProps);
  return web.createComponent(SegmentGroupProvider, {
    value: segmentGroup,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var segmentGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SegmentGroupContext,
  Indicator: SegmentGroupIndicator,
  Item: SegmentGroupItem,
  ItemContext: SegmentGroupItemContext,
  ItemControl: SegmentGroupItemControl,
  ItemHiddenInput: SegmentGroupItemHiddenInput,
  ItemText: SegmentGroupItemText,
  Label: SegmentGroupLabel,
  Root: SegmentGroupRoot,
  RootProvider: SegmentGroupRootProvider
});

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
const [SelectProvider, useSelectContext] = createContext({
  hookName: 'useSelectContext',
  providerName: '<SelectProvider />'
});

const SelectClearTrigger = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getClearTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const SelectContent = props => {
  const select = useSelectContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => select().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SelectContext = props => props.children(useSelectContext());

const SelectControl = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

var _tmpl$$2 = /*#__PURE__*/web.template(`<option value="">`),
  _tmpl$2$1 = /*#__PURE__*/web.template(`<option>`);
const SelectHiddenSelect = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getHiddenSelectProps(), props);
  const isValueEmpty = solidJs.createMemo(() => select().value.length === 0);
  const field = useFieldContext();
  return web.createComponent(ark.select, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps, {
    get children() {
      return [web.createComponent(solidJs.Show, {
        get when() {
          return isValueEmpty();
        },
        get children() {
          return _tmpl$$2();
        }
      }), web.createComponent(solidJs.Index, {
        get each() {
          return select().collection.items;
        },
        children: item => (() => {
          var _el$2 = _tmpl$2$1();
          web.effect(() => _el$2.disabled = select().collection.getItemDisabled(item()));
          web.effect(() => _el$2.value = select().collection.getItemValue(item()) ?? '');
          return _el$2;
        })()
      })];
    }
  }));
};

const SelectIndicator = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getIndicatorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const [SelectItemProvider, useSelectItemContext] = createContext({
  hookName: 'useSelectItemContext',
  providerName: '<SelectItemProvider />'
});

const [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  hookName: 'useSelectItemPropsContext',
  providerName: '<SelectItemPropsProvider />'
});

const SelectItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['item', 'persistFocus']);
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => select().getItemState(itemProps));
  return web.createComponent(SelectItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(SelectItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const SelectItemContext = props => props.children(useSelectItemContext());

const [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  hookName: 'useSelectItemGroupPropsContext',
  providerName: '<SelectItemGroupPropsProvider />'
});

const SelectItemGroup = props => {
  const [_itemGroupProps, localProps] = createSplitProps()(props, ['id']);
  const select = useSelectContext();
  const itemGroupProps = solid.mergeProps({
    id: solidJs.createUniqueId()
  }, _itemGroupProps);
  const mergedProps = solid.mergeProps(() => select().getItemGroupProps(itemGroupProps), localProps);
  return web.createComponent(SelectItemGroupPropsProvider, {
    value: itemGroupProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SelectItemGroupLabel = props => {
  const select = useSelectContext();
  const itemGroupProps = useSelectItemGroupPropsContext();
  const mergedProps = solid.mergeProps(() => select().getItemGroupLabelProps({
    htmlFor: itemGroupProps.id
  }), props);
  return web.createComponent(ark.div, mergedProps);
};

const SelectItemIndicator = props => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = solid.mergeProps(() => select().getItemIndicatorProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const SelectItemText = props => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = solid.mergeProps(() => select().getItemTextProps(itemProps), props);
  return web.createComponent(ark.span, mergedProps);
};

const SelectLabel = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const SelectList = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getListProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const SelectPositioner = props => {
  const select = useSelectContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => select().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useSelect = props => {
  const [collectionOptions, selectProps] = createSplitProps()(props, ['isItemDisabled', 'itemToValue', 'itemToString', 'items']);
  const collection = solidJs.createMemo(() => select__namespace.collection({
    ...collectionOptions
  }));
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const initialContext = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenSelect: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    invalid: field?.().invalid,
    required: field?.().required,
    collection: collection(),
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    value: props.defaultValue,
    'open.controlled': props.open !== undefined,
    ...selectProps
  }));
  const context = solidJs.createMemo(() => {
    const [, restProps] = solidJs.splitProps(initialContext(), ['collection']);
    return restProps;
  });
  const [state, send] = solid.useMachine(select__namespace.machine(initialContext()), {
    context
  });
  const api = solidJs.createMemo(() => select__namespace.connect(state, send, solid.normalizeProps));
  solidJs.createEffect(() => {
    api().setCollection(collection());
  });
  return api;
};

const SelectRoot = props => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [useSelectProps, localProps] = createSplitProps()(selectProps, ['closeOnSelect', 'composite', 'defaultOpen', 'defaultValue', 'disabled', 'form', 'highlightedValue', 'id', 'ids', 'invalid', 'isItemDisabled', 'items', 'itemToString', 'itemToValue', 'loopFocus', 'multiple', 'name', 'onFocusOutside', 'onHighlightChange', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'onValueChange', 'open', 'positioning', 'readOnly', 'required', 'scrollToIndexFn', 'value']);
  const select = useSelect(useSelectProps);
  const presenceApi = usePresence(solid.mergeProps(() => ({
    present: select().open
  }), presenceProps));
  const mergedProps = solid.mergeProps(() => select().getRootProps(), localProps);
  return web.createComponent(SelectProvider, {
    value: select,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: presenceApi,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const SelectRootProvider = props => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [{
    value: select
  }, localProps] = createSplitProps()(selectProps, ['value']);
  const presence = usePresence(solid.mergeProps(() => ({
    present: select().open
  }), presenceProps));
  const mergedProps = solid.mergeProps(() => select().getRootProps(), localProps);
  return web.createComponent(SelectProvider, {
    value: select,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const SelectTrigger = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const SelectValueText = props => {
  const select = useSelectContext();
  const mergedProps = solid.mergeProps(() => select().getValueTextProps(), props);
  return web.createComponent(ark.span, web.mergeProps(mergedProps, {
    get children() {
      return select().valueAsString || props.placeholder;
    }
  }));
};

var select = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: SelectClearTrigger,
  Content: SelectContent,
  Context: SelectContext,
  Control: SelectControl,
  HiddenSelect: SelectHiddenSelect,
  Indicator: SelectIndicator,
  Item: SelectItem,
  ItemContext: SelectItemContext,
  ItemGroup: SelectItemGroup,
  ItemGroupLabel: SelectItemGroupLabel,
  ItemIndicator: SelectItemIndicator,
  ItemText: SelectItemText,
  Label: SelectLabel,
  List: SelectList,
  Positioner: SelectPositioner,
  Root: SelectRoot,
  RootProvider: SelectRootProvider,
  Trigger: SelectTrigger,
  ValueText: SelectValueText
});

const [SignaturePadProvider, useSignaturePadContext] = createContext({
  hookName: 'useSignaturePadContext',
  providerName: '<SignaturePadProvider />'
});

const SignaturePadClearTrigger = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = solid.mergeProps(() => signaturePad().getClearTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const SignaturePadContext = props => props.children(useSignaturePadContext());

const SignaturePadControl = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = solid.mergeProps(() => signaturePad().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const SignaturePadGuide = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = solid.mergeProps(() => signaturePad().getGuideProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const SignaturePadLabel = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = solid.mergeProps(() => signaturePad().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const SignaturePadHiddenInput = props => {
  const [hiddenInputProps, localProps] = createSplitProps()(props, ['value']);
  const signaturePad = useSignaturePadContext();
  const mergedProps = solid.mergeProps(() => signaturePad().getHiddenInputProps(hiddenInputProps), localProps);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const useSignaturePad = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(signaturePad__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => signaturePad__namespace.connect(state, send, solid.normalizeProps));
};

const SignaturePadRoot = props => {
  const [useSignaturePadProps, localProps] = createSplitProps()(props, ['id', 'ids', 'drawing', 'disabled', 'readOnly', 'name', 'onDraw', 'onDrawEnd', 'readOnly', 'required', 'translations']);
  const signaturePad = useSignaturePad(useSignaturePadProps);
  const mergedProps = solid.mergeProps(() => signaturePad().getRootProps(), localProps);
  return web.createComponent(SignaturePadProvider, {
    value: signaturePad,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SignaturePadRootProvider = props => {
  const [{
    value: signaturePad
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => signaturePad().getRootProps(), localProps);
  return web.createComponent(SignaturePadProvider, {
    value: signaturePad,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var _tmpl$$1 = /*#__PURE__*/web.template(`<title>Signature`),
  _tmpl$2 = /*#__PURE__*/web.template(`<svg><path></svg>`, false, true);
const SignaturePadSegment = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = solid.mergeProps(() => signaturePad().getSegmentProps(), props);
  return web.createComponent(ark.svg, web.mergeProps(mergedProps, {
    get children() {
      return [_tmpl$$1(), web.createComponent(solidJs.For, {
        get each() {
          return signaturePad().paths;
        },
        children: path => (() => {
          var _el$3 = _tmpl$2();
          web.spread(_el$3, web.mergeProps(() => signaturePad().getSegmentPathProps({
            path
          })), true, false);
          return _el$3;
        })()
      }), web.createComponent(solidJs.Show, {
        get when() {
          return signaturePad().currentPath;
        },
        get children() {
          var _el$2 = _tmpl$2();
          web.spread(_el$2, web.mergeProps(() => signaturePad().getSegmentPathProps({
            path: signaturePad().currentPath
          })), true, false);
          return _el$2;
        }
      })];
    }
  }));
};

var signaturePad = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: SignaturePadClearTrigger,
  Context: SignaturePadContext,
  Control: SignaturePadControl,
  Guide: SignaturePadGuide,
  HiddenInput: SignaturePadHiddenInput,
  Label: SignaturePadLabel,
  Root: SignaturePadRoot,
  RootProvider: SignaturePadRootProvider,
  Segment: SignaturePadSegment
});

const [SliderProvider, useSliderContext] = createContext({
  hookName: 'useSliderContext',
  providerName: '<SliderProvider />'
});

const SliderContext = props => props.children(useSliderContext());

const SliderControl = props => {
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext({
  hookName: 'useSliderThumbPropsContext',
  providerName: '<SliderThumbPropsProvider />'
});

const SliderHiddenInput = props => {
  const slider = useSliderContext();
  const thumbProps = useSliderThumbPropsContext();
  const mergedProps = solid.mergeProps(slider().getHiddenInputProps(thumbProps), props);
  return web.createComponent(ark.input, mergedProps);
};

const SliderLabel = props => {
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const SliderMarker = props => {
  const [markerProps, localProps] = createSplitProps()(props, ['value']);
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getMarkerProps(markerProps), localProps);
  return web.createComponent(ark.span, mergedProps);
};

const SliderMarkerGroup = props => {
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getMarkerGroupProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const SliderRange = props => {
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getRangeProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const useSlider = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(slider__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => slider__namespace.connect(state, send, solid.normalizeProps));
};

const SliderRoot = props => {
  const [useSliderProps, localProps] = createSplitProps()(props, ['aria-label', 'aria-labelledby', 'defaultValue', 'disabled', 'form', 'getAriaValueText', 'id', 'ids', 'invalid', 'max', 'min', 'minStepsBetweenThumbs', 'name', 'onFocusChange', 'onValueChange', 'onValueChangeEnd', 'orientation', 'origin', 'readOnly', 'step', 'thumbAlignment', 'thumbAlignment', 'thumbSize', 'value']);
  const api = useSlider(useSliderProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(SliderProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SliderRootProvider = props => {
  const [{
    value: slider
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => slider().getRootProps(), localProps);
  return web.createComponent(SliderProvider, {
    value: slider,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SliderThumb = props => {
  const [thumbProps, localProps] = createSplitProps()(props, ['index', 'name']);
  const slider = useSliderContext();
  const mergedProps = solid.mergeProps(() => slider().getThumbProps(thumbProps), localProps);
  return web.createComponent(SliderThumbPropsProvider, {
    value: thumbProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SliderTrack = props => {
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getTrackProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const SliderValueText = props => {
  const api = useSliderContext();
  const mergedProps = solid.mergeProps(() => api().getValueTextProps(), props);
  return web.createComponent(ark.span, web.mergeProps(mergedProps, {
    get children() {
      return props.children || api().value.join(',');
    }
  }));
};

var slider = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SliderContext,
  Control: SliderControl,
  HiddenInput: SliderHiddenInput,
  Label: SliderLabel,
  Marker: SliderMarker,
  MarkerGroup: SliderMarkerGroup,
  Range: SliderRange,
  Root: SliderRoot,
  RootProvider: SliderRootProvider,
  Thumb: SliderThumb,
  Track: SliderTrack,
  ValueText: SliderValueText
});

const [SplitterProvider, useSplitterContext] = createContext({
  hookName: 'useSplitterContext',
  providerName: '<SplitterProvider />'
});

const SplitterContext = props => props.children(useSplitterContext());

const SplitterPanel = props => {
  const [panelProps, restProps] = createSplitProps()(props, ['id', 'snapSize']);
  const api = useSplitterContext();
  const mergedProps = solid.mergeProps(() => api().getPanelProps(panelProps), restProps);
  return web.createComponent(ark.div, mergedProps);
};

const SplitterResizeTrigger = props => {
  const [resizeTriggerProps, restProps] = createSplitProps()(props, ['disabled', 'id', 'step']);
  const api = useSplitterContext();
  const mergedProps = solid.mergeProps(() => api().getResizeTriggerProps(resizeTriggerProps), restProps);
  return web.createComponent(ark.button, mergedProps);
};

const useSplitter = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    size: props.defaultSize,
    ...props
  }));
  const [state, send] = solid.useMachine(splitter__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => splitter__namespace.connect(state, send, solid.normalizeProps));
};

const SplitterRoot = props => {
  const [useSplitterProps, localProps] = createSplitProps()(props, ['defaultSize', 'id', 'ids', 'onSizeChange', 'onSizeChangeEnd', 'orientation', 'size']);
  const api = useSplitter(useSplitterProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(SplitterProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const SplitterRootProvider = props => {
  const [{
    value: splitter
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => splitter().getRootProps(), localProps);
  return web.createComponent(SplitterProvider, {
    value: splitter,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var splitter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SplitterContext,
  Panel: SplitterPanel,
  ResizeTrigger: SplitterResizeTrigger,
  Root: SplitterRoot,
  RootProvider: SplitterRootProvider
});

const [SwitchProvider, useSwitchContext] = createContext({
  hookName: 'useSwitchContext',
  providerName: '<SwitchProvider />'
});

const SwitchContext = props => props.children(useSwitchContext());

const SwitchControl = props => {
  const api = useSwitchContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const SwitchHiddenInput = props => {
  const api = useSwitchContext();
  const mergedProps = solid.mergeProps(() => api().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const SwitchLabel = props => {
  const api = useSwitchContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

const useSwitch = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    invalid: field?.().invalid,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    checked: props.defaultChecked,
    ...props
  }));
  const [state, send] = solid.useMachine(zagSwitch__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => zagSwitch__namespace.connect(state, send, solid.normalizeProps));
};

const SwitchRoot = props => {
  const [switchProps, localProps] = createSplitProps()(props, ['checked', 'defaultChecked', 'disabled', 'form', 'id', 'ids', 'invalid', 'label', 'name', 'onCheckedChange', 'readOnly', 'required', 'value']);
  const api = useSwitch(switchProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(SwitchProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.label, mergedProps);
    }
  });
};

const SwitchRootProvider = props => {
  const [{
    value: api
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(SwitchProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.label, mergedProps);
    }
  });
};

const SwitchThumb = props => {
  const api = useSwitchContext();
  const mergedProps = solid.mergeProps(() => api().getThumbProps(), props);
  return web.createComponent(ark.span, mergedProps);
};

var _switch = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SwitchContext,
  Control: SwitchControl,
  HiddenInput: SwitchHiddenInput,
  Label: SwitchLabel,
  Root: SwitchRoot,
  RootProvider: SwitchRootProvider,
  Thumb: SwitchThumb
});

const [TabsProvider, useTabsContext] = createContext({
  hookName: 'useTabsContext',
  providerName: '<TabsProvider />'
});

const TabContent = props => {
  const [contentProps, localProps] = createSplitProps()(props, ['value']);
  const api = useTabsContext();
  const renderStrategyProps = useRenderStrategyContext();
  const presenceApi = usePresence(solid.mergeProps(renderStrategyProps, () => ({
    present: api().value === contentProps.value,
    immediate: true
  })));
  const mergedProps = solid.mergeProps(() => api().getContentProps(contentProps), () => presenceApi().presenceProps, localProps);
  return web.createComponent(PresenceProvider, {
    value: presenceApi,
    get children() {
      return web.createComponent(solidJs.Show, {
        get when() {
          return !presenceApi().unmounted;
        },
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TabIndicator = props => {
  const api = useTabsContext();
  const mergedProps = solid.mergeProps(() => api().getIndicatorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TabList = props => {
  const api = useTabsContext();
  const mergedProps = solid.mergeProps(() => api().getListProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TabTrigger = props => {
  const [triggerProps, localProps] = createSplitProps()(props, ['disabled', 'value']);
  const api = useTabsContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(triggerProps), localProps);
  return web.createComponent(ark.button, mergedProps);
};

const TabsContext = props => props.children(useTabsContext());

const useTabs = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(tabs__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => tabs__namespace.connect(state, send, solid.normalizeProps));
};

const TabsRoot = props => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [useTabsProps, restProps] = createSplitProps()(tabsProps, ['activationMode', 'composite', 'defaultValue', 'id', 'ids', 'loopFocus', 'onFocusChange', 'onValueChange', 'orientation', 'translations', 'value']);
  const api = useTabs(useTabsProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), restProps);
  return web.createComponent(TabsProvider, {
    value: api,
    get children() {
      return web.createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TabsRootProvider = props => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [{
    value: tabs
  }, localprops] = createSplitProps()(tabsProps, ['value']);
  const mergedProps = solid.mergeProps(() => tabs().getRootProps(), localprops);
  return web.createComponent(TabsProvider, {
    value: tabs,
    get children() {
      return web.createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

var tabs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: TabContent,
  Context: TabsContext,
  Indicator: TabIndicator,
  List: TabList,
  Root: TabsRoot,
  RootProvider: TabsRootProvider,
  Trigger: TabTrigger
});

const [TagsInputProvider, useTagsInputContext] = createContext({
  hookName: 'useTagsInputContext',
  providerName: '<TagsInputProvider />'
});

const TagsInputClearTrigger = props => {
  const api = useTagsInputContext();
  const mergedProps = solid.mergeProps(() => api().getClearTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const TagsInputContext = props => props.children(useTagsInputContext());

const TagsInputControl = props => {
  const api = useTagsInputContext();
  const mergedProps = solid.mergeProps(() => api().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TagsInputHiddenInput = props => {
  const tagsInput = useTagsInputContext();
  const mergedProps = solid.mergeProps(() => tagsInput().getHiddenInputProps(), props);
  const field = useFieldContext();
  return web.createComponent(ark.input, web.mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const TagsInputInput = props => {
  const api = useTagsInputContext();
  const mergedProps = solid.mergeProps(() => api().getInputProps(), props);
  return web.createComponent(ark.input, mergedProps);
};

const [TagsInputItemProvider, useTagsInputItemContext] = createContext({
  hookName: 'useTagsInputItemContext',
  providerName: '<TagsInputItemProvider />'
});

const [TagsInputItemPropsProvider, useTagsInputItemPropsContext] = createContext({
  hookName: 'useTagsInputItemPropsContext',
  providerName: '<TagsInputItemPropsProvider />'
});

const TagsInputItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['disabled', 'index', 'value']);
  const api = useTagsInputContext();
  const mergedProps = solid.mergeProps(() => api().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => api().getItemState(itemProps));
  return web.createComponent(TagsInputItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(TagsInputItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TagsInputItemContext = props => props.children(useTagsInputItemContext());

const TagsInputItemDeleteTrigger = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemDeleteTriggerProps(itemProps), props);
  return web.createComponent(ark.button, mergedProps);
};

const TagsInputItemInput = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemInputProps(itemProps), props);
  return web.createComponent(ark.input, mergedProps);
};

const TagsInputItemPreview = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemPreviewProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const TagsInputItemText = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemTextProps(itemProps), props);
  return web.createComponent(ark.span, mergedProps);
};

const TagsInputLabel = props => {
  const api = useTagsInputContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useTagsInput = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const field = useFieldContext();
  const context = solidJs.createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    invalid: field?.().invalid,
    readOnly: field?.().readOnly,
    required: field?.().required,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(tagsInput__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => tagsInput__namespace.connect(state, send, solid.normalizeProps));
};

const TagsInputRoot = props => {
  const [useTagsInputProps, localProps] = createSplitProps()(props, ['addOnPaste', 'allowOverflow', 'autoFocus', 'blurBehavior', 'delimiter', 'defaultValue', 'disabled', 'editable', 'form', 'id', 'ids', 'inputValue', 'invalid', 'max', 'maxLength', 'name', 'onFocusOutside', 'onHighlightChange', 'onInputValueChange', 'onInteractOutside', 'onPointerDownOutside', 'onValueChange', 'onValueInvalid', 'readOnly', 'required', 'translations', 'validate', 'value']);
  const api = useTagsInput(useTagsInputProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(TagsInputProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TagsInputRootProvider = props => {
  const [{
    value: tagsInput
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => tagsInput().getRootProps(), localProps);
  return web.createComponent(TagsInputProvider, {
    value: tagsInput,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var tagsInput = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: TagsInputClearTrigger,
  Context: TagsInputContext,
  Control: TagsInputControl,
  HiddenInput: TagsInputHiddenInput,
  Input: TagsInputInput,
  Item: TagsInputItem,
  ItemContext: TagsInputItemContext,
  ItemDeleteTrigger: TagsInputItemDeleteTrigger,
  ItemInput: TagsInputItemInput,
  ItemPreview: TagsInputItemPreview,
  ItemText: TagsInputItemText,
  Label: TagsInputLabel,
  Root: TagsInputRoot,
  RootProvider: TagsInputRootProvider
});

const [TimePickerColumnPropsProvider, useTimePickerColumnPropsContext] = createContext({
  hookName: 'useTimePickerColumnPropsContext',
  providerName: '<TimePickerColumnPropsProvider />'
});

const [TimePickerProvider, useTimePickerContext] = createContext({
  hookName: 'useTimePickerContext',
  providerName: '<TimePickerProvider />'
});

const TimePickerCell = props => {
  const [cellProps, localProps] = createSplitProps()(props, ['value']);
  const timePicker = useTimePickerContext();
  const columnProps = useTimePickerColumnPropsContext();
  const unitToPropsMap = {
    hour: () => timePicker().getHourCellProps(cellProps),
    minute: () => timePicker().getMinuteCellProps(cellProps),
    second: () => timePicker().getSecondCellProps(cellProps),
    period: () => timePicker().getPeriodCellProps(cellProps)
  };
  const mergedProps = solid.mergeProps(() => unitToPropsMap[columnProps.unit](), localProps);
  return web.createComponent(ark.button, mergedProps);
};

const TimePickerClearTrigger = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getClearTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const TimePickerColumn = props => {
  const [columnProps, localProps] = createSplitProps()(props, ['unit']);
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getColumnProps(columnProps), localProps);
  return web.createComponent(TimePickerColumnPropsProvider, {
    value: columnProps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TimePickerContent = props => {
  const timePicker = useTimePickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => timePicker().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TimePickerContext = props => props.children(useTimePickerContext());

const TimePickerControl = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getControlProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TimePickerInput = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getInputProps(), props);
  return web.createComponent(ark.input, mergedProps);
};

const TimePickerLabel = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const TimePickerPositioner = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getPositionerProps(), props);
  const presenceApi = usePresenceContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useTimePicker = (props = {}) => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props,
    value: props.defaultValue ? date.parseTime(props.defaultValue) : undefined,
    min: props.min ? date.parseTime(props.min) : undefined,
    max: props.max ? date.parseTime(props.max) : undefined
  }));
  const [state, send] = solid.useMachine(timePicker__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => timePicker__namespace.connect(state, send, solid.normalizeProps));
};

const TimePickerRoot = props => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props);
  const [useTimePickerProps, localProps] = createSplitProps()(timePickerProps, ['allowSeconds', 'defaultOpen', 'defaultValue', 'disableLayer', 'disabled', 'id', 'ids', 'locale', 'max', 'min', 'name', 'onFocusChange', 'onOpenChange', 'onValueChange', 'open', 'placeholder', 'positioning', 'readOnly', 'steps', 'value']);
  const timePicker = useTimePicker(useTimePickerProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: timePicker().open
  })));
  const mergedProps = solid.mergeProps(() => timePicker().getRootProps(), localProps);
  return web.createComponent(TimePickerProvider, {
    value: timePicker,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TimePickerRootProvider = props => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props);
  const [{
    value: timePicker
  }, localProps] = createSplitProps()(timePickerProps, ['value']);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: timePicker().open
  })));
  const mergedProps = solid.mergeProps(() => timePicker().getRootProps(), localProps);
  return web.createComponent(TimePickerProvider, {
    value: timePicker,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return web.createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TimePickerSpacer = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getSpacerProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TimePickerTrigger = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = solid.mergeProps(() => timePicker().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var timePicker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Cell: TimePickerCell,
  ClearTrigger: TimePickerClearTrigger,
  Column: TimePickerColumn,
  Content: TimePickerContent,
  Context: TimePickerContext,
  Control: TimePickerControl,
  Input: TimePickerInput,
  Label: TimePickerLabel,
  Positioner: TimePickerPositioner,
  Root: TimePickerRoot,
  RootProvider: TimePickerRootProvider,
  Spacer: TimePickerSpacer,
  Trigger: TimePickerTrigger
});

const createToaster = props => {
  const machine = toast__namespace.group.machine({
    id: '1',
    ...props
  });
  const api = toast__namespace.group.connect(machine, machine.send, solid.normalizeProps);
  return {
    ...api,
    machine
  };
};

const [ToastProvider, useToastContext] = createContext({
  hookName: 'useToastContext',
  providerName: '<ToastProvider />'
});

const ToastActionTrigger = props => {
  const toast = useToastContext();
  const mergedProps = solid.mergeProps(() => toast().getActionTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const ToastCloseTrigger = props => {
  const toast = useToastContext();
  const mergedProps = solid.mergeProps(() => toast().getCloseTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const ToastContext = props => props.children(useToastContext());

const ToastDescription = props => {
  const toast = useToastContext();
  const mergedProps = solid.mergeProps(() => toast().getDescriptionProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

var _tmpl$ = /*#__PURE__*/web.template(`<div><div></div><div>`);
const ToastRoot = props => {
  const toast = useToastContext();
  const mergedProps = solid.mergeProps(() => toast().getRootProps(), props);
  return (() => {
    var _el$ = _tmpl$(),
      _el$2 = _el$.firstChild,
      _el$3 = _el$2.nextSibling;
    web.spread(_el$, mergedProps, false, true);
    web.spread(_el$2, web.mergeProps(() => toast().getGhostBeforeProps()), false, false);
    web.insert(_el$, () => props.children, _el$3);
    web.spread(_el$3, web.mergeProps(() => toast().getGhostAfterProps()), false, false);
    return _el$;
  })();
};

const ToastTitle = props => {
  const toast = useToastContext();
  const mergedProps = solid.mergeProps(() => toast().getTitleProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const Toaster = props => {
  const [toasterProps, localProps] = solidJs.splitProps(props, ['toaster', 'children']);
  const [state, send] = solid.useMachine(toasterProps.toaster.machine);
  const placement = state.context.placement;
  const api = solidJs.createMemo(() => toast__namespace.group.connect(state, send, solid.normalizeProps));
  const toasts = solidJs.createMemo(() => api().getToastsByPlacement(placement));
  const mergedProps = solid.mergeProps(api().getGroupProps({
    placement
  }), localProps);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get children() {
      return web.createComponent(solidJs.For, {
        get each() {
          return toasts();
        },
        children: toast => web.createComponent(ToastActor, {
          value: toast,
          children: ctx => toasterProps.children(ctx)
        })
      });
    }
  }));
};
const ToastActor = props => {
  const [state, send] = solid.useActor(props.value);
  const api = solidJs.createMemo(() => toast__namespace.connect(state, send, solid.normalizeProps));
  const ctx = solidJs.createMemo(() => state.context);
  return web.createComponent(ToastProvider, {
    value: api,
    get children() {
      return props.children(ctx);
    }
  });
};

var toast = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ActionTrigger: ToastActionTrigger,
  CloseTrigger: ToastCloseTrigger,
  Context: ToastContext,
  Description: ToastDescription,
  Root: ToastRoot,
  Title: ToastTitle
});

const [ToggleGroupProvider, useToggleGroupContext] = createContext({
  hookName: 'useToggleGroupContext',
  providerName: '<ToggleGroupProvider />'
});

const ToggleGroupContext = props => props.children(useToggleGroupContext());

const ToggleGroupItem = props => {
  const [toggleProps, restProps] = createSplitProps()(props, ['value', 'disabled']);
  const api = useToggleGroupContext();
  const mergedProps = solid.mergeProps(() => api().getItemProps(toggleProps), restProps);
  return web.createComponent(ark.button, mergedProps);
};

const useToggleGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = solid.useMachine(toggleGroup__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => toggleGroup__namespace.connect(state, send, solid.normalizeProps));
};

const ToggleGroupRoot = props => {
  const [useToggleGroupProps, restProps] = createSplitProps()(props, ['defaultValue', 'disabled', 'id', 'ids', 'loopFocus', 'multiple', 'onValueChange', 'orientation', 'rovingFocus', 'value']);
  const api = useToggleGroup(useToggleGroupProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), restProps);
  return web.createComponent(ToggleGroupProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const ToggleGroupRootProvider = props => {
  const [{
    value: toggleGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => toggleGroup().getRootProps(), localProps);
  return web.createComponent(ToggleGroupProvider, {
    value: toggleGroup,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var toggleGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: ToggleGroupContext,
  Item: ToggleGroupItem,
  Root: ToggleGroupRoot,
  RootProvider: ToggleGroupRootProvider
});

const [TooltipProvider, useTooltipContext] = createContext({
  hookName: 'useTooltipContext',
  providerName: '<TooltipProvider />'
});

const TooltipArrow = props => {
  const tooltip = useTooltipContext();
  const mergedProps = solid.mergeProps(() => tooltip().getArrowProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TooltipArrowTip = props => {
  const api = useTooltipContext();
  const mergedProps = solid.mergeProps(() => api().getArrowTipProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const TooltipContent = props => {
  const api = useTooltipContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TooltipContext = props => props.children(useTooltipContext());

const TooltipPositioner = props => {
  const api = useTooltipContext();
  const presenceApi = usePresenceContext();
  const mergedProps = solid.mergeProps(() => api().getPositionerProps(), props);
  return web.createComponent(solidJs.Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const useTooltip = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = solid.useMachine(tooltip__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => tooltip__namespace.connect(state, send, solid.normalizeProps));
};

const TooltipRoot = props => {
  const [presenceProps, tooltipProps] = splitPresenceProps(props);
  const [useTooltipProps, localProps] = createSplitProps()(tooltipProps, ['aria-label', 'closeDelay', 'closeOnClick', 'closeOnEscape', 'closeOnPointerDown', 'closeOnScroll', 'defaultOpen', 'disabled', 'id', 'ids', 'interactive', 'onOpenChange', 'open', 'openDelay', 'positioning']);
  const api = useTooltip(useTooltipProps);
  const apiPresence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: api().open
  })));
  return web.createComponent(TooltipProvider, {
    value: api,
    get children() {
      return web.createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return localProps.children;
        }
      });
    }
  });
};

const TooltipRootProvider = props => {
  const [presenceProps, tooltipProps] = splitPresenceProps(props);
  const presence = usePresence(solid.mergeProps(presenceProps, () => ({
    present: tooltipProps.value().open
  })));
  return web.createComponent(TooltipProvider, {
    get value() {
      return tooltipProps.value;
    },
    get children() {
      return web.createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return tooltipProps.children;
        }
      });
    }
  });
};

const TooltipTrigger = props => {
  const api = useTooltipContext();
  const mergedProps = solid.mergeProps(() => api().getTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

var tooltip = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: TooltipArrow,
  ArrowTip: TooltipArrowTip,
  Content: TooltipContent,
  Context: TooltipContext,
  Positioner: TooltipPositioner,
  Root: TooltipRoot,
  RootProvider: TooltipRootProvider,
  Trigger: TooltipTrigger
});

const [TreeViewBranchProvider, useTreeViewBranchContext] = createContext({
  hookName: 'useTreeViewBranchContext',
  providerName: '<TreeViewBranchProvider />'
});

const [TreeViewProvider, useTreeViewContext] = createContext({
  hookName: 'useTreeViewContext',
  providerName: '<TreeViewProvider />'
});

const [TreeViewDepthProvider, useTreeViewDepthContext] = createContext({
  hookName: 'useTreeViewDepthContext',
  providerName: '<TreeViewDepthProvider />'
});

const TreeViewBranch = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['disabled', 'value']);
  const api = useTreeViewContext();
  const depth = useTreeViewDepthContext();
  const branchProps = solid.mergeProps(itemProps, {
    depth
  });
  const mergedProps = solid.mergeProps(() => api().getBranchProps(branchProps), localProps);
  return web.createComponent(TreeViewDepthProvider, {
    value: depth + 1,
    get children() {
      return web.createComponent(TreeViewBranchProvider, {
        value: branchProps,
        get children() {
          return web.createComponent(ark.li, mergedProps);
        }
      });
    }
  });
};

const TreeViewBranchContent = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = solid.mergeProps(() => api().getBranchContentProps(branchProps), props);
  return web.createComponent(ark.ul, mergedProps);
};

const TreeViewBranchControl = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = solid.mergeProps(() => api().getBranchControlProps(branchProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const TreeViewBranchIndicator = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = solid.mergeProps(() => api().getBranchIndicatorProps(branchProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const TreeViewBranchText = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = solid.mergeProps(() => api().getBranchTextProps(branchProps), props);
  return web.createComponent(ark.span, mergedProps);
};

const TreeViewBranchTrigger = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = solid.mergeProps(() => api().getBranchTriggerProps(branchProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const TreeViewContext = props => props.children(useTreeViewContext());

const [TreeViewItemProvider, useTreeViewItemContext] = createContext({
  hookName: 'useTreeViewItemContext',
  providerName: '<TreeViewItemProvider />'
});

const [TreeViewItemPropsProvider, useTreeViewItemPropsContext] = createContext({
  hookName: 'useTreeViewItemPropsContext',
  providerName: '<TreeViewItemProvider />'
});

const TreeViewItem = props => {
  const [_itemProps, localProps] = createSplitProps()(props, ['disabled', 'value']);
  const api = useTreeViewContext();
  const depth = useTreeViewDepthContext();
  const itemProps = solid.mergeProps(_itemProps, {
    depth
  });
  const itemState = solidJs.createMemo(() => api().getItemState(itemProps));
  const mergedProps = solid.mergeProps(() => api().getItemProps(itemProps), localProps);
  return web.createComponent(TreeViewItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(TreeViewItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.li, mergedProps);
        }
      });
    }
  });
};

const TreeViewItemContext = props => props.children(useTreeViewItemContext());

const TreeViewItemIndicator = props => {
  const api = useTreeViewContext();
  const itemProps = useTreeViewItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemIndicatorProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const TreeViewItemText = props => {
  const api = useTreeViewContext();
  const itemProps = useTreeViewItemPropsContext();
  const mergedProps = solid.mergeProps(() => api().getItemTextProps(itemProps), props);
  return web.createComponent(ark.span, mergedProps);
};

const TreeViewLabel = props => {
  const api = useTreeViewContext();
  const mergedProps = solid.mergeProps(() => api().getLabelProps(), props);
  return web.createComponent(ark.label, mergedProps);
};

const useTreeView = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    selectedValue: props.defaultSelectedValue,
    expandedValue: props.defaultExpandedValue,
    ...props
  }));
  const [state, send] = solid.useMachine(treeView__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => treeView__namespace.connect(state, send, solid.normalizeProps));
};

const TreeViewRoot = props => {
  const [useTreeViewProps, localProps] = createSplitProps()(props, ['defaultExpandedValue', 'defaultSelectedValue', 'expandedValue', 'expandOnClick', 'focusedValue', 'id', 'ids', 'onExpandedChange', 'onFocusChange', 'onSelectionChange', 'selectedValue', 'selectionMode', 'typeahead']);
  const api = useTreeView(useTreeViewProps);
  const mergedProps = solid.mergeProps(() => api().getRootProps(), localProps);
  return web.createComponent(TreeViewProvider, {
    value: api,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TreeViewRootProvider = props => {
  const [{
    value: treeView
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => treeView().getRootProps(), localProps);
  return web.createComponent(TreeViewProvider, {
    value: treeView,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TreeViewTree = props => {
  const api = useTreeViewContext();
  const mergedProps = solid.mergeProps(() => api().getTreeProps(), props);
  return web.createComponent(TreeViewDepthProvider, {
    value: 1,
    get children() {
      return web.createComponent(ark.ul, mergedProps);
    }
  });
};

var treeView = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Branch: TreeViewBranch,
  BranchContent: TreeViewBranchContent,
  BranchControl: TreeViewBranchControl,
  BranchIndicator: TreeViewBranchIndicator,
  BranchText: TreeViewBranchText,
  BranchTrigger: TreeViewBranchTrigger,
  Context: TreeViewContext,
  Item: TreeViewItem,
  ItemContext: TreeViewItemContext,
  ItemIndicator: TreeViewItemIndicator,
  ItemText: TreeViewItemText,
  Label: TreeViewLabel,
  Root: TreeViewRoot,
  RootProvider: TreeViewRootProvider,
  Tree: TreeViewTree
});

const [TimerProvider, useTimerContext] = createContext({
  hookName: 'useTimerContext',
  providerName: '<TimerProvider />'
});

const TimerContext = props => props.children(useTimerContext());

const TimerActionTrigger = props => {
  const timer = useTimerContext();
  const mergedProps = solid.mergeProps(() => timer().getActionTriggerProps(props), props);
  return web.createComponent(ark.button, mergedProps);
};

const TimerItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['type']);
  const timer = useTimerContext();
  const mergedProps = solid.mergeProps(() => timer().getItemProps(itemProps), localProps);
  return web.createComponent(ark.div, web.mergeProps(mergedProps, {
    get children() {
      return timer().formattedTime[itemProps.type];
    }
  }));
};

const TimerSeparator = props => {
  const timer = useTimerContext();
  const mergedProps = solid.mergeProps(() => timer().getSeparatorProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

const useTimer = props => {
  const env = useEnvironmentContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    getRootNode: env().getRootNode,
    ...props
  }));
  const [state, send] = solid.useMachine(timer__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => timer__namespace.connect(state, send, solid.normalizeProps));
};

const TimerRoot = props => {
  const [useTimerProps, localProps] = createSplitProps()(props, ['id', 'autoStart', 'interval', 'countdown', 'startMs', 'targetMs', 'onComplete', 'onTick']);
  const timer = useTimer(useTimerProps);
  const mergedProps = solid.mergeProps(() => timer().getRootProps(), localProps);
  return web.createComponent(TimerProvider, {
    value: timer,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const TimerRootProvider = props => {
  const [{
    value: timer
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => timer().getRootProps(), localProps);
  return web.createComponent(TimerProvider, {
    value: timer,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

var timer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ActionTrigger: TimerActionTrigger,
  Context: TimerContext,
  Item: TimerItem,
  Root: TimerRoot,
  RootProvider: TimerRootProvider,
  Separator: TimerSeparator
});

const [StepsProvider, useStepsContext] = createContext({
  hookName: 'useStepsContext',
  providerName: '<StepsProvider />'
});

const StepsCompletedContent = props => {
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getContentProps({
    index: steps().count
  }), props);
  return web.createComponent(ark.div, mergedProps);
};

const StepsContent = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getContentProps(itemProps), localProps);
  return web.createComponent(ark.div, mergedProps);
};

const StepsContext = props => {
  const context = useStepsContext();
  return props.children(context);
};

const [StepsItemPropsProvider, useStepsItemPropsContext] = createContext({
  hookName: 'useStepsItemPropsContext',
  providerName: '<StepsItemPropsProvider />'
});

const StepsIndicator = props => {
  const steps = useStepsContext();
  const itemProps = useStepsItemPropsContext();
  const mergedProps = solid.mergeProps(() => steps().getIndicatorProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const [StepsItemProvider, useStepsItemContext] = createContext({
  hookName: 'useStepsItemContext',
  providerName: '<StepsItem />'
});

const StepsItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getItemProps(itemProps), localProps);
  const itemState = solidJs.createMemo(() => steps().getItemState(itemProps));
  return web.createComponent(StepsItemPropsProvider, {
    value: itemProps,
    get children() {
      return web.createComponent(StepsItemProvider, {
        value: itemState,
        get children() {
          return web.createComponent(ark.li, mergedProps);
        }
      });
    }
  });
};

const StepsItemContext = props => {
  return props.children(useStepsItemContext());
};
StepsItemContext.displayName = 'StepsItemContext';

const StepsList = props => {
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getListProps(), props);
  return web.createComponent(ark.ol, mergedProps);
};

const StepsNextTrigger = props => {
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getNextTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const StepsPrevTrigger = props => {
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getPrevTriggerProps(), props);
  return web.createComponent(ark.button, mergedProps);
};

const StepsProgress = props => {
  const steps = useStepsContext();
  const mergedProps = solid.mergeProps(() => steps().getProgressProps(), props);
  return web.createComponent(ark.div, mergedProps);
};

function useSteps(props = {}) {
  const environment = useEnvironmentContext();
  const locale = useLocaleContext();
  const id = solidJs.createUniqueId();
  const context = solidJs.createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    step: props.defaultStep,
    ...props
  }));
  const [state, send] = solid.useMachine(steps__namespace.machine(context()), {
    context
  });
  return solidJs.createMemo(() => steps__namespace.connect(state, send, solid.normalizeProps));
}

const StepsRoot = props => {
  const [useStepsProps, localProps] = createSplitProps()(props, ['defaultStep', 'id', 'ids', 'count', 'linear', 'onStepChange', 'onStepComplete', 'orientation', 'step']);
  const steps = useSteps(useStepsProps);
  const mergedProps = solid.mergeProps(() => steps().getRootProps(), localProps);
  return web.createComponent(StepsProvider, {
    value: steps,
    get children() {
      return web.createComponent(ark.div, mergedProps);
    }
  });
};

const StepsRootProvider = props => {
  const [{
    value: steps
  }, rootProps] = createSplitProps()(props, ['value']);
  const mergedProps = solid.mergeProps(() => steps().getRootProps(), rootProps);
  return web.createComponent(StepsProvider, {
    value: steps,
    get children() {
      return web.createComponent(ark.div, web.mergeProps(mergedProps, {
        get children() {
          return props.children;
        }
      }));
    }
  });
};

const StepsSeparator = props => {
  const steps = useStepsContext();
  const itemProps = useStepsItemPropsContext();
  const mergedProps = solid.mergeProps(() => steps().getSeparatorProps(itemProps), props);
  return web.createComponent(ark.div, mergedProps);
};

const StepsTrigger = props => {
  const steps = useStepsContext();
  const itemProps = useStepsItemPropsContext();
  const mergedProps = solid.mergeProps(() => steps().getTriggerProps(itemProps), props);
  return web.createComponent(ark.button, mergedProps);
};

var steps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CompletedContent: StepsCompletedContent,
  Content: StepsContent,
  Context: StepsContext,
  Indicator: StepsIndicator,
  Item: StepsItem,
  ItemContext: StepsItemContext,
  List: StepsList,
  NextTrigger: StepsNextTrigger,
  PrevTrigger: StepsPrevTrigger,
  Progress: StepsProgress,
  Root: StepsRoot,
  RootProvider: StepsRootProvider,
  Separator: StepsSeparator,
  Trigger: StepsTrigger
});

Object.defineProperty(exports, "collapsibleAnatomy", {
  enumerable: true,
  get: function () { return collapsible$1.anatomy; }
});
Object.defineProperty(exports, "accordionAnatomy", {
  enumerable: true,
  get: function () { return accordion$1.anatomy; }
});
Object.defineProperty(exports, "avatarAnatomy", {
  enumerable: true,
  get: function () { return avatar$1.anatomy; }
});
Object.defineProperty(exports, "clipboardAnatomy", {
  enumerable: true,
  get: function () { return clipboard$1.anatomy; }
});
Object.defineProperty(exports, "comboboxAnatomy", {
  enumerable: true,
  get: function () { return combobox$1.anatomy; }
});
Object.defineProperty(exports, "dialogAnatomy", {
  enumerable: true,
  get: function () { return dialog$1.anatomy; }
});
Object.defineProperty(exports, "editableAnatomy", {
  enumerable: true,
  get: function () { return editable$1.anatomy; }
});
Object.defineProperty(exports, "fileUploadAnatomy", {
  enumerable: true,
  get: function () { return fileUpload$1.anatomy; }
});
Object.defineProperty(exports, "hoverCardAnatomy", {
  enumerable: true,
  get: function () { return hoverCard$1.anatomy; }
});
Object.defineProperty(exports, "menuAnatomy", {
  enumerable: true,
  get: function () { return menu$1.anatomy; }
});
Object.defineProperty(exports, "numberInputAnatomy", {
  enumerable: true,
  get: function () { return numberInput$1.anatomy; }
});
Object.defineProperty(exports, "paginationAnatomy", {
  enumerable: true,
  get: function () { return pagination$1.anatomy; }
});
Object.defineProperty(exports, "pinInputAnatomy", {
  enumerable: true,
  get: function () { return pinInput$1.anatomy; }
});
Object.defineProperty(exports, "popoverAnatomy", {
  enumerable: true,
  get: function () { return popover$1.anatomy; }
});
Object.defineProperty(exports, "progressAnatomy", {
  enumerable: true,
  get: function () { return progress$1.anatomy; }
});
Object.defineProperty(exports, "qrCodeAnatomy", {
  enumerable: true,
  get: function () { return qrCode$1.anatomy; }
});
Object.defineProperty(exports, "radioGroupAnatomy", {
  enumerable: true,
  get: function () { return radio.anatomy; }
});
Object.defineProperty(exports, "ratingGroupAnatomy", {
  enumerable: true,
  get: function () { return rating.anatomy; }
});
Object.defineProperty(exports, "selectAnatomy", {
  enumerable: true,
  get: function () { return select$1.anatomy; }
});
Object.defineProperty(exports, "signaturePadAnatomy", {
  enumerable: true,
  get: function () { return signaturePad$1.anatomy; }
});
Object.defineProperty(exports, "sliderAnatomy", {
  enumerable: true,
  get: function () { return slider$1.anatomy; }
});
Object.defineProperty(exports, "splitterAnatomy", {
  enumerable: true,
  get: function () { return splitter$1.anatomy; }
});
Object.defineProperty(exports, "switchAnatomy", {
  enumerable: true,
  get: function () { return zagSwitch.anatomy; }
});
Object.defineProperty(exports, "tabsAnatomy", {
  enumerable: true,
  get: function () { return tabs$1.anatomy; }
});
Object.defineProperty(exports, "tagsInputAnatomy", {
  enumerable: true,
  get: function () { return tagsInput$1.anatomy; }
});
Object.defineProperty(exports, "toastAnatomy", {
  enumerable: true,
  get: function () { return toast$1.anatomy; }
});
Object.defineProperty(exports, "toggleGroupAnatomy", {
  enumerable: true,
  get: function () { return toggleGroup$1.anatomy; }
});
Object.defineProperty(exports, "tooltipAnatomy", {
  enumerable: true,
  get: function () { return tooltip$1.anatomy; }
});
Object.defineProperty(exports, "treeViewAnatomy", {
  enumerable: true,
  get: function () { return treeView$1.anatomy; }
});
Object.defineProperty(exports, "stepsAnatomy", {
  enumerable: true,
  get: function () { return steps$1.anatomy; }
});
exports.Accordion = accordion;
exports.AccordionContext = AccordionContext;
exports.AccordionItem = AccordionItem;
exports.AccordionItemContent = AccordionItemContent;
exports.AccordionItemContext = AccordionItemContext;
exports.AccordionItemIndicator = AccordionItemIndicator;
exports.AccordionItemTrigger = AccordionItemTrigger;
exports.AccordionRoot = AccordionRoot;
exports.AccordionRootProvider = AccordionRootProvider;
exports.Avatar = avatar;
exports.AvatarContext = AvatarContext;
exports.AvatarFallback = AvatarFallback;
exports.AvatarImage = AvatarImage;
exports.AvatarRoot = AvatarRoot;
exports.AvatarRootProvider = AvatarRootProvider;
exports.Carousel = carousel;
exports.CarouselContext = CarouselContext;
exports.CarouselControl = CarouselControl;
exports.CarouselIndicator = CarouselIndicator;
exports.CarouselIndicatorGroup = CarouselIndicatorGroup;
exports.CarouselItem = CarouselItem;
exports.CarouselItemGroup = CarouselItemGroup;
exports.CarouselNextTrigger = CarouselNextTrigger;
exports.CarouselPrevTrigger = CarouselPrevTrigger;
exports.CarouselRoot = CarouselRoot;
exports.CarouselRootProvider = CarouselRootProvider;
exports.CarouselViewport = CarouselViewport;
exports.Checkbox = checkbox;
exports.CheckboxContext = CheckboxContext;
exports.CheckboxControl = CheckboxControl;
exports.CheckboxGroup = CheckboxGroup;
exports.CheckboxHiddenInput = CheckboxHiddenInput;
exports.CheckboxIndicator = CheckboxIndicator;
exports.CheckboxLabel = CheckboxLabel;
exports.CheckboxRoot = CheckboxRoot;
exports.CheckboxRootProvider = CheckboxRootProvider;
exports.Clipboard = clipboard;
exports.ClipboardContext = ClipboardContext;
exports.ClipboardControl = ClipboardControl;
exports.ClipboardIndicator = ClipboardIndicator;
exports.ClipboardInput = ClipboardInput;
exports.ClipboardLabel = ClipboardLabel;
exports.ClipboardRoot = ClipboardRoot;
exports.ClipboardRootProvider = ClipboardRootProvider;
exports.ClipboardTrigger = ClipboardTrigger;
exports.Collapsible = collapsible;
exports.CollapsibleContent = CollapsibleContent;
exports.CollapsibleContext = CollapsibleContext;
exports.CollapsibleRoot = CollapsibleRoot;
exports.CollapsibleRootProvider = CollapsibleRootProvider;
exports.CollapsibleTrigger = CollapsibleTrigger;
exports.ColorPicker = colorPicker;
exports.ColorPickerArea = ColorPickerArea;
exports.ColorPickerAreaBackground = ColorPickerAreaBackground;
exports.ColorPickerAreaThumb = ColorPickerAreaThumb;
exports.ColorPickerChannelInput = ColorPickerChannelInput;
exports.ColorPickerChannelSlider = ColorPickerChannelSlider;
exports.ColorPickerChannelSliderLabel = ColorPickerChannelSliderLabel;
exports.ColorPickerChannelSliderThumb = ColorPickerChannelSliderThumb;
exports.ColorPickerChannelSliderTrack = ColorPickerChannelSliderTrack;
exports.ColorPickerChannelSliderValueText = ColorPickerChannelSliderValueText;
exports.ColorPickerContent = ColorPickerContent;
exports.ColorPickerContext = ColorPickerContext;
exports.ColorPickerControl = ColorPickerControl;
exports.ColorPickerEyeDropperTrigger = ColorPickerEyeDropperTrigger;
exports.ColorPickerFormatSelect = ColorPickerFormatSelect;
exports.ColorPickerFormatTrigger = ColorPickerFormatTrigger;
exports.ColorPickerHiddenInput = ColorPickerHiddenInput;
exports.ColorPickerLabel = ColorPickerLabel;
exports.ColorPickerPositioner = ColorPickerPositioner;
exports.ColorPickerRoot = ColorPickerRoot;
exports.ColorPickerRootProvider = ColorPickerRootProvider;
exports.ColorPickerSwatch = ColorPickerSwatch;
exports.ColorPickerSwatchGroup = ColorPickerSwatchGroup;
exports.ColorPickerSwatchIndicator = ColorPickerSwatchIndicator;
exports.ColorPickerSwatchTrigger = ColorPickerSwatchTrigger;
exports.ColorPickerTransparencyGrid = ColorPickerTransparencyGrid;
exports.ColorPickerTrigger = ColorPickerTrigger;
exports.ColorPickerValueSwatch = ColorPickerValueSwatch;
exports.ColorPickerValueText = ColorPickerValueText;
exports.ColorPickerView = ColorPickerView;
exports.Combobox = combobox;
exports.ComboboxClearTrigger = ComboboxClearTrigger;
exports.ComboboxContent = ComboboxContent;
exports.ComboboxContext = ComboboxContext;
exports.ComboboxControl = ComboboxControl;
exports.ComboboxInput = ComboboxInput;
exports.ComboboxItem = ComboboxItem;
exports.ComboboxItemContext = ComboboxItemContext;
exports.ComboboxItemGroup = ComboboxItemGroup;
exports.ComboboxItemGroupLabel = ComboboxItemGroupLabel;
exports.ComboboxItemIndicator = ComboboxItemIndicator;
exports.ComboboxItemText = ComboboxItemText;
exports.ComboboxLabel = ComboboxLabel;
exports.ComboboxList = ComboboxList;
exports.ComboboxPositioner = ComboboxPositioner;
exports.ComboboxRoot = ComboboxRoot;
exports.ComboboxRootProvider = ComboboxRootProvider;
exports.ComboboxTrigger = ComboboxTrigger;
exports.DatePicker = datePicker;
exports.DatePickerClearTrigger = DatePickerClearTrigger;
exports.DatePickerContent = DatePickerContent;
exports.DatePickerContext = DatePickerContext;
exports.DatePickerControl = DatePickerControl;
exports.DatePickerInput = DatePickerInput;
exports.DatePickerLabel = DatePickerLabel;
exports.DatePickerMonthSelect = DatePickerMonthSelect;
exports.DatePickerNextTrigger = DatePickerNextTrigger;
exports.DatePickerPositioner = DatePickerPositioner;
exports.DatePickerPresetTrigger = DatePickerPresetTrigger;
exports.DatePickerPrevTrigger = DatePickerPrevTrigger;
exports.DatePickerRangeText = DatePickerRangeText;
exports.DatePickerRoot = DatePickerRoot;
exports.DatePickerRootProvider = DatePickerRootProvider;
exports.DatePickerTable = DatePickerTable;
exports.DatePickerTableBody = DatePickerTableBody;
exports.DatePickerTableCell = DatePickerTableCell;
exports.DatePickerTableCellTrigger = DatePickerTableCellTrigger;
exports.DatePickerTableHead = DatePickerTableHead;
exports.DatePickerTableHeader = DatePickerTableHeader;
exports.DatePickerTableRow = DatePickerTableRow;
exports.DatePickerTrigger = DatePickerTrigger;
exports.DatePickerView = DatePickerView;
exports.DatePickerViewControl = DatePickerViewControl;
exports.DatePickerViewTrigger = DatePickerViewTrigger;
exports.DatePickerYearSelect = DatePickerYearSelect;
exports.Dialog = dialog;
exports.DialogBackdrop = DialogBackdrop;
exports.DialogCloseTrigger = DialogCloseTrigger;
exports.DialogContent = DialogContent;
exports.DialogContext = DialogContext;
exports.DialogDescription = DialogDescription;
exports.DialogPositioner = DialogPositioner;
exports.DialogRoot = DialogRoot;
exports.DialogRootProvider = DialogRootProvider;
exports.DialogTitle = DialogTitle;
exports.DialogTrigger = DialogTrigger;
exports.Editable = editable;
exports.EditableArea = EditableArea;
exports.EditableCancelTrigger = EditableCancelTrigger;
exports.EditableContext = EditableContext;
exports.EditableControl = EditableControl;
exports.EditableEditTrigger = EditableEditTrigger;
exports.EditableInput = EditableInput;
exports.EditableLabel = EditableLabel;
exports.EditablePreview = EditablePreview;
exports.EditableRoot = EditableRoot;
exports.EditableRootProvider = EditableRootProvider;
exports.EditableSubmitTrigger = EditableSubmitTrigger;
exports.EnvironmentProvider = EnvironmentProvider;
exports.Field = field;
exports.FieldContext = FieldContext;
exports.FieldErrorText = FieldErrorText;
exports.FieldHelperText = FieldHelperText;
exports.FieldInput = FieldInput;
exports.FieldLabel = FieldLabel;
exports.FieldRoot = FieldRoot;
exports.FieldRootProvider = FieldRootProvider;
exports.FieldSelect = FieldSelect;
exports.FieldTextarea = FieldTextarea;
exports.Fieldset = fieldset;
exports.FieldsetContext = FieldsetContext;
exports.FieldsetErrorText = FieldsetErrorText;
exports.FieldsetHelperText = FieldsetHelperText;
exports.FieldsetLegend = FieldsetLegend;
exports.FieldsetRoot = FieldsetRoot;
exports.FieldsetRootProvider = FieldsetRootProvider;
exports.FileUpload = fileUpload;
exports.FileUploadContext = FileUploadContext;
exports.FileUploadDropzone = FileUploadDropzone;
exports.FileUploadHiddenInput = FileUploadHiddenInput;
exports.FileUploadItem = FileUploadItem;
exports.FileUploadItemDeleteTrigger = FileUploadItemDeleteTrigger;
exports.FileUploadItemGroup = FileUploadItemGroup;
exports.FileUploadItemName = FileUploadItemName;
exports.FileUploadItemPreview = FileUploadItemPreview;
exports.FileUploadItemPreviewImage = FileUploadItemPreviewImage;
exports.FileUploadItemSizeText = FileUploadItemSizeText;
exports.FileUploadLabel = FileUploadLabel;
exports.FileUploadRoot = FileUploadRoot;
exports.FileUploadRootProvider = FileUploadRootProvider;
exports.FileUploadTrigger = FileUploadTrigger;
exports.Format = format;
exports.FormatByte = FormatByte;
exports.FormatNumber = FormatNumber;
exports.Highlight = Highlight;
exports.HoverCard = hoverCard;
exports.HoverCardArrow = HoverCardArrow;
exports.HoverCardArrowTip = HoverCardArrowTip;
exports.HoverCardContent = HoverCardContent;
exports.HoverCardContext = HoverCardContext;
exports.HoverCardPositioner = HoverCardPositioner;
exports.HoverCardRoot = HoverCardRoot;
exports.HoverCardRootProvider = HoverCardRootProvider;
exports.HoverCardTrigger = HoverCardTrigger;
exports.LocaleProvider = LocaleProvider;
exports.Menu = menu;
exports.MenuArrow = MenuArrow;
exports.MenuArrowTip = MenuArrowTip;
exports.MenuCheckboxItem = MenuCheckboxItem;
exports.MenuContent = MenuContent;
exports.MenuContext = MenuContext;
exports.MenuContextTrigger = MenuContextTrigger;
exports.MenuIndicator = MenuIndicator;
exports.MenuItem = MenuItem;
exports.MenuItemContext = MenuItemContext;
exports.MenuItemGroup = MenuItemGroup;
exports.MenuItemGroupLabel = MenuItemGroupLabel;
exports.MenuItemIndicator = MenuItemIndicator;
exports.MenuItemText = MenuItemText;
exports.MenuPositioner = MenuPositioner;
exports.MenuRadioItem = MenuRadioItem;
exports.MenuRadioItemGroup = MenuRadioItemGroup;
exports.MenuRoot = MenuRoot;
exports.MenuRootProvider = MenuRootProvider;
exports.MenuSeparator = MenuSeparator;
exports.MenuTrigger = MenuTrigger;
exports.MenuTriggerItem = MenuTriggerItem;
exports.NumberInput = numberInput;
exports.NumberInputContext = NumberInputContext;
exports.NumberInputControl = NumberInputControl;
exports.NumberInputDecrementTrigger = NumberInputDecrementTrigger;
exports.NumberInputIncrementTrigger = NumberInputIncrementTrigger;
exports.NumberInputInput = NumberInputInput;
exports.NumberInputLabel = NumberInputLabel;
exports.NumberInputRoot = NumberInputRoot;
exports.NumberInputRootProvider = NumberInputRootProvider;
exports.NumberInputScrubber = NumberInputScrubber;
exports.NumberInputValueText = NumberInputValueText;
exports.Pagination = pagination;
exports.PaginationContext = PaginationContext;
exports.PaginationEllipsis = PaginationEllipsis;
exports.PaginationItem = PaginationItem;
exports.PaginationNextTrigger = PaginationNextTrigger;
exports.PaginationPrevTrigger = PaginationPrevTrigger;
exports.PaginationRoot = PaginationRoot;
exports.PaginationRootProvider = PaginationRootProvider;
exports.PinInput = pinInput;
exports.PinInputContext = PinInputContext;
exports.PinInputControl = PinInputControl;
exports.PinInputHiddenInput = PinInputHiddenInput;
exports.PinInputInput = PinInputInput;
exports.PinInputLabel = PinInputLabel;
exports.PinInputRoot = PinInputRoot;
exports.PinInputRootProvider = PinInputRootProvider;
exports.Popover = popover;
exports.PopoverAnchor = PopoverAnchor;
exports.PopoverArrow = PopoverArrow;
exports.PopoverArrowTip = PopoverArrowTip;
exports.PopoverCloseTrigger = PopoverCloseTrigger;
exports.PopoverContent = PopoverContent;
exports.PopoverContext = PopoverContext;
exports.PopoverDescription = PopoverDescription;
exports.PopoverIndicator = PopoverIndicator;
exports.PopoverPositioner = PopoverPositioner;
exports.PopoverRoot = PopoverRoot;
exports.PopoverRootProvider = PopoverRootProvider;
exports.PopoverTitle = PopoverTitle;
exports.PopoverTrigger = PopoverTrigger;
exports.Presence = Presence;
exports.PresenceProvider = PresenceProvider;
exports.Progress = progress;
exports.ProgressCircle = ProgressCircle;
exports.ProgressCircleRange = ProgressCircleRange;
exports.ProgressCircleTrack = ProgressCircleTrack;
exports.ProgressContext = ProgressContext;
exports.ProgressLabel = ProgressLabel;
exports.ProgressRange = ProgressRange;
exports.ProgressRoot = ProgressRoot;
exports.ProgressRootProvider = ProgressRootProvider;
exports.ProgressTrack = ProgressTrack;
exports.ProgressValueText = ProgressValueText;
exports.ProgressView = ProgressView;
exports.QrCode = qrCode;
exports.QrCodeContext = QrCodeContext;
exports.QrCodeFrame = QrCodeFrame;
exports.QrCodeOverlay = QrCodeOverlay;
exports.QrCodePattern = QrCodePattern;
exports.QrCodeRoot = QrCodeRoot;
exports.QrCodeRootProvider = QrCodeRootProvider;
exports.RadioGroup = radioGroup;
exports.RadioGroupContext = RadioGroupContext;
exports.RadioGroupIndicator = RadioGroupIndicator;
exports.RadioGroupItem = RadioGroupItem;
exports.RadioGroupItemContext = RadioGroupItemContext;
exports.RadioGroupItemControl = RadioGroupItemControl;
exports.RadioGroupItemHiddenInput = RadioGroupItemHiddenInput;
exports.RadioGroupItemText = RadioGroupItemText;
exports.RadioGroupLabel = RadioGroupLabel;
exports.RadioGroupRoot = RadioGroupRoot;
exports.RadioGroupRootProvider = RadioGroupRootProvider;
exports.RatingGroup = ratingGroup;
exports.RatingGroupContext = RatingGroupContext;
exports.RatingGroupControl = RatingGroupControl;
exports.RatingGroupHiddenInput = RatingGroupHiddenInput;
exports.RatingGroupItem = RatingGroupItem;
exports.RatingGroupItemContext = RatingGroupItemContext;
exports.RatingGroupLabel = RatingGroupLabel;
exports.RatingGroupRoot = RatingGroupRoot;
exports.RatingGroupRootProvider = RatingGroupRootProvider;
exports.SegmentGroup = segmentGroup;
exports.SegmentGroupContext = SegmentGroupContext;
exports.SegmentGroupIndicator = SegmentGroupIndicator;
exports.SegmentGroupItem = SegmentGroupItem;
exports.SegmentGroupItemContext = SegmentGroupItemContext;
exports.SegmentGroupItemControl = SegmentGroupItemControl;
exports.SegmentGroupItemHiddenInput = SegmentGroupItemHiddenInput;
exports.SegmentGroupItemText = SegmentGroupItemText;
exports.SegmentGroupLabel = SegmentGroupLabel;
exports.SegmentGroupRoot = SegmentGroupRoot;
exports.SegmentGroupRootProvider = SegmentGroupRootProvider;
exports.Select = select;
exports.SelectClearTrigger = SelectClearTrigger;
exports.SelectContent = SelectContent;
exports.SelectContext = SelectContext;
exports.SelectControl = SelectControl;
exports.SelectHiddenSelect = SelectHiddenSelect;
exports.SelectIndicator = SelectIndicator;
exports.SelectItem = SelectItem;
exports.SelectItemContext = SelectItemContext;
exports.SelectItemGroup = SelectItemGroup;
exports.SelectItemGroupLabel = SelectItemGroupLabel;
exports.SelectItemIndicator = SelectItemIndicator;
exports.SelectItemText = SelectItemText;
exports.SelectLabel = SelectLabel;
exports.SelectList = SelectList;
exports.SelectPositioner = SelectPositioner;
exports.SelectRoot = SelectRoot;
exports.SelectRootProvider = SelectRootProvider;
exports.SelectTrigger = SelectTrigger;
exports.SelectValueText = SelectValueText;
exports.SignaturePad = signaturePad;
exports.SignaturePadClearTrigger = SignaturePadClearTrigger;
exports.SignaturePadContext = SignaturePadContext;
exports.SignaturePadControl = SignaturePadControl;
exports.SignaturePadGuide = SignaturePadGuide;
exports.SignaturePadHiddenInput = SignaturePadHiddenInput;
exports.SignaturePadLabel = SignaturePadLabel;
exports.SignaturePadRoot = SignaturePadRoot;
exports.SignaturePadRootProvider = SignaturePadRootProvider;
exports.SignaturePadSegment = SignaturePadSegment;
exports.Slider = slider;
exports.SliderContext = SliderContext;
exports.SliderControl = SliderControl;
exports.SliderHiddenInput = SliderHiddenInput;
exports.SliderLabel = SliderLabel;
exports.SliderMarker = SliderMarker;
exports.SliderMarkerGroup = SliderMarkerGroup;
exports.SliderRange = SliderRange;
exports.SliderRoot = SliderRoot;
exports.SliderRootProvider = SliderRootProvider;
exports.SliderThumb = SliderThumb;
exports.SliderTrack = SliderTrack;
exports.SliderValueText = SliderValueText;
exports.Splitter = splitter;
exports.SplitterContext = SplitterContext;
exports.SplitterPanel = SplitterPanel;
exports.SplitterResizeTrigger = SplitterResizeTrigger;
exports.SplitterRoot = SplitterRoot;
exports.SplitterRootProvider = SplitterRootProvider;
exports.Steps = steps;
exports.StepsCompletedContent = StepsCompletedContent;
exports.StepsContent = StepsContent;
exports.StepsContext = StepsContext;
exports.StepsIndicator = StepsIndicator;
exports.StepsItem = StepsItem;
exports.StepsItemContext = StepsItemContext;
exports.StepsList = StepsList;
exports.StepsNextTrigger = StepsNextTrigger;
exports.StepsPrevTrigger = StepsPrevTrigger;
exports.StepsProgress = StepsProgress;
exports.StepsRoot = StepsRoot;
exports.StepsRootProvider = StepsRootProvider;
exports.StepsSeparator = StepsSeparator;
exports.StepsTrigger = StepsTrigger;
exports.Switch = _switch;
exports.SwitchContext = SwitchContext;
exports.SwitchControl = SwitchControl;
exports.SwitchHiddenInput = SwitchHiddenInput;
exports.SwitchLabel = SwitchLabel;
exports.SwitchRoot = SwitchRoot;
exports.SwitchRootProvider = SwitchRootProvider;
exports.SwitchThumb = SwitchThumb;
exports.TabContent = TabContent;
exports.TabIndicator = TabIndicator;
exports.TabList = TabList;
exports.TabTrigger = TabTrigger;
exports.Tabs = tabs;
exports.TabsContext = TabsContext;
exports.TabsRoot = TabsRoot;
exports.TabsRootProvider = TabsRootProvider;
exports.TagsInput = tagsInput;
exports.TagsInputClearTrigger = TagsInputClearTrigger;
exports.TagsInputContext = TagsInputContext;
exports.TagsInputControl = TagsInputControl;
exports.TagsInputHiddenInput = TagsInputHiddenInput;
exports.TagsInputInput = TagsInputInput;
exports.TagsInputItem = TagsInputItem;
exports.TagsInputItemContext = TagsInputItemContext;
exports.TagsInputItemDeleteTrigger = TagsInputItemDeleteTrigger;
exports.TagsInputItemInput = TagsInputItemInput;
exports.TagsInputItemPreview = TagsInputItemPreview;
exports.TagsInputItemText = TagsInputItemText;
exports.TagsInputLabel = TagsInputLabel;
exports.TagsInputRoot = TagsInputRoot;
exports.TagsInputRootProvider = TagsInputRootProvider;
exports.TimePicker = timePicker;
exports.TimePickerCell = TimePickerCell;
exports.TimePickerClearTrigger = TimePickerClearTrigger;
exports.TimePickerColumn = TimePickerColumn;
exports.TimePickerContent = TimePickerContent;
exports.TimePickerContext = TimePickerContext;
exports.TimePickerControl = TimePickerControl;
exports.TimePickerInput = TimePickerInput;
exports.TimePickerLabel = TimePickerLabel;
exports.TimePickerPositioner = TimePickerPositioner;
exports.TimePickerRoot = TimePickerRoot;
exports.TimePickerRootProvider = TimePickerRootProvider;
exports.TimePickerSpacer = TimePickerSpacer;
exports.TimePickerTrigger = TimePickerTrigger;
exports.Timer = timer;
exports.TimerActionTrigger = TimerActionTrigger;
exports.TimerContext = TimerContext;
exports.TimerItem = TimerItem;
exports.TimerRoot = TimerRoot;
exports.TimerRootProvider = TimerRootProvider;
exports.TimerSeparator = TimerSeparator;
exports.Toast = toast;
exports.ToastActionTrigger = ToastActionTrigger;
exports.ToastCloseTrigger = ToastCloseTrigger;
exports.ToastContext = ToastContext;
exports.ToastDescription = ToastDescription;
exports.ToastRoot = ToastRoot;
exports.ToastTitle = ToastTitle;
exports.Toaster = Toaster;
exports.ToggleGroup = toggleGroup;
exports.ToggleGroupContext = ToggleGroupContext;
exports.ToggleGroupItem = ToggleGroupItem;
exports.ToggleGroupRoot = ToggleGroupRoot;
exports.ToggleGroupRootProvider = ToggleGroupRootProvider;
exports.Tooltip = tooltip;
exports.TooltipArrow = TooltipArrow;
exports.TooltipArrowTip = TooltipArrowTip;
exports.TooltipContent = TooltipContent;
exports.TooltipContext = TooltipContext;
exports.TooltipPositioner = TooltipPositioner;
exports.TooltipRoot = TooltipRoot;
exports.TooltipRootProvider = TooltipRootProvider;
exports.TooltipTrigger = TooltipTrigger;
exports.TreeView = treeView;
exports.TreeViewBranch = TreeViewBranch;
exports.TreeViewBranchContent = TreeViewBranchContent;
exports.TreeViewBranchControl = TreeViewBranchControl;
exports.TreeViewBranchIndicator = TreeViewBranchIndicator;
exports.TreeViewBranchText = TreeViewBranchText;
exports.TreeViewBranchTrigger = TreeViewBranchTrigger;
exports.TreeViewContext = TreeViewContext;
exports.TreeViewItem = TreeViewItem;
exports.TreeViewItemContext = TreeViewItemContext;
exports.TreeViewItemIndicator = TreeViewItemIndicator;
exports.TreeViewItemText = TreeViewItemText;
exports.TreeViewLabel = TreeViewLabel;
exports.TreeViewRoot = TreeViewRoot;
exports.TreeViewRootProvider = TreeViewRootProvider;
exports.TreeViewTree = TreeViewTree;
exports.ark = ark;
exports.carouselAnatomy = carouselAnatomy;
exports.checkboxAnatomy = checkboxAnatomy;
exports.colorPickerAnatomy = colorPickerAnatomy;
exports.createToaster = createToaster;
exports.datePickerAnatomy = datePickerAnatomy;
exports.fieldAnatomy = fieldAnatomy;
exports.fieldsetAnatomy = fieldsetAnatomy;
exports.segmentGroupAnatomy = segmentGroupAnatomy;
exports.splitPresenceProps = splitPresenceProps;
exports.useAccordion = useAccordion;
exports.useAccordionContext = useAccordionContext;
exports.useAccordionItemContext = useAccordionItemContext;
exports.useAvatar = useAvatar;
exports.useAvatarContext = useAvatarContext;
exports.useCarousel = useCarousel;
exports.useCarouselContext = useCarouselContext;
exports.useCheckbox = useCheckbox;
exports.useCheckboxContext = useCheckboxContext;
exports.useCheckboxGroup = useCheckboxGroup;
exports.useCheckboxGroupContext = useCheckboxGroupContext;
exports.useClipboard = useClipboard;
exports.useClipboardContext = useClipboardContext;
exports.useCollapsible = useCollapsible;
exports.useCollapsibleContext = useCollapsibleContext;
exports.useColorPicker = useColorPicker;
exports.useColorPickerContext = useColorPickerContext;
exports.useCombobox = useCombobox;
exports.useComboboxContext = useComboboxContext;
exports.useComboboxItemContext = useComboboxItemContext;
exports.useDatePicker = useDatePicker;
exports.useDatePickerContext = useDatePickerContext;
exports.useDialog = useDialog;
exports.useDialogContext = useDialogContext;
exports.useEditable = useEditable;
exports.useEditableContext = useEditableContext;
exports.useEnvironmentContext = useEnvironmentContext;
exports.useFieldContext = useFieldContext;
exports.useFieldsetContext = useFieldsetContext;
exports.useFileUpload = useFileUpload;
exports.useFileUploadContext = useFileUploadContext;
exports.useHighlight = useHighlight;
exports.useHoverCard = useHoverCard;
exports.useHoverCardContext = useHoverCardContext;
exports.useLocaleContext = useLocaleContext;
exports.useMenu = useMenu;
exports.useMenuContext = useMenuContext;
exports.useMenuItemContext = useMenuItemContext;
exports.useNumberInput = useNumberInput;
exports.useNumberInputContext = useNumberInputContext;
exports.usePagination = usePagination;
exports.usePaginationContext = usePaginationContext;
exports.usePinInput = usePinInput;
exports.usePinInputContext = usePinInputContext;
exports.usePopover = usePopover;
exports.usePopoverContext = usePopoverContext;
exports.usePresence = usePresence;
exports.usePresenceContext = usePresenceContext;
exports.useProgress = useProgress;
exports.useProgressContext = useProgressContext;
exports.useQrCode = useQrCode;
exports.useQrCodeContext = useQrCodeContext;
exports.useRadioGroup = useRadioGroup;
exports.useRadioGroupContext = useRadioGroupContext;
exports.useRadioGroupItemContext = useRadioGroupItemContext;
exports.useRatingGroup = useRatingGroup;
exports.useRatingGroupContext = useRatingGroupContext;
exports.useRatingGroupItemContext = useRatingGroupItemContext;
exports.useSegmentGroup = useSegmentGroup;
exports.useSegmentGroupContext = useSegmentGroupContext;
exports.useSegmentGroupItemContext = useSegmentGroupItemContext;
exports.useSelect = useSelect;
exports.useSelectContext = useSelectContext;
exports.useSelectItemContext = useSelectItemContext;
exports.useSignaturePad = useSignaturePad;
exports.useSignaturePadContext = useSignaturePadContext;
exports.useSlider = useSlider;
exports.useSliderContext = useSliderContext;
exports.useSplitter = useSplitter;
exports.useSplitterContext = useSplitterContext;
exports.useSteps = useSteps;
exports.useStepsContext = useStepsContext;
exports.useStepsItemContext = useStepsItemContext;
exports.useSwitch = useSwitch;
exports.useSwitchContext = useSwitchContext;
exports.useTabs = useTabs;
exports.useTabsContext = useTabsContext;
exports.useTagsInput = useTagsInput;
exports.useTagsInputContext = useTagsInputContext;
exports.useTagsInputItemContext = useTagsInputItemContext;
exports.useTimePicker = useTimePicker;
exports.useTimePickerContext = useTimePickerContext;
exports.useTimer = useTimer;
exports.useTimerContext = useTimerContext;
exports.useToastContext = useToastContext;
exports.useToggleGroup = useToggleGroup;
exports.useToggleGroupContext = useToggleGroupContext;
exports.useTooltip = useTooltip;
exports.useTooltipContext = useTooltipContext;
exports.useTreeView = useTreeView;
exports.useTreeViewContext = useTreeViewContext;
exports.useTreeViewItemContext = useTreeViewItemContext;
//# sourceMappingURL=index.js.map
