'use strict';

var solidJs = require('solid-js');
var web = require('solid-js/web');
var scheduled = require('@solid-primitives/scheduled');
var utils = require('@solid-primitives/utils');

// src/index.ts
var callbackWith = (fn, v) => fn.length > 0 ? () => fn(solidJs.untrack(v)) : fn;
function createPureReaction(onInvalidate, options) {
  if (web.isServer) {
    return () => void 0;
  }
  const owner = solidJs.getOwner();
  const disposers = /* @__PURE__ */ new Set();
  let trackers = 0;
  let disposed = false;
  solidJs.onCleanup(() => {
    for (const fn of disposers)
      fn();
    disposers.clear();
    disposed = true;
  });
  return (tracking) => {
    if (disposed) {
      solidJs.untrack(tracking);
      return;
    }
    trackers++;
    solidJs.createRoot((dispose) => {
      disposers.add(dispose);
      let init = true;
      solidJs.createComputed(() => {
        if (init) {
          init = false;
          return tracking();
        }
        if (--trackers === 0)
          solidJs.untrack(onInvalidate);
        dispose();
        disposers.delete(dispose);
      }, options);
    }, owner);
  };
}
function createLatest(sources, options) {
  let index = 0;
  const memos = sources.map(
    (source, i) => solidJs.createMemo(
      () => (index = i, source()),
      void 0,
      solidJs.DEV ? { name: i + 1 + ". source", equals: false } : utils.EQUALS_FALSE_OPTIONS
    )
  );
  return solidJs.createMemo(() => memos.map((m) => m())[index], void 0, options);
}
function createLatestMany(sources, options) {
  const memos = sources.map((source, i) => {
    const obj = { dirty: true, get: null };
    obj.get = solidJs.createMemo(
      () => (obj.dirty = true, source()),
      void 0,
      solidJs.DEV ? { name: i + 1 + ". source", equals: false } : utils.EQUALS_FALSE_OPTIONS
    );
    return obj;
  });
  return createLazyMemo(
    () => memos.reduce((acc, memo) => {
      const v = memo.get();
      if (memo.dirty) {
        memo.dirty = false;
        acc.push(v);
      }
      return acc;
    }, []),
    void 0,
    options
  );
}
function createWritableMemo(fn, value, options) {
  let combined = () => value;
  const [signal, setSignal] = solidJs.createSignal(value, utils.EQUALS_FALSE_OPTIONS), memo = solidJs.createMemo(
    callbackWith(fn, () => combined()),
    value
  );
  return [
    combined = createLatest([signal, memo], options),
    (setter) => setSignal(
      () => typeof setter === "function" ? setter(solidJs.untrack(combined)) : setter
    )
  ];
}
function createDebouncedMemo(fn, timeoutMs, value, options) {
  const memo = solidJs.createMemo(() => fn(value), void 0, options);
  if (web.isServer) {
    return memo;
  }
  const [signal, setSignal] = solidJs.createSignal(solidJs.untrack(memo));
  const updateSignal = scheduled.debounce(() => value = setSignal(memo), timeoutMs);
  solidJs.createComputed(solidJs.on(memo, updateSignal, { defer: true }));
  return signal;
}
function createDebouncedMemoOn(deps, fn, timeoutMs, value, options) {
  if (web.isServer) {
    return solidJs.createMemo(solidJs.on(deps, fn), value);
  }
  let init = true;
  const [signal, setSignal] = solidJs.createSignal(
    (() => {
      let v;
      solidJs.createComputed(
        solidJs.on(deps, (input, prevInput) => {
          if (init) {
            v = fn(input, prevInput, value);
            init = false;
          } else
            updateSignal(input, prevInput);
        })
      );
      return v;
    })(),
    options
  );
  const updateSignal = scheduled.debounce((input, prevInput) => {
    setSignal(() => fn(input, prevInput, signal()));
  }, timeoutMs);
  return signal;
}
function createThrottledMemo(fn, timeoutMs, value, options) {
  if (web.isServer) {
    return solidJs.createMemo(fn);
  }
  let onInvalidate = utils.noop;
  const track = createPureReaction(() => onInvalidate());
  const [state, setState] = solidJs.createSignal(
    (() => {
      let v;
      track(() => v = fn(value));
      return v;
    })(),
    options
  );
  onInvalidate = scheduled.throttle(() => track(() => setState(fn)), timeoutMs);
  return state;
}
function createAsyncMemo(calc, options = {}) {
  if (web.isServer) {
    return () => options.value;
  }
  const [state, setState] = solidJs.createSignal(options.value, options);
  const order = [];
  solidJs.createComputed(async () => {
    const value = calc(solidJs.untrack(state));
    if (value instanceof Promise) {
      order.push(value);
      value.then((r) => order.includes(value) && setState(() => r));
      value.finally(() => {
        const index = order.indexOf(value);
        order.splice(0, index + 1);
      });
    } else
      setState(() => value);
  }, void 0, options);
  return state;
}
function createLazyMemo(calc, value, options) {
  if (web.isServer) {
    let calculated = false;
    return () => {
      if (!calculated) {
        calculated = true;
        value = calc(value);
      }
      return value;
    };
  }
  let isReading = false, isStale = true;
  const [track, trigger] = solidJs.createSignal(void 0, utils.EQUALS_FALSE_OPTIONS), memo = solidJs.createMemo(
    (p) => isReading ? calc(p) : (isStale = !track(), p),
    value,
    solidJs.DEV ? { name: options?.name, equals: false } : utils.EQUALS_FALSE_OPTIONS
  );
  return () => {
    isReading = true;
    if (isStale)
      isStale = trigger();
    const v = memo();
    isReading = false;
    return v;
  };
}
function createMemoCache(...args) {
  const cache = /* @__PURE__ */ new Map();
  const owner = solidJs.getOwner();
  const key = typeof args[1] === "function" ? args[0] : void 0, calc = typeof args[1] === "function" ? args[1] : args[0], options = typeof args[1] === "object" ? args[1] : typeof args[2] === "object" ? args[2] : {};
  const run = (key2) => {
    if (cache.has(key2))
      return cache.get(key2)();
    const memo = solidJs.runWithOwner(
      owner,
      () => createLazyMemo((prev) => calc(key2, prev), void 0, options)
    );
    if (options.size === void 0 || cache.size < options.size)
      cache.set(key2, memo);
    return memo();
  };
  return key ? () => run(key()) : run;
}
function createReducer(dispatcher, initialValue, options) {
  const [state, setState] = solidJs.createSignal(initialValue, options);
  return [state, (...args) => void setState((state2) => dispatcher(state2, ...args))];
}

exports.createAsyncMemo = createAsyncMemo;
exports.createDebouncedMemo = createDebouncedMemo;
exports.createDebouncedMemoOn = createDebouncedMemoOn;
exports.createLatest = createLatest;
exports.createLatestMany = createLatestMany;
exports.createLazyMemo = createLazyMemo;
exports.createMemoCache = createMemoCache;
exports.createPureReaction = createPureReaction;
exports.createReducer = createReducer;
exports.createThrottledMemo = createThrottledMemo;
exports.createWritableMemo = createWritableMemo;
