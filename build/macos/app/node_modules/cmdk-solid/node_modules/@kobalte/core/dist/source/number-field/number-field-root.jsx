import { access, createGenerateId, mergeDefaultProps, mergeRefs, } from "@kobalte/utils";
import { batch, createEffect, createMemo, createSignal, createUniqueId, on, splitProps, } from "solid-js";
import { NumberFormatter, NumberParser } from "@internationalized/number";
import { FORM_CONTROL_PROP_NAMES, FormControlContext, createFormControl, } from "../form-control";
import { useLocale } from "../i18n";
import { Polymorphic } from "../polymorphic";
import { createControllableSignal, createFormResetListener, } from "../primitives";
import { NumberFieldContext, } from "./number-field-context";
/**
 * A text input that allow users to input custom text entries with a keyboard.
 */
export function NumberFieldRoot(props) {
    let ref;
    const defaultId = `NumberField-${createUniqueId()}`;
    const mergedProps = mergeDefaultProps({
        id: defaultId,
        format: true,
        minValue: Number.MIN_SAFE_INTEGER,
        maxValue: Number.MAX_SAFE_INTEGER,
        step: 1,
        changeOnWheel: true,
    }, props);
    const [local, formControlProps, others] = splitProps(mergedProps, [
        "ref",
        "value",
        "defaultValue",
        "onChange",
        "rawValue",
        "onRawValueChange",
        "translations",
        "format",
        "formatOptions",
        "textValue",
        "minValue",
        "maxValue",
        "step",
        "largeStep",
        "changeOnWheel",
        "translations",
        "allowedInput",
    ], FORM_CONTROL_PROP_NAMES);
    const { locale } = useLocale();
    const numberParser = createMemo(() => {
        return new NumberParser(locale(), local.formatOptions);
    });
    const numberFormatter = createMemo(() => {
        return new NumberFormatter(locale(), local.formatOptions);
    });
    const allNumberFormatParts = createMemo(() => [
        ...numberFormatter().formatToParts(-1234567890.1),
        ...numberFormatter().formatToParts(1),
    ]);
    const uniquePartTypes = [
        "decimal",
        "minusSign",
        "plusSign",
    ];
    const commonPartTypes = [
        "integer",
        "group",
        "percentSign",
    ];
    const uniqueCharacters = () => new Set(allNumberFormatParts()
        .filter((part) => uniquePartTypes.includes(part.type))
        .map((part) => part.value)
        .join("")
        .split(""));
    const commonCharacters = () => new Set(allNumberFormatParts()
        .filter((part) => commonPartTypes.includes(part.type))
        .map((part) => part.value)
        .join("")
        .split(""));
    const parseRawValue = (value) => local.format && typeof value !== "number"
        ? numberParser().parse(value ?? "")
        : Number(value ?? "");
    const [value, setValue] = createControllableSignal({
        value: () => local.value,
        defaultValue: () => local.defaultValue ?? local.rawValue,
        onChange: (value) => {
            local.onChange?.(typeof value === "number" ? numberFormatter().format(value) : value);
            local.onRawValueChange?.(parseRawValue(value));
        },
    });
    local.onRawValueChange?.(parseRawValue(value()));
    function isAllowedInput(char) {
        if (local.allowedInput !== undefined)
            return local.allowedInput.test(char);
        if (commonCharacters().has(char))
            return true;
        if (uniqueCharacters().has(char)) {
            let val = value() ?? "";
            if (typeof val === "number")
                val = numberFormatter().format(val);
            return !val.split("").includes(char);
        }
        return false;
    }
    const { formControlContext } = createFormControl(formControlProps);
    createFormResetListener(() => ref, () => {
        setValue(local.defaultValue ?? "");
    });
    const [inputRef, setInputRef] = createSignal();
    const [hiddenInputRef, setHiddenInputRef] = createSignal();
    const onInput = (e) => {
        if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
            return;
        }
        const target = e.target;
        if (e.inputType !== "insertText" || isAllowedInput(e.data || "")) {
            setValue(target.value);
        }
        // Unlike in React, inputs `value` can be out of sync with our value state.
        // even if an input is controlled (ex: `<input value="foo" />`,
        // typing on the input will change its internal `value`.
        //
        // To prevent this, we need to force the input `value` to be in sync with the text field value state.
        target.value = String(value() ?? "");
    };
    const context = {
        value,
        setValue,
        rawValue: () => parseRawValue(value()),
        generateId: createGenerateId(() => access(formControlProps.id)),
        formatNumber: (number) => numberFormatter().format(number),
        format: () => {
            if (!local.format)
                return;
            let rawValue = context.rawValue();
            if (Number.isNaN(rawValue)) {
                if (hiddenInputRef())
                    hiddenInputRef().value = "";
                local.onRawValueChange?.(rawValue);
                return;
            }
            if (context.minValue())
                rawValue = Math.max(rawValue, context.minValue());
            if (context.maxValue())
                rawValue = Math.min(rawValue, context.maxValue());
            const formattedValue = context.formatNumber(rawValue);
            // biome-ignore lint/suspicious/noDoubleEquals: loose comparison
            if (value() != formattedValue)
                setValue(formattedValue);
            if (inputRef())
                inputRef().value = formattedValue;
            if (hiddenInputRef())
                hiddenInputRef().value = String(rawValue);
        },
        onInput,
        textValue: () => local.textValue,
        minValue: () => local.minValue,
        maxValue: () => local.maxValue,
        step: () => local.step,
        largeStep: () => local.largeStep ?? local.step * 10,
        changeOnWheel: () => local.changeOnWheel,
        translations: () => local.translations,
        inputRef,
        setInputRef,
        hiddenInputRef,
        setHiddenInputRef,
        varyValue: (offset) => {
            let rawValue = context.rawValue() ?? 0;
            if (Number.isNaN(rawValue))
                rawValue = 0;
            batch(() => {
                const decimals = Math.max(local.formatOptions?.minimumFractionDigits ?? 0, local.formatOptions?.maximumFractionDigits ?? 3);
                const newValue = Number.parseFloat((rawValue + offset).toFixed(decimals));
                context.setValue(newValue);
                context.format();
            });
        },
    };
    createEffect(on(() => local.rawValue, (rawValue) => {
        if (rawValue !== context.rawValue()) {
            if (Number.isNaN(rawValue))
                return;
            batch(() => {
                setValue(rawValue ?? "");
                context.format();
            });
        }
    }, { defer: true }));
    return (<FormControlContext.Provider value={formControlContext}>
			<NumberFieldContext.Provider value={context}>
				<Polymorphic as="div" ref={mergeRefs((el) => (ref = el), local.ref)} role="group" id={access(formControlProps.id)} {...formControlContext.dataset()} {...others}/>
			</NumberFieldContext.Provider>
		</FormControlContext.Provider>);
}
