import {
  commandScore
} from "./chunk/5WIGIOAJ.jsx";

// src/index.tsx
import { Dialog as KobalteDialog } from "@kobalte/core";
import { mergeDefaultProps, mergeRefs } from "@kobalte/utils";
import { trackDeep } from "@solid-primitives/deep";
import {
  Show,
  createContext,
  createEffect,
  createMemo,
  createSignal,
  createUniqueId,
  onCleanup,
  onMount,
  splitProps,
  useContext
} from "solid-js";
import { createStore } from "solid-js/store";
var GROUP_SELECTOR = `[cmdk-group=""]`;
var GROUP_HEADING_SELECTOR = `[cmdk-group-heading=""]`;
var ITEM_SELECTOR = `[cmdk-item=""]`;
var VALID_ITEM_SELECTOR = `${ITEM_SELECTOR}:not([aria-disabled="true"])`;
var SELECT_EVENT = `cmdk-item-select`;
var VALUE_ATTR = `data-value`;
var defaultFilter = (value, search, keywords) => commandScore(value, search, keywords);
var CommandContext = createContext(void 0);
var useCommand = () => useContext(CommandContext);
var StoreContext = createContext(void 0);
var useStore = () => useContext(StoreContext);
var GroupContext = createContext(void 0);
var Command = (props) => {
  const [state, setState] = createStore({
    search: "",
    value: props.value ?? props.defaultValue ?? "",
    filtered: { count: 0, items: {}, groups: [] },
    items: [],
    groups: {},
    ids: {}
  });
  createEffect(() => {
    trackDeep(state.ids);
    const skipFiltering = !state.search || props.shouldFilter === false;
    const items = state.items.reduce(
      (acc, id) => {
        acc[id] = skipFiltering ? 1 : score(state.ids[id].value, state.ids[id].keywords);
        return acc;
      },
      {}
    );
    const groups = Object.keys(state.groups).filter((groupId) => {
      return state.groups[groupId].some((id) => (items[id] || 0) > 0);
    });
    const count = Object.values(items).filter((score2) => score2 > 0).length;
    setState("filtered", { count, items, groups });
  });
  const mergedProps = mergeDefaultProps({ vimBindings: true, disablePointerSelection: false }, props);
  const [localProps, etc] = splitProps(mergedProps, [
    "label",
    "children",
    "value",
    "onValueChange",
    "filter",
    "shouldFilter",
    "loop",
    "disablePointerSelection",
    "vimBindings"
  ]);
  const listId = createUniqueId();
  const labelId = createUniqueId();
  const inputId = createUniqueId();
  const [listInnerRef, setListInnerRef] = createSignal(null);
  const schedule = useScheduleLayoutEffect();
  createEffect(() => {
    if (localProps.value !== void 0) {
      const v = localProps.value.trim();
      if (v != state.value) {
        setState("value", v);
      }
    }
  });
  onMount(() => {
    schedule(6, scrollSelectedIntoView);
  });
  const store = {
    state,
    snapshot: () => trackDeep(state),
    setState: (key, value, opts) => {
      if (Object.is(state[key], value))
        return;
      setState(key, value);
      if (key === "search") {
        schedule(8, selectFirstItem);
      } else if (key === "value") {
        if (!opts) {
          schedule(5, scrollSelectedIntoView);
        }
        if (props.value !== void 0) {
          const newValue = value ?? "";
          props.onValueChange?.(newValue);
          return;
        }
      }
    }
  };
  const context = {
    value: (id, value, keywords) => {
      setState("ids", (ids) => ({
        ...ids,
        [id]: { value, keywords }
      }));
    },
    // Track item lifecycle (mount, unmount)
    item: (id, groupId) => {
      if (!listInnerRef()) {
        console.warn("Mount Command.Item inside a Command.List component.");
      }
      setState((state2) => {
        return {
          ...state2,
          items: Array.from(/* @__PURE__ */ new Set([...state2.items, id])),
          ...groupId && {
            groups: {
              ...state2.groups,
              [groupId]: [...state2.groups[groupId] || [], id]
            }
          }
        };
      });
      schedule(3, () => {
        if (!state.value) {
          selectFirstItem();
        }
      });
      onCleanup(() => {
        setState((state2) => ({
          ...state2,
          items: state2.items.filter((item) => item !== id),
          ...groupId && {
            groups: {
              ...state2.groups,
              [groupId]: state2.groups[groupId].filter((item) => item !== id)
            }
          },
          ids: Object.fromEntries(Object.entries(state2.ids).filter(([key]) => key !== id))
        }));
        const selectedItem = getSelectedItem();
        if (selectedItem?.getAttribute("id") === id)
          schedule(1, () => selectFirstItem());
      });
    },
    // Track group lifecycle (mount, unmount)
    group: (id) => {
      if (!listInnerRef()) {
        console.warn("Mount Command.Group inside a Command.List component.");
      }
      setState("groups", (state2) => {
        return {
          [id]: [],
          ...state2
        };
      });
      onCleanup(() => {
        setState((state2) => ({
          ...state2,
          groups: Object.fromEntries(Object.entries(state2.groups).filter(([key]) => key !== id)),
          ids: Object.fromEntries(Object.entries(state2.ids).filter(([key]) => key !== id))
        }));
      });
    },
    filter: () => {
      return props.shouldFilter !== false;
    },
    label: () => localProps.label || props["aria-label"] || "",
    disablePointerSelection: () => !!props.disablePointerSelection,
    listId,
    inputId,
    labelId,
    listInnerRef,
    setListInnerRef
  };
  function score(value, keywords) {
    const filter = localProps.filter ?? defaultFilter;
    return value ? filter(value, state.search, keywords) : 0;
  }
  function selectFirstItem() {
    const item = getValidItems().find((item2) => item2.getAttribute("aria-disabled") !== "true");
    const value = item?.getAttribute(VALUE_ATTR) || "";
    store.setState("value", value);
  }
  function scrollSelectedIntoView() {
    const item = getSelectedItem();
    if (item) {
      if (item.parentElement?.firstChild === item) {
        item.closest(GROUP_SELECTOR)?.querySelector(GROUP_HEADING_SELECTOR)?.scrollIntoView({ block: "nearest", inline: "start", behavior: "smooth" });
      }
      item.scrollIntoView({ block: "nearest", inline: "start", behavior: "smooth" });
    }
  }
  function getSelectedItem() {
    return listInnerRef()?.querySelector(`${ITEM_SELECTOR}[aria-selected="true"]`);
  }
  function getValidItems() {
    return Array.from(listInnerRef()?.querySelectorAll(VALID_ITEM_SELECTOR) || []);
  }
  function updateSelectedToIndex(index) {
    const items = getValidItems();
    const item = items[index];
    if (item)
      store.setState("value", item.getAttribute(VALUE_ATTR) || "");
  }
  function updateSelectedByItem(change) {
    const selected = getSelectedItem();
    const items = getValidItems();
    const index = items.findIndex((item) => item === selected);
    let newSelected = items[index + change];
    if (props.loop) {
      newSelected = index + change < 0 ? items[items.length - 1] : index + change === items.length ? items[0] : items[index + change];
    }
    if (newSelected)
      store.setState("value", newSelected.getAttribute(VALUE_ATTR) || "");
  }
  function updateSelectedByGroup(change) {
    const selected = getSelectedItem();
    let group = selected?.closest(GROUP_SELECTOR);
    let item = null;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, GROUP_SELECTOR) : findPreviousSibling(group, GROUP_SELECTOR);
      item = group?.querySelector(VALID_ITEM_SELECTOR) || null;
    }
    if (item) {
      store.setState("value", item.getAttribute(VALUE_ATTR) || "");
    } else {
      updateSelectedByItem(change);
    }
  }
  const last = () => updateSelectedToIndex(getValidItems().length - 1);
  const next = (e) => {
    e.preventDefault();
    if (e.metaKey) {
      last();
    } else if (e.altKey) {
      updateSelectedByGroup(1);
    } else {
      updateSelectedByItem(1);
    }
  };
  const prev = (e) => {
    e.preventDefault();
    if (e.metaKey) {
      updateSelectedToIndex(0);
    } else if (e.altKey) {
      updateSelectedByGroup(-1);
    } else {
      updateSelectedByItem(-1);
    }
  };
  return <div
    tabIndex={-1}
    {...etc}
    cmdk-root=""
    onKeyDown={(e) => {
      etc.onKeyDown?.(e);
      if (!e.defaultPrevented) {
        switch (e.key) {
          case "n":
          case "j": {
            if (localProps.vimBindings && e.ctrlKey) {
              next(e);
            }
            break;
          }
          case "ArrowDown": {
            next(e);
            break;
          }
          case "p":
          case "k": {
            if (localProps.vimBindings && e.ctrlKey) {
              prev(e);
            }
            break;
          }
          case "ArrowUp": {
            prev(e);
            break;
          }
          case "Home": {
            e.preventDefault();
            updateSelectedToIndex(0);
            break;
          }
          case "End": {
            e.preventDefault();
            last();
            break;
          }
          case "Enter": {
            if (!e.isComposing && e.keyCode !== 229) {
              e.preventDefault();
              const item = getSelectedItem();
              if (item) {
                const event = new Event(SELECT_EVENT);
                item.dispatchEvent(event);
              }
            }
          }
        }
      }
    }}
  ><label
    cmdk-label=""
    for={context.inputId}
    id={context.labelId}
    style={srOnlyStyles}
  >{localProps.label}</label><StoreContext.Provider value={store}><CommandContext.Provider value={context}>{props.children}</CommandContext.Provider></StoreContext.Provider></div>;
};
var Item = (props) => {
  const store = useStore();
  const id = createUniqueId();
  const [ref, setRef] = createSignal();
  const groupContext = useContext(GroupContext);
  const context = useCommand();
  const [rendered, setRendered] = createSignal(false);
  onMount(() => {
    if (!forceMount()) {
      return context.item(id, groupContext?.().id);
    }
  });
  const [value, setValue] = createSignal(props.value || "");
  createEffect(() => {
    if (props.value) {
      setValue(props.value);
      return;
    }
    const innerValue = ref()?.textContent;
    if (innerValue) {
      setValue(innerValue);
      return;
    }
  });
  createEffect(() => {
    context.value(id, value(), props.keywords);
    ref()?.setAttribute(VALUE_ATTR, value());
  });
  const forceMount = () => props.forceMount ?? groupContext?.().forceMount;
  const selected = useCmdk((state) => value() && value() == state.value);
  const render = useCmdk(
    (state) => !rendered() ? true : forceMount() ? true : context.filter() === false ? true : !state.search ? true : (state.filtered.items[id] || 0) > 0
  );
  onMount(() => {
    const element = ref();
    if (!element || props.disabled)
      return;
    element.addEventListener(SELECT_EVENT, onSelect);
    onCleanup(() => element.removeEventListener(SELECT_EVENT, onSelect));
    setRendered(true);
  });
  function onSelect() {
    select();
    props.onSelect?.(value());
  }
  function select() {
    store.setState("value", value(), true);
  }
  const [localProps, etc] = splitProps(props, ["disabled", "onSelect", "value", "forceMount", "keywords"]);
  return <Show when={render()}><div
    {...etc}
    ref={(el) => setRef(el)}
    id={id}
    cmdk-item=""
    role="option"
    aria-disabled={Boolean(localProps.disabled)}
    aria-selected={Boolean(selected())}
    data-disabled={Boolean(localProps.disabled)}
    data-selected={Boolean(selected())}
    onPointerMove={localProps.disabled || context.disablePointerSelection() ? void 0 : select}
    onClick={localProps.disabled ? void 0 : onSelect}
  >{props.children}</div></Show>;
};
var Group = (props) => {
  const [localProps, etc] = splitProps(props, ["heading", "value", "forceMount"]);
  const id = createUniqueId();
  const [ref, setRef] = createSignal();
  const [headerRef, setHeaderRef] = createSignal();
  const headingId = createUniqueId();
  const context = useCommand();
  const render = useCmdk((state) => {
    return localProps.forceMount ? true : context.filter() === false ? true : !state.search ? true : state.filtered.groups.includes(id);
  });
  onMount(() => {
    context.group(id);
  });
  const [value, setValue] = createSignal(props.value || "");
  createEffect(() => {
    if (props.value) {
      setValue(props.value);
      return;
    }
    const innerValue = headerRef()?.textContent;
    if (innerValue) {
      setValue(innerValue);
      return;
    }
  });
  createEffect(() => {
    context.value(id, value());
    ref()?.setAttribute(VALUE_ATTR, value());
  });
  const contextValue = () => ({ id, forceMount: localProps.forceMount });
  return <div
    ref={mergeRefs((el) => setRef(el), props.ref)}
    {...etc}
    cmdk-group=""
    id={id}
    role="presentation"
    hidden={render() ? void 0 : true}
  ><Show when={props.heading}><div cmdk-group-heading="" ref={(el) => setHeaderRef(el)} aria-hidden id={headingId}>{props.heading}</div></Show><div cmdk-group-items="" role="group" aria-labelledby={props.heading ? headingId : void 0}><GroupContext.Provider value={contextValue}>{props.children}</GroupContext.Provider></div></div>;
};
var Separator = (props) => {
  const [localProps, etc] = splitProps(props, ["alwaysRender"]);
  const render = useCmdk((state) => !state.search);
  return <Show when={localProps.alwaysRender || render()}><div {...etc} cmdk-separator="" role="separator" /></Show>;
};
var Input = (props) => {
  const [localProps, etc] = splitProps(props, ["onValueChange", "ref"]);
  const isControlled = () => props.value != null;
  const store = useStore();
  const search = useCmdk((state) => state.search);
  const value = useCmdk((state) => state.value);
  const context = useCommand();
  const selectedItemId = createMemo(() => {
    const item = context.listInnerRef()?.querySelector(`${ITEM_SELECTOR}[${VALUE_ATTR}="${encodeURIComponent(value())}"]`);
    return item?.getAttribute("id") || void 0;
  });
  createEffect(() => {
    if (props.value != null) {
      store.setState("search", props.value);
    }
  });
  return <input
    ref={localProps.ref}
    {...etc}
    cmdk-input=""
    autocomplete="off"
    autocorrect="off"
    spellcheck={false}
    aria-autocomplete="list"
    role="combobox"
    aria-expanded={true}
    aria-controls={context.listId}
    aria-labelledby={context.labelId}
    aria-activedescendant={selectedItemId()}
    id={context.inputId}
    type="text"
    value={isControlled() ? props.value : search()}
    onInput={(e) => {
      if (!isControlled()) {
        store.setState("search", e.target.value);
      }
      localProps.onValueChange?.(e.target.value);
    }}
  />;
};
var List = (props) => {
  const mergedProps = mergeDefaultProps({ label: "Suggestions" }, props);
  const [localProps, etc] = splitProps(mergedProps, ["label", "children", "ref"]);
  let ref;
  let height;
  const context = useCommand();
  onMount(() => {
    if (!ref || !height)
      return;
    const el = height;
    const wrapper = ref;
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        const height2 = el.offsetHeight;
        wrapper.style.setProperty(`--cmdk-list-height`, height2.toFixed(1) + "px");
      });
    });
    observer.observe(el);
    return () => {
      cancelAnimationFrame(animationFrame);
      observer.unobserve(el);
    };
  });
  return <div
    ref={mergeRefs((el) => ref = el, localProps.ref)}
    {...etc}
    cmdk-list=""
    role="listbox"
    aria-label={localProps.label}
    id={context.listId}
  >{SlottableWithNestedChildren(props, (child) => <div ref={mergeRefs((el) => height = el, context.setListInnerRef)} cmdk-list-sizer="">{child}</div>)}</div>;
};
var Dialog = (props) => {
  const [localProps, dialogRootProps, etc] = splitProps(
    props,
    ["overlayClassName", "contentClassName", "container"],
    ["open", "defaultOpen", "onOpenChange", "id", "modal", "preventScroll", "forceMount", "translations"]
  );
  return <KobalteDialog.Root {...dialogRootProps}><KobalteDialog.Portal mount={localProps.container}><KobalteDialog.Overlay cmdk-overlay="" class={localProps.overlayClassName} /><KobalteDialog.Content aria-label={props.label} cmdk-dialog="" class={localProps.contentClassName}><Command {...etc} /></KobalteDialog.Content></KobalteDialog.Portal></KobalteDialog.Root>;
};
var Empty = (props) => {
  const [mounted, setMounted] = createSignal(false);
  const render = useCmdk((state) => state.filtered.count === 0 && mounted());
  onMount(() => {
    setMounted(true);
  });
  return <Show when={render()}><div {...props} cmdk-empty="" role="presentation" /></Show>;
};
var Loading = (props) => {
  const mergedProps = mergeDefaultProps(
    {
      label: "Loading..."
    },
    props
  );
  const [localProps, etc] = splitProps(mergedProps, ["progress", "children", "label"]);
  return <div
    {...etc}
    cmdk-loading=""
    role="progressbar"
    aria-valuenow={localProps.progress}
    aria-valuemin={0}
    aria-valuemax={100}
    aria-label={localProps.label}
  >{SlottableWithNestedChildren(props, (child) => <div aria-hidden>{child}</div>)}</div>;
};
var pkg = Object.assign(Command, {
  List,
  Item,
  Input,
  Group,
  Separator,
  Dialog,
  Empty,
  Loading
});
function findNextSibling(el, selector) {
  let sibling = el.nextElementSibling;
  while (sibling) {
    if (sibling.matches(selector))
      return sibling;
    sibling = sibling.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling = el.previousElementSibling;
  while (sibling) {
    if (sibling.matches(selector))
      return sibling;
    sibling = sibling.previousElementSibling;
  }
}
function useCmdk(selector) {
  const store = useStore();
  return () => selector(store.state);
}
var useScheduleLayoutEffect = () => {
  const [s, ss] = createSignal(0);
  let fns = /* @__PURE__ */ new Map();
  createEffect(() => {
    s();
    queueMicrotask(() => {
      fns.forEach((f, key) => {
        f();
      });
      fns = /* @__PURE__ */ new Map();
    });
  });
  return (id, cb) => {
    fns.set(id, cb);
    ss(s() + 1);
  };
};
function SlottableWithNestedChildren(props, render) {
  return render(props.children);
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0"
};
export {
  pkg as Command,
  Dialog as CommandDialog,
  Empty as CommandEmpty,
  Group as CommandGroup,
  Input as CommandInput,
  Item as CommandItem,
  List as CommandList,
  Loading as CommandLoading,
  Command as CommandRoot,
  Separator as CommandSeparator,
  defaultFilter,
  useCmdk as useCommandState
};
//! Causes a re-render loop, I should investigate further
//! This approach to sorting is flawed in SolidJS.
//! Sorting Elements that are generated by a <For> component will eventually cause the framework to lose track of the element
//! The error is "Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node"
