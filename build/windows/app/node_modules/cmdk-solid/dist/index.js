import { commandScore } from './chunk/IOVUHIGA.js';
import { spread, mergeProps, insert, createComponent, effect, setAttribute, style, use, memo, template } from 'solid-js/web';
import { Dialog as Dialog$1 } from '@kobalte/core';
import { mergeDefaultProps, mergeRefs } from '@kobalte/utils';
import { trackDeep } from '@solid-primitives/deep';
import { createContext, createEffect, splitProps, createUniqueId, createSignal, onMount, useContext, onCleanup, Show, createMemo } from 'solid-js';
import { createStore } from 'solid-js/store';

var _tmpl$ = /* @__PURE__ */ template(`<div tabindex=-1><label cmdk-label="">`);
var _tmpl$2 = /* @__PURE__ */ template(`<div>`);
var _tmpl$3 = /* @__PURE__ */ template(`<div cmdk-group-heading=""aria-hidden>`);
var _tmpl$4 = /* @__PURE__ */ template(`<div><div cmdk-group-items=""role=group>`);
var _tmpl$5 = /* @__PURE__ */ template(`<input>`);
var _tmpl$6 = /* @__PURE__ */ template(`<div cmdk-list-sizer="">`);
var _tmpl$7 = /* @__PURE__ */ template(`<div aria-hidden>`);
var GROUP_SELECTOR = `[cmdk-group=""]`;
var GROUP_HEADING_SELECTOR = `[cmdk-group-heading=""]`;
var ITEM_SELECTOR = `[cmdk-item=""]`;
var VALID_ITEM_SELECTOR = `${ITEM_SELECTOR}:not([aria-disabled="true"])`;
var SELECT_EVENT = `cmdk-item-select`;
var VALUE_ATTR = `data-value`;
var defaultFilter = (value, search, keywords) => commandScore(value, search, keywords);
var CommandContext = createContext(void 0);
var useCommand = () => useContext(CommandContext);
var StoreContext = createContext(void 0);
var useStore = () => useContext(StoreContext);
var GroupContext = createContext(void 0);
var Command = (props) => {
  const [state, setState] = createStore({
    search: "",
    value: props.value ?? props.defaultValue ?? "",
    filtered: {
      count: 0,
      items: {},
      groups: []
    },
    items: [],
    groups: {},
    ids: {}
  });
  createEffect(() => {
    trackDeep(state.ids);
    const skipFiltering = !state.search || props.shouldFilter === false;
    const items = state.items.reduce((acc, id) => {
      acc[id] = skipFiltering ? 1 : score(state.ids[id].value, state.ids[id].keywords);
      return acc;
    }, {});
    const groups = Object.keys(state.groups).filter((groupId) => {
      return state.groups[groupId].some((id) => (items[id] || 0) > 0);
    });
    const count = Object.values(items).filter((score2) => score2 > 0).length;
    setState("filtered", {
      count,
      items,
      groups
    });
  });
  const mergedProps = mergeDefaultProps({
    vimBindings: true,
    disablePointerSelection: false
  }, props);
  const [localProps, etc] = splitProps(mergedProps, ["label", "children", "value", "onValueChange", "filter", "shouldFilter", "loop", "disablePointerSelection", "vimBindings"]);
  const listId = createUniqueId();
  const labelId = createUniqueId();
  const inputId = createUniqueId();
  const [listInnerRef, setListInnerRef] = createSignal(null);
  const schedule = useScheduleLayoutEffect();
  createEffect(() => {
    if (localProps.value !== void 0) {
      const v = localProps.value.trim();
      if (v != state.value) {
        setState("value", v);
      }
    }
  });
  onMount(() => {
    schedule(6, scrollSelectedIntoView);
  });
  const store = {
    state,
    snapshot: () => trackDeep(state),
    setState: (key, value, opts) => {
      if (Object.is(state[key], value))
        return;
      setState(key, value);
      if (key === "search") {
        schedule(8, selectFirstItem);
      } else if (key === "value") {
        if (!opts) {
          schedule(5, scrollSelectedIntoView);
        }
        if (props.value !== void 0) {
          const newValue = value ?? "";
          props.onValueChange?.(newValue);
          return;
        }
      }
    }
  };
  const context = {
    value: (id, value, keywords) => {
      setState("ids", (ids) => ({
        ...ids,
        [id]: {
          value,
          keywords
        }
      }));
    },
    // Track item lifecycle (mount, unmount)
    item: (id, groupId) => {
      if (!listInnerRef()) {
        console.warn("Mount Command.Item inside a Command.List component.");
      }
      setState((state2) => {
        return {
          ...state2,
          items: Array.from(/* @__PURE__ */ new Set([...state2.items, id])),
          ...groupId && {
            groups: {
              ...state2.groups,
              [groupId]: [...state2.groups[groupId] || [], id]
            }
          }
        };
      });
      schedule(3, () => {
        if (!state.value) {
          selectFirstItem();
        }
      });
      onCleanup(() => {
        setState((state2) => ({
          ...state2,
          items: state2.items.filter((item) => item !== id),
          ...groupId && {
            groups: {
              ...state2.groups,
              [groupId]: state2.groups[groupId].filter((item) => item !== id)
            }
          },
          ids: Object.fromEntries(Object.entries(state2.ids).filter(([key]) => key !== id))
        }));
        const selectedItem = getSelectedItem();
        if (selectedItem?.getAttribute("id") === id)
          schedule(1, () => selectFirstItem());
      });
    },
    // Track group lifecycle (mount, unmount)
    group: (id) => {
      if (!listInnerRef()) {
        console.warn("Mount Command.Group inside a Command.List component.");
      }
      setState("groups", (state2) => {
        return {
          [id]: [],
          ...state2
        };
      });
      onCleanup(() => {
        setState((state2) => ({
          ...state2,
          groups: Object.fromEntries(Object.entries(state2.groups).filter(([key]) => key !== id)),
          ids: Object.fromEntries(Object.entries(state2.ids).filter(([key]) => key !== id))
        }));
      });
    },
    filter: () => {
      return props.shouldFilter !== false;
    },
    label: () => localProps.label || props["aria-label"] || "",
    disablePointerSelection: () => !!props.disablePointerSelection,
    listId,
    inputId,
    labelId,
    listInnerRef,
    setListInnerRef
  };
  function score(value, keywords) {
    const filter = localProps.filter ?? defaultFilter;
    return value ? filter(value, state.search, keywords) : 0;
  }
  function selectFirstItem() {
    const item = getValidItems().find((item2) => item2.getAttribute("aria-disabled") !== "true");
    const value = item?.getAttribute(VALUE_ATTR) || "";
    store.setState("value", value);
  }
  function scrollSelectedIntoView() {
    const item = getSelectedItem();
    if (item) {
      if (item.parentElement?.firstChild === item) {
        item.closest(GROUP_SELECTOR)?.querySelector(GROUP_HEADING_SELECTOR)?.scrollIntoView({
          block: "nearest",
          inline: "start",
          behavior: "smooth"
        });
      }
      item.scrollIntoView({
        block: "nearest",
        inline: "start",
        behavior: "smooth"
      });
    }
  }
  function getSelectedItem() {
    return listInnerRef()?.querySelector(`${ITEM_SELECTOR}[aria-selected="true"]`);
  }
  function getValidItems() {
    return Array.from(listInnerRef()?.querySelectorAll(VALID_ITEM_SELECTOR) || []);
  }
  function updateSelectedToIndex(index) {
    const items = getValidItems();
    const item = items[index];
    if (item)
      store.setState("value", item.getAttribute(VALUE_ATTR) || "");
  }
  function updateSelectedByItem(change) {
    const selected = getSelectedItem();
    const items = getValidItems();
    const index = items.findIndex((item) => item === selected);
    let newSelected = items[index + change];
    if (props.loop) {
      newSelected = index + change < 0 ? items[items.length - 1] : index + change === items.length ? items[0] : items[index + change];
    }
    if (newSelected)
      store.setState("value", newSelected.getAttribute(VALUE_ATTR) || "");
  }
  function updateSelectedByGroup(change) {
    const selected = getSelectedItem();
    let group = selected?.closest(GROUP_SELECTOR);
    let item = null;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, GROUP_SELECTOR) : findPreviousSibling(group, GROUP_SELECTOR);
      item = group?.querySelector(VALID_ITEM_SELECTOR) || null;
    }
    if (item) {
      store.setState("value", item.getAttribute(VALUE_ATTR) || "");
    } else {
      updateSelectedByItem(change);
    }
  }
  const last = () => updateSelectedToIndex(getValidItems().length - 1);
  const next = (e) => {
    e.preventDefault();
    if (e.metaKey) {
      last();
    } else if (e.altKey) {
      updateSelectedByGroup(1);
    } else {
      updateSelectedByItem(1);
    }
  };
  const prev = (e) => {
    e.preventDefault();
    if (e.metaKey) {
      updateSelectedToIndex(0);
    } else if (e.altKey) {
      updateSelectedByGroup(-1);
    } else {
      updateSelectedByItem(-1);
    }
  };
  return (() => {
    var _el$ = _tmpl$(), _el$2 = _el$.firstChild;
    spread(_el$, mergeProps(etc, {
      "cmdk-root": "",
      "onKeyDown": (e) => {
        etc.onKeyDown?.(e);
        if (!e.defaultPrevented) {
          switch (e.key) {
            case "n":
            case "j": {
              if (localProps.vimBindings && e.ctrlKey) {
                next(e);
              }
              break;
            }
            case "ArrowDown": {
              next(e);
              break;
            }
            case "p":
            case "k": {
              if (localProps.vimBindings && e.ctrlKey) {
                prev(e);
              }
              break;
            }
            case "ArrowUp": {
              prev(e);
              break;
            }
            case "Home": {
              e.preventDefault();
              updateSelectedToIndex(0);
              break;
            }
            case "End": {
              e.preventDefault();
              last();
              break;
            }
            case "Enter": {
              if (!e.isComposing && e.keyCode !== 229) {
                e.preventDefault();
                const item = getSelectedItem();
                if (item) {
                  const event = new Event(SELECT_EVENT);
                  item.dispatchEvent(event);
                }
              }
            }
          }
        }
      }
    }), false, true);
    insert(_el$2, () => localProps.label);
    insert(_el$, createComponent(StoreContext.Provider, {
      value: store,
      get children() {
        return createComponent(CommandContext.Provider, {
          value: context,
          get children() {
            return props.children;
          }
        });
      }
    }), null);
    effect((_p$) => {
      var _v$ = context.inputId, _v$2 = context.labelId, _v$3 = srOnlyStyles;
      _v$ !== _p$.e && setAttribute(_el$2, "for", _p$.e = _v$);
      _v$2 !== _p$.t && setAttribute(_el$2, "id", _p$.t = _v$2);
      _p$.a = style(_el$2, _v$3, _p$.a);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })();
};
var Item = (props) => {
  const store = useStore();
  const id = createUniqueId();
  const [ref, setRef] = createSignal();
  const groupContext = useContext(GroupContext);
  const context = useCommand();
  const [rendered, setRendered] = createSignal(false);
  onMount(() => {
    if (!forceMount()) {
      return context.item(id, groupContext?.().id);
    }
  });
  const [value, setValue] = createSignal(props.value || "");
  createEffect(() => {
    if (props.value) {
      setValue(props.value);
      return;
    }
    const innerValue = ref()?.textContent;
    if (innerValue) {
      setValue(innerValue);
      return;
    }
  });
  createEffect(() => {
    context.value(id, value(), props.keywords);
    ref()?.setAttribute(VALUE_ATTR, value());
  });
  const forceMount = () => props.forceMount ?? groupContext?.().forceMount;
  const selected = useCmdk((state) => value() && value() == state.value);
  const render = useCmdk((state) => !rendered() ? true : forceMount() ? true : context.filter() === false ? true : !state.search ? true : (state.filtered.items[id] || 0) > 0);
  onMount(() => {
    const element = ref();
    if (!element || props.disabled)
      return;
    element.addEventListener(SELECT_EVENT, onSelect);
    onCleanup(() => element.removeEventListener(SELECT_EVENT, onSelect));
    setRendered(true);
  });
  function onSelect() {
    select();
    props.onSelect?.(value());
  }
  function select() {
    store.setState("value", value(), true);
  }
  const [localProps, etc] = splitProps(props, ["disabled", "onSelect", "value", "forceMount", "keywords"]);
  return createComponent(Show, {
    get when() {
      return render();
    },
    get children() {
      var _el$3 = _tmpl$2();
      use((el) => setRef(el), _el$3);
      spread(_el$3, mergeProps(etc, {
        "id": id,
        "cmdk-item": "",
        "role": "option",
        get ["aria-disabled"]() {
          return Boolean(localProps.disabled);
        },
        get ["aria-selected"]() {
          return Boolean(selected());
        },
        get ["data-disabled"]() {
          return Boolean(localProps.disabled);
        },
        get ["data-selected"]() {
          return Boolean(selected());
        },
        get onPointerMove() {
          return localProps.disabled || context.disablePointerSelection() ? void 0 : select;
        },
        get onClick() {
          return localProps.disabled ? void 0 : onSelect;
        }
      }), false, true);
      insert(_el$3, () => props.children);
      return _el$3;
    }
  });
};
var Group = (props) => {
  const [localProps, etc] = splitProps(props, ["heading", "value", "forceMount"]);
  const id = createUniqueId();
  const [ref, setRef] = createSignal();
  const [headerRef, setHeaderRef] = createSignal();
  const headingId = createUniqueId();
  const context = useCommand();
  const render = useCmdk((state) => {
    return localProps.forceMount ? true : context.filter() === false ? true : !state.search ? true : state.filtered.groups.includes(id);
  });
  onMount(() => {
    context.group(id);
  });
  const [value, setValue] = createSignal(props.value || "");
  createEffect(() => {
    if (props.value) {
      setValue(props.value);
      return;
    }
    const innerValue = headerRef()?.textContent;
    if (innerValue) {
      setValue(innerValue);
      return;
    }
  });
  createEffect(() => {
    context.value(id, value());
    ref()?.setAttribute(VALUE_ATTR, value());
  });
  const contextValue = () => ({
    id,
    forceMount: localProps.forceMount
  });
  return (() => {
    var _el$4 = _tmpl$4(), _el$6 = _el$4.firstChild;
    var _ref$ = mergeRefs((el) => setRef(el), props.ref);
    typeof _ref$ === "function" && use(_ref$, _el$4);
    spread(_el$4, mergeProps(etc, {
      "cmdk-group": "",
      "id": id,
      "role": "presentation",
      get hidden() {
        return render() ? void 0 : true;
      }
    }), false, true);
    insert(_el$4, createComponent(Show, {
      get when() {
        return props.heading;
      },
      get children() {
        var _el$5 = _tmpl$3();
        use((el) => setHeaderRef(el), _el$5);
        setAttribute(_el$5, "id", headingId);
        insert(_el$5, () => props.heading);
        return _el$5;
      }
    }), _el$6);
    insert(_el$6, createComponent(GroupContext.Provider, {
      value: contextValue,
      get children() {
        return props.children;
      }
    }));
    effect(() => setAttribute(_el$6, "aria-labelledby", props.heading ? headingId : void 0));
    return _el$4;
  })();
};
var Separator = (props) => {
  const [localProps, etc] = splitProps(props, ["alwaysRender"]);
  const render = useCmdk((state) => !state.search);
  return createComponent(Show, {
    get when() {
      return localProps.alwaysRender || render();
    },
    get children() {
      var _el$7 = _tmpl$2();
      spread(_el$7, mergeProps(etc, {
        "cmdk-separator": "",
        "role": "separator"
      }), false, false);
      return _el$7;
    }
  });
};
var Input = (props) => {
  const [localProps, etc] = splitProps(props, ["onValueChange", "ref"]);
  const isControlled = () => props.value != null;
  const store = useStore();
  const search = useCmdk((state) => state.search);
  const value = useCmdk((state) => state.value);
  const context = useCommand();
  const selectedItemId = createMemo(() => {
    const item = context.listInnerRef()?.querySelector(`${ITEM_SELECTOR}[${VALUE_ATTR}="${encodeURIComponent(value())}"]`);
    return item?.getAttribute("id") || void 0;
  });
  createEffect(() => {
    if (props.value != null) {
      store.setState("search", props.value);
    }
  });
  return (() => {
    var _el$8 = _tmpl$5();
    var _ref$2 = localProps.ref;
    typeof _ref$2 === "function" ? use(_ref$2, _el$8) : localProps.ref = _el$8;
    spread(_el$8, mergeProps(etc, {
      "cmdk-input": "",
      "autocomplete": "off",
      "autocorrect": "off",
      "spellcheck": false,
      "aria-autocomplete": "list",
      "role": "combobox",
      "aria-expanded": true,
      get ["aria-controls"]() {
        return context.listId;
      },
      get ["aria-labelledby"]() {
        return context.labelId;
      },
      get ["aria-activedescendant"]() {
        return selectedItemId();
      },
      get id() {
        return context.inputId;
      },
      "type": "text",
      get value() {
        return memo(() => !!isControlled())() ? props.value : search();
      },
      "onInput": (e) => {
        if (!isControlled()) {
          store.setState("search", e.target.value);
        }
        localProps.onValueChange?.(e.target.value);
      }
    }), false, false);
    return _el$8;
  })();
};
var List = (props) => {
  const mergedProps = mergeDefaultProps({
    label: "Suggestions"
  }, props);
  const [localProps, etc] = splitProps(mergedProps, ["label", "children", "ref"]);
  let ref;
  let height;
  const context = useCommand();
  onMount(() => {
    if (!ref || !height)
      return;
    const el = height;
    const wrapper = ref;
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        const height2 = el.offsetHeight;
        wrapper.style.setProperty(`--cmdk-list-height`, height2.toFixed(1) + "px");
      });
    });
    observer.observe(el);
    return () => {
      cancelAnimationFrame(animationFrame);
      observer.unobserve(el);
    };
  });
  return (() => {
    var _el$9 = _tmpl$2();
    var _ref$3 = mergeRefs((el) => ref = el, localProps.ref);
    typeof _ref$3 === "function" && use(_ref$3, _el$9);
    spread(_el$9, mergeProps(etc, {
      "cmdk-list": "",
      "role": "listbox",
      get ["aria-label"]() {
        return localProps.label;
      },
      get id() {
        return context.listId;
      }
    }), false, true);
    insert(_el$9, () => SlottableWithNestedChildren(props, (child) => (() => {
      var _el$10 = _tmpl$6();
      var _ref$4 = mergeRefs((el) => height = el, context.setListInnerRef);
      typeof _ref$4 === "function" && use(_ref$4, _el$10);
      insert(_el$10, child);
      return _el$10;
    })()));
    return _el$9;
  })();
};
var Dialog = (props) => {
  const [localProps, dialogRootProps, etc] = splitProps(props, ["overlayClassName", "contentClassName", "container"], ["open", "defaultOpen", "onOpenChange", "id", "modal", "preventScroll", "forceMount", "translations"]);
  return createComponent(Dialog$1.Root, mergeProps(dialogRootProps, {
    get children() {
      return createComponent(Dialog$1.Portal, {
        get mount() {
          return localProps.container;
        },
        get children() {
          return [createComponent(Dialog$1.Overlay, {
            "cmdk-overlay": "",
            get ["class"]() {
              return localProps.overlayClassName;
            }
          }), createComponent(Dialog$1.Content, {
            get ["aria-label"]() {
              return props.label;
            },
            "cmdk-dialog": "",
            get ["class"]() {
              return localProps.contentClassName;
            },
            get children() {
              return createComponent(Command, etc);
            }
          })];
        }
      });
    }
  }));
};
var Empty = (props) => {
  const [mounted, setMounted] = createSignal(false);
  const render = useCmdk((state) => state.filtered.count === 0 && mounted());
  onMount(() => {
    setMounted(true);
  });
  return createComponent(Show, {
    get when() {
      return render();
    },
    get children() {
      var _el$11 = _tmpl$2();
      spread(_el$11, mergeProps(props, {
        "cmdk-empty": "",
        "role": "presentation"
      }), false, false);
      return _el$11;
    }
  });
};
var Loading = (props) => {
  const mergedProps = mergeDefaultProps({
    label: "Loading..."
  }, props);
  const [localProps, etc] = splitProps(mergedProps, ["progress", "children", "label"]);
  return (() => {
    var _el$12 = _tmpl$2();
    spread(_el$12, mergeProps(etc, {
      "cmdk-loading": "",
      "role": "progressbar",
      get ["aria-valuenow"]() {
        return localProps.progress;
      },
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      get ["aria-label"]() {
        return localProps.label;
      }
    }), false, true);
    insert(_el$12, () => SlottableWithNestedChildren(props, (child) => (() => {
      var _el$13 = _tmpl$7();
      insert(_el$13, child);
      return _el$13;
    })()));
    return _el$12;
  })();
};
var pkg = Object.assign(Command, {
  List,
  Item,
  Input,
  Group,
  Separator,
  Dialog,
  Empty,
  Loading
});
function findNextSibling(el, selector) {
  let sibling = el.nextElementSibling;
  while (sibling) {
    if (sibling.matches(selector))
      return sibling;
    sibling = sibling.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling = el.previousElementSibling;
  while (sibling) {
    if (sibling.matches(selector))
      return sibling;
    sibling = sibling.previousElementSibling;
  }
}
function useCmdk(selector) {
  const store = useStore();
  return () => selector(store.state);
}
var useScheduleLayoutEffect = () => {
  const [s, ss] = createSignal(0);
  let fns = /* @__PURE__ */ new Map();
  createEffect(() => {
    s();
    queueMicrotask(() => {
      fns.forEach((f, key) => {
        f();
      });
      fns = /* @__PURE__ */ new Map();
    });
  });
  return (id, cb) => {
    fns.set(id, cb);
    ss(s() + 1);
  };
};
function SlottableWithNestedChildren(props, render) {
  return render(props.children);
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0"
};
//! Causes a re-render loop, I should investigate further
//! This approach to sorting is flawed in SolidJS.
//! Sorting Elements that are generated by a <For> component will eventually cause the framework to lose track of the element
//! The error is "Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node"

export { pkg as Command, Dialog as CommandDialog, Empty as CommandEmpty, Group as CommandGroup, Input as CommandInput, Item as CommandItem, List as CommandList, Loading as CommandLoading, Command as CommandRoot, Separator as CommandSeparator, defaultFilter, useCmdk as useCommandState };
