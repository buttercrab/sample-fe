import { untrack, createComputed, createSignal, children, batch, } from "solid-js";
import { camelize } from "../utils/camelize";
import { queryElement } from "../utils/queryElement";
import { runToggleScrollbar } from "../utils/runToggleScrollbar";
function nextFrame(fn) {
    requestAnimationFrame(() => {
        requestAnimationFrame(fn);
    });
}
export const Transition = (props) => {
    let el;
    let first = true;
    let isPortal = false;
    let portalMarker;
    let isExiting = false;
    let hasOverlayAnimation = !!props.overlay;
    const [s1, set1] = createSignal();
    const [s2, set2] = createSignal();
    const resolved = children(() => props.children);
    const { onBeforeEnter, onEnter, onAfterEnter, onBeforeExit, onExit, onAfterExit, appendToElement, appear, state, } = props;
    const { onBeforeEnter: onBeforeEnterOverlay, onEnter: onEnterOverlay, onAfterEnter: onAfterEnterOverlay, onBeforeExit: onBeforeExitOverlay, onExit: onExitOverlay, onAfterExit: onAfterExitOverlay, appendToElement: appendToElementOverlay, } = props.overlay || {};
    const createOnBeforeEnter = (type) => type === "content" ? onBeforeEnter : onBeforeEnterOverlay;
    const createOnEnter = (type) => type === "content" ? onEnter : onEnterOverlay;
    const createOnAfterEnter = (type) => type === "content" ? onAfterEnter : onAfterEnterOverlay;
    const createOnBeforeExit = (type) => type === "content" ? onBeforeExit : onBeforeExitOverlay;
    const createOnExit = (type) => type === "content" ? onExit : onExitOverlay;
    const createOnAfterExit = (type) => type === "content" ? onAfterExit : onAfterExitOverlay;
    function getClassState(animatedElType, type) {
        const getName = () => {
            return animatedElType === "content" ? props.name : props.overlay?.name;
        };
        const name = getName() || "s";
        const propStr = camelize(type) + "Class";
        const classAnimationStates = animatedElType === "content" ? props : props.overlay;
        // @ts-ignore
        const classState = classAnimationStates[propStr];
        return classState ? classState.split(" ") : [`${name}-${type}`];
    }
    const getElement = (type, el) => {
        const appendToElement_ = type === "content" ? appendToElement : appendToElementOverlay;
        if (appendToElement_) {
            if (appendToElement_ === "menuPopup" && type !== "overlay") {
                return queryElement({ containerEl: el }, { inputElement: null, type: "menuPopup" });
            }
            return typeof appendToElement_ === "string"
                ? el && el.querySelector(appendToElement_)
                : appendToElement_;
        }
        return el;
    };
    let endExitTransitionRef;
    let endExitTransitionOverlayRef;
    function enterTransition(type, _el, prev) {
        // TODO: refactor this
        if (isExiting) {
            if (type === "content") {
                endExitTransitionRef();
            }
            else {
                endExitTransitionOverlayRef();
            }
        }
        if (!first || props.appear) {
            const onEnter = createOnEnter(type);
            const onBeforeEnter = createOnBeforeEnter(type);
            const onAfterEnter = createOnAfterEnter(type);
            const enterClasses = getClassState(type, "enter");
            const enterActiveClasses = getClassState(type, "enter-active");
            const enterToClasses = getClassState(type, "enter-to");
            const el = getElement(type, _el);
            onBeforeEnter && onBeforeEnter(el);
            el.classList.add(...enterClasses);
            el.classList.add(...enterActiveClasses);
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    el.classList.remove(...enterClasses);
                    el.classList.add(...enterToClasses);
                });
                onEnter && onEnter(el, () => endTransition());
                requestAnimationFrame(() => {
                    if (!onEnter || onEnter.length < 2) {
                        el.addEventListener("transitionend", endTransition);
                        el.addEventListener("animationend", endTransition);
                    }
                });
            });
            function endTransition(e) {
                if (el && (!e || e.target === el)) {
                    el.removeEventListener("transitionend", endTransition);
                    el.removeEventListener("animationend", endTransition);
                    el.classList.remove(...enterActiveClasses);
                    el.classList.remove(...enterToClasses);
                    batch(() => {
                        const el_ = isPortal ? portalMarker : _el;
                        s1() !== el_ && set1(el_);
                        s2() === el_ && set2(undefined);
                    });
                    onAfterEnter && onAfterEnter(el);
                    if (props.mode === "inout")
                        exitTransition(type, el, prev);
                }
            }
        }
        if (type === "content") {
            const el_ = isPortal ? portalMarker : _el;
            prev && !props.mode ? set2(el_) : set1(el_);
        }
    }
    function exitTransition(type, _el, _prev) {
        isExiting = true;
        const onExit = createOnExit(type);
        const onBeforeExit = createOnBeforeExit(type);
        const onAfterExit = createOnAfterExit(type);
        const exitClasses = getClassState(type, "exit");
        const exitActiveClasses = getClassState(type, "exit-active");
        const exitToClasses = getClassState(type, "exit-to");
        const el = getElement(type, _el);
        const prev = getElement(type, _prev);
        if (!prev.parentNode)
            return endTransition();
        onBeforeExit && onBeforeExit(prev);
        prev.classList.add(...exitClasses);
        prev.classList.add(...exitActiveClasses);
        nextFrame(() => {
            prev.classList.remove(...exitClasses);
            prev.classList.add(...exitToClasses);
        });
        onExit && onExit(prev, () => endTransition());
        if (!onExit || onExit.length < 2) {
            prev.addEventListener("transitionend", endTransition);
            prev.addEventListener("animationend", endTransition);
        }
        function endTransition(e) {
            if (!e || e.target === prev) {
                isExiting = false;
                prev.removeEventListener("transitionend", endTransition);
                prev.removeEventListener("animationend", endTransition);
                if (type === "content") {
                    prev.classList.remove(...exitActiveClasses);
                    prev.classList.remove(...exitToClasses);
                }
                if (type === "content") {
                    if (isPortal) {
                        // @ts-ignore
                        _prev.parentElement.remove();
                        runToggleScrollbar(state, false);
                    }
                    s1() === _prev && set1(undefined);
                }
                onAfterExit && onAfterExit(prev);
                if (props.mode === "outin")
                    enterTransition(type, el, prev);
            }
        }
        if (type === "content") {
            endExitTransitionRef = endTransition;
        }
        else {
            endExitTransitionOverlayRef = endTransition;
        }
    }
    createComputed((prev) => {
        el = resolved();
        while (typeof el === "function")
            el = el();
        if (el && el.nodeType === 3) {
            isPortal = true;
            portalMarker = el;
            // @ts-ignore
            portalMarker.willRemove = false;
            // @ts-ignore
            const portalContainerChild = el["portalContainerChild"];
            if (hasOverlayAnimation) {
                // @ts-ignore
                const overlayChildren = el["portalOverlay"];
                Object.defineProperty(portalContainerChild, "portalOverlay", {
                    get() {
                        return overlayChildren;
                    },
                    configurable: true,
                });
            }
            el = portalContainerChild;
        }
        return untrack(() => {
            if (el && el !== prev) {
                if (props.mode !== "outin") {
                    enterTransition("content", el, prev);
                    if (hasOverlayAnimation) {
                        enterTransition("overlay", 
                        // @ts-ignore
                        el.portalOverlay, 
                        // @ts-ignore
                        prev && prev.portalOverlay);
                    }
                }
                else if (first) {
                    const _el = isPortal ? portalMarker : el;
                    set1(_el);
                }
            }
            if (prev && prev !== el && props.mode !== "inout") {
                exitTransition("content", el, prev);
                if (hasOverlayAnimation) {
                    // @ts-ignore
                    exitTransition("overlay", el && el.portalOverlay, prev.portalOverlay);
                }
            }
            first = false;
            return el;
        });
    });
    return [s1, s2];
};
