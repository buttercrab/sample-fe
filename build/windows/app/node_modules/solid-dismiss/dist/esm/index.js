import { insert, delegateEvents, isServer, use, addEventListener, effect, setAttribute, className, classList, createComponent, mergeProps, template } from 'solid-js/web';
import { createSignal, children, createComputed, untrack, batch, createRoot, onCleanup, sharedConfig, createUniqueId, on, createEffect, createMemo } from 'solid-js';

const dismissStack = [];
const addDismissStack = props => {
  dismissStack.push(props);
};
const removeDismissStack = id => {
  const foundIdx = dismissStack.findIndex(item => item.uniqueId === id);
  if (foundIdx === -1) return;
  const foundStack = dismissStack[foundIdx];
  dismissStack.splice(foundIdx, 1);
  return foundStack;
};

const _tabbableSelectors = ["a[href]", "area[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "iframe", "[tabindex]", "[contentEditable=true]"].reduce((a, c, idx) => `${a}${idx ? "," : ""}${c}:not([tabindex="-1"])`, "");

let willWrap = false;
const getNextTabbableElement = ({
  from: _from,
  stopAtRootElement: stopAtRootElement,
  ignoreElement = [],
  allowSelectors,
  direction = "forwards",
  wrap
}) => {
  let fromResult;
  let _isFromElIframe = false;

  if (!(_from instanceof Element)) {
    if (_from === "activeElement") {
      const activeElement = document.activeElement;
      _isFromElIframe = isIframe(activeElement);
      fromResult = getActiveElement(activeElement);
    }

    if (typeof _from === "object") {
      if (_from.getActiveElement) {
        fromResult = getActiveElement(_from.el);
      }

      _isFromElIframe = _from.isIframe;
    }
  } else {
    _isFromElIframe = isIframe(_from);
    fromResult = _from;
  }

  const from = fromResult;
  const parent = from.parentElement;
  const isFromElIframe = _isFromElIframe;
  const visitedElement = from;
  const tabbableSelectors = _tabbableSelectors + (allowSelectors ? "," + allowSelectors.join(",") : "");
  if (!visitedElement) return null;

  const traverseNextSiblingsThenUp = (parent, visitedElement) => {
    let hasPassedVisitedElement = false;
    const children = parent.children;
    const childrenCount = children.length;

    if (willWrap) {
      hasPassedVisitedElement = true;
    }

    if (direction === "forwards") {
      for (let i = 0; i < childrenCount; i++) {
        const child = children[i];

        if (hasPassedVisitedElement) {
          const el = queryTabbableElement(child, tabbableSelectors, direction, ignoreElement);

          if (el) {
            return el;
          }

          continue;
        }

        if (child === stopAtRootElement) {
          return null;
        }

        if (child === visitedElement) {
          hasPassedVisitedElement = true;
          continue;
        }
      }
    } else {
      for (let i = childrenCount - 1; i >= 0; i--) {
        const child = children[i];

        if (hasPassedVisitedElement) {
          const el = queryTabbableElement(child, tabbableSelectors, direction, ignoreElement);
          if (el) return el;
          continue;
        }

        if (child === stopAtRootElement) {
          return null;
        }

        if (child === visitedElement) {
          hasPassedVisitedElement = true;
          continue;
        }
      }
    }

    visitedElement = parent;
    parent = parent.parentElement;

    if (!parent && isFromElIframe) {
      // TODO: only get's top level iframe, should get correct iframe
      const iframe = document.activeElement;

      if (iframe && isIframe(iframe)) {
        visitedElement = iframe;
        parent = iframe.parentElement;
      }
    }

    if (!parent) {
      return null;
    }

    return traverseNextSiblingsThenUp(parent, visitedElement);
  };

  let result = traverseNextSiblingsThenUp(parent, visitedElement);

  if (!result && wrap && stopAtRootElement) {
    willWrap = true;
    result = getNextTabbableElement({
      from: stopAtRootElement,
      allowSelectors,
      direction,
      ignoreElement,
      // stopAtElement,
      wrap: false
    });
  }

  willWrap = false;
  return result;
};

const getIframeWindow = iframe => {
  try {
    return iframe.contentWindow;
  } catch (e) {
    return null;
  }
};

const getIframeDocument = iframe => {
  const iframeWindow = getIframeWindow(iframe);
  if (!iframeWindow) return null;
  return iframeWindow.document;
};

const getActiveElement = el => {
  // TODO: only goes one depth, should go infinitly
  if (!isIframe(el)) return el;
  const iframeDocument = getIframeDocument(el);
  if (!iframeDocument) return el;
  return iframeDocument.activeElement || el;
};

const isHidden = (el, windowContext = window) => {
  const checkByStyle = style => style.display === "none" || style.visibility === "hidden";

  if (el.style && checkByStyle(el.style) || el.hidden) return true;
  const style = windowContext.getComputedStyle(el);
  if (!style || checkByStyle(style)) return true;
  return false;
};

const queryTabbableElement = (el, selectors = _tabbableSelectors, iterationDirection = "forwards", ignoreElement = [], windowContext = window, init = true) => {
  const queryChild = el => {
    if (!el.matches(selectors)) return {
      el,
      matched: false
    };
    const tabindex = el.getAttribute("tabindex");

    if (isIframe(el) && (!tabindex || tabindex === "-1")) {
      const iframeWindow = getIframeWindow(el);

      if (!iframeWindow) {
        return {
          el,
          matched: true
        };
      }

      el = iframeWindow.document.documentElement;
      windowContext = iframeWindow;
      return {
        el,
        matched: false,
        windowContext: iframeWindow
      };
    }

    return {
      el,
      matched: true
    };
  };

  if (init) {
    if (ignoreElement.some(item => item === el) || isHidden(el, windowContext)) return null;
    const {
      el: elResult,
      matched,
      windowContext: windowContextResult
    } = queryChild(el);
    el = elResult;
    if (matched) return el;
    windowContext = windowContextResult || windowContext;
    return queryTabbableElement(el, selectors, iterationDirection, ignoreElement, windowContext, false);
  }

  const shadowRoot = el.shadowRoot;
  if (shadowRoot) el = shadowRoot;
  const children = el.children;
  const childrenLength = children.length;

  const iterateChild = el => {
    if (ignoreElement.some(item => item === el) || isHidden(el, windowContext)) return {
      continue: true
    };
    const {
      el: elResult,
      matched,
      windowContext: windowContextResult
    } = queryChild(el);
    el = elResult;
    windowContext = windowContextResult || windowContext;

    if (matched) {
      return {
        returnVal: el
      };
    }

    const foundChild = queryTabbableElement(el, selectors, iterationDirection, ignoreElement, windowContext, false);
    if (foundChild) return {
      returnVal: foundChild
    };
    return null;
  };

  if (iterationDirection === "forwards") {
    for (let i = 0; i < childrenLength; i++) {
      let child = children[i];
      const result = iterateChild(child);

      if (result) {
        if (result.continue) continue;
        if (result.returnVal) return result.returnVal;
      }
    }
  } else {
    for (let i = childrenLength - 1; i >= 0; i--) {
      let child = children[i];
      const result = iterateChild(child);

      if (result) {
        if (result.continue) continue;
        if (result.returnVal) return result.returnVal;
      }
    }
  }

  return null;
};

const isIframe = el => el.tagName === "IFRAME";

/**
 * Why this might be better than direct check of CSS display property? Because you do not need to check all parent elements. If some parent element has display: none, its children are hidden too but still has `element.style.display !== 'none'`
 */
const hasDisplayNone = el => el.offsetHeight === 0 && el.offsetWidth === 0;

const isObjectLiteral = value => Object.getPrototypeOf(value) === Object.prototype;

const queryElement = (state, {
  inputElement,
  type,
  subType
}) => {
  if (inputElement === "menuPopup") {
    return state.menuPopupEl;
  }

  if (inputElement === "menuButton") {
    return getMenuButton(state.menuBtnEls);
  }

  if (type === "focusElementOnOpen") {
    if (isObjectLiteral(inputElement)) {
      return queryElement(state, {
        inputElement: inputElement.target,
        type: "focusElementOnOpen"
      });
    }

    if (inputElement === "none") return null;

    if (inputElement === "firstChild") {
      return getNextTabbableElement({
        from: state.focusSentinelBeforeEl,
        stopAtRootElement: state.containerEl
      });
    }

    if (typeof inputElement === "string") {
      return state.containerEl?.querySelector(inputElement);
    }

    if (inputElement instanceof Element) {
      return inputElement;
    }

    if (typeof inputElement === "object") {
      return queryElement(state, {
        inputElement: inputElement.target,
        type: "focusElementOnOpen"
      });
    }

    const component = inputElement();

    if (typeof component === "string") {
      return state.containerEl?.querySelector(component);
    }

    return component;
  }

  if (inputElement == null && type === "menuPopup") {
    if (!state.containerEl) return null;
    if (state.menuPopupEl) return state.menuPopupEl;
    return state.containerEl.children[1];
  }

  if (typeof inputElement === "string" && type === "menuButton") {
    return document.querySelector(inputElement);
  }

  if (typeof inputElement === "string") {
    return document.querySelector(inputElement);
  }

  if (inputElement instanceof Element) {
    return inputElement;
  }

  if (typeof inputElement === "function") {
    const result = inputElement();

    if (result instanceof Element) {
      return result;
    }

    if (type === "closeButton") {
      if (!state.containerEl) return null;
      return state.containerEl.querySelector(result);
    }
  }

  if (type === "focusElementOnClose") {
    if (!inputElement) return null;

    switch (subType) {
      case "tabForwards":
        return queryElement(state, {
          inputElement: inputElement.tabForwards
        });

      case "tabBackwards":
        return queryElement(state, {
          inputElement: inputElement.tabBackwards
        });

      case "click":
        return queryElement(state, {
          inputElement: inputElement.click
        });

      case "escapeKey":
        return queryElement(state, {
          inputElement: inputElement.escapeKey
        });

      case "scrolling":
        return queryElement(state, {
          inputElement: inputElement.scrolling
        });
    }
  }

  if (inputElement == null) return null;

  if (Array.isArray(inputElement)) {
    return inputElement.map(el => queryElement(state, {
      inputElement: el,
      type
    }));
  }

  for (const key in inputElement) {
    const item = inputElement[key];
    return queryElement(state, {
      inputElement: item
    });
  }

  return null;
};

/**
 * checks if element is hidden or invisible
 *
 * The shallow checking is whether element has css `visibility: hidden` property
 */

const isHiddenOrInvisbleShallow = el => {
  const isInvisible = el => {
    const checkByStyle = style => style.visibility === "hidden";

    if (el.style && checkByStyle(el.style) || el.hidden) return true;
    const style = window.getComputedStyle(el);
    if (!style || checkByStyle(style)) return true;
    return false;
  };

  return hasDisplayNone(el) || isInvisible(el);
};

/**
 *  Iterate stack backwards, checks item, pass it to close callback. Setting `continue` to `true` property in checkCb return object, will continue iteration
 */
const checkThenClose = (arr, checkCb, destroyCb) => {
  for (let i = arr.length - 1; i >= 0; i--) {
    const {
      item,
      continue: _continue
    } = checkCb(arr[i]);

    if (item) {
      destroyCb(item);
    }

    if (_continue) continue;
    return;
  }
};

const onClickMenuButton = (state, e) => {
  const {
    timeouts,
    closeWhenMenuButtonIsClicked,
    focusedMenuBtn,
    onClickOutsideMenuButtonRef: onClickOutsideRef,
    setOpen,
    open,
    deadMenuButton,
    closeWhenClickingOutside
  } = state;
  state.menuBtnMouseDownFired = false;
  const menuBtnEl = e.currentTarget;
  globalState.focusedMenuBtns.forEach(item => item.el = null);

  if (deadMenuButton) {
    // globalState.addedDocumentClick = true;
    // setTimeout(() => {
    //   document.addEventListener("pointerdown", onDocumentClick, { once: true });
    // });
    return;
  }

  state.menuBtnKeyupTabFired = false;
  focusedMenuBtn.el = menuBtnEl;
  globalState.focusedMenuBtns.add(focusedMenuBtn); // TODO:?
  // timeouts.containerFocusTimeoutId = null;

  if (!closeWhenClickingOutside) {
    const stackItem = dismissStack[dismissStack.length - 1];

    if (stackItem && !stackItem.menuBtnEls.includes(menuBtnEl) && !stackItem.containerEl.contains(menuBtnEl)) {
      checkThenClose(dismissStack, item => {
        return {
          item,
          continue: true
        };
      }, item => {
        const {
          setOpen
        } = item;
        setOpen(false);
      });
    }
  }

  if (!closeWhenMenuButtonIsClicked) {
    setOpen(true);
    return;
  }

  if (open()) {
    // focusedMenuBtn.el = null;
    globalState.closedByEvents = true;
  }

  setOpen(!open());
};
const onBlurMenuButton = (state, e) => {
  const {
    containerEl,
    focusedMenuBtn,
    overlay,
    setOpen,
    timeouts,
    menuBtnMouseDownFired,
    closeWhenDocumentBlurs,
    closeWhenClickingOutside,
    open
  } = state;
  const currentMenuBtn = e.currentTarget;
  queueMicrotask(() => {
    runLastAfterEvents();
  });

  if (state.menuBtnKeyupTabFired) {
    state.menuBtnKeyupTabFired = false;
    return;
  }

  if (menuBtnMouseDownFired) return;
  if (containerEl && containerEl.contains(e.relatedTarget)) return;

  if (!closeWhenClickingOutside && open()) {
    document.addEventListener("keydown", onKeyDownFocusIn);
    return;
  }

  const clickedTarget = globalState.clickTarget;

  const run = () => {
    const activeElement = document.activeElement;
    if (!e.relatedTarget && activeElement && activeElement.tagName === "IFRAME", containerEl && containerEl.contains(activeElement)) return;
    if (!closeWhenDocumentBlurs && !document.hasFocus()) return;
    if (globalState.closedBySetOpen) return;
    if (!currentMenuBtn.isConnected) return;

    if (isHiddenOrInvisbleShallow(currentMenuBtn)) {
      let clickIsOutside = false;
      state.menuBtnEls?.some(el => {
        if (el === currentMenuBtn) return false;
        if (isHiddenOrInvisbleShallow(el)) return false;

        if (clickedTarget && !el.contains(clickedTarget)) {
          clickIsOutside = true;
          return false;
        }

        el.focus();
        return true;
      });

      if (!clickIsOutside) {
        return;
      }
    }

    if (!state.open()) return;
    globalState.closedByEvents = true; // TODO:?

    focusedMenuBtn.el = null;
    setOpen(false);
  };

  timeouts.menuButtonBlurTimeoutId = window.setTimeout(run);
};
const onMouseDownMenuButton = (state, e) => {
  const {
    focusMenuButtonOnMouseDown
  } = state;
  const menuBtnEl = e.currentTarget;
  state.menuBtnMouseDownFired = true;
  menuBtnEl.addEventListener("click", state.onClickMenuButtonRef); // if `false`, enables switching focus from menuButton to menuPopup input element while keeping virtual keyboard opened in iOS. However end-user must also provide additional logic to fire inside menuButton onclick for behavior to work.

  if (focusMenuButtonOnMouseDown) {
    menuBtnEl.addEventListener("blur", state.onBlurMenuButtonRef);
    requestAnimationFrame(() => {
      menuBtnEl.focus();
    });
  }
}; // TODO: ?

const onClickOutsideMenuButton = state => {
  state.focusedMenuBtn.el = null;
};
const onKeydownMenuButton = (state, e) => {
  const {
    containerEl,
    setOpen,
    open,
    onKeydownMenuButtonRef,
    onBlurMenuButtonRef,
    mount,
    focusSentinelBeforeEl,
    focusSentinelAfterEl,
    ignoreMenuPopupWhenTabbing
  } = state;
  const menuBtnEl = e.currentTarget;
  if (e.key !== "Tab") return;
  globalState.focusedMenuBtns.forEach(item => item.el = null);
  if (!open()) return;
  state.menuBtnKeyupTabFired = true;

  if (e.key === "Tab" && e.shiftKey) {
    globalState.closedByEvents = true; // menuPopup is previous general sibling of menuButton

    if (!mount || menuBtnEl.nextElementSibling !== containerEl) {
      e.preventDefault();
      let el = getNextTabbableElement({
        from: menuBtnEl,
        direction: "backwards",
        ignoreElement: [containerEl, focusSentinelBeforeEl, focusSentinelAfterEl]
      });

      if (el) {
        el.focus();
      }
    }

    setOpen(false);
    menuBtnEl.removeEventListener("keydown", onKeydownMenuButtonRef);
    menuBtnEl.removeEventListener("blur", onBlurMenuButtonRef);
    return;
  }

  e.preventDefault();

  if (ignoreMenuPopupWhenTabbing) {
    const el = getNextTabbableElement({
      from: menuBtnEl,
      direction: "forwards",
      ignoreElement: [containerEl, focusSentinelBeforeEl, focusSentinelAfterEl]
    });

    if (el) {
      el.focus();
    }

    setOpen(false);
    menuBtnEl.removeEventListener("keydown", onKeydownMenuButtonRef);
    menuBtnEl.removeEventListener("blur", onBlurMenuButtonRef);
    return;
  }

  let el = getNextTabbableElement({
    from: focusSentinelBeforeEl,
    stopAtRootElement: containerEl
  });

  if (el) {
    el.focus();
  } else {
    // TODO: why is this needed when next conditional queries element and focuses it
    containerEl.focus();
  }

  if (!el) {
    setOpen(false);
    el = getNextTabbableElement({
      from: focusSentinelBeforeEl
    });

    if (el) {
      el.focus();
    }
  }

  menuBtnEl.removeEventListener("keydown", onKeydownMenuButtonRef);
  menuBtnEl.removeEventListener("blur", onBlurMenuButtonRef);
};
const onFocusMenuButton = (state, e) => {
  const {
    closeWhenMenuButtonIsTabbed,
    timeouts,
    deadMenuButton,
    menuBtnEls,
    focusedMenuBtn
  } = state;
  const menuBtn = getMenuButton(menuBtnEls);
  menuBtn.addEventListener("click", state.onClickMenuButtonRef);
  menuBtn.addEventListener("blur", state.onBlurMenuButtonRef);
  menuBtn.addEventListener("keydown", state.onKeydownMenuButtonRef);
  focusedMenuBtn.el = e.currentTarget; // solution to Safari/Mac/iOS

  window.setTimeout(() => {// check if menuButton arg is an array of at least two items(buttons)
    // check if currentTarget focused
    // if yes, check if it's hidden
    // if yes, mark a variable
    // then on blur event, if that variable is true
    // if yes, check if currentTarget is hidden
    // then allow blur to continue and close stacks, rather than focus on other button bug
    // if()
  }); // TODO:

  if (deadMenuButton) {
    menuBtn.addEventListener("blur", state.onBlurMenuButtonRef);
    menuBtn.addEventListener("keydown", state.onKeydownMenuButtonRef); // globalState.addedDocumentClick = true;
    // setTimeout(() => {
    //   document.addEventListener("pointerdown", onDocumentClick, { once: true });
    // });

    return;
  }

  if (!closeWhenMenuButtonIsTabbed) {
    clearTimeout(timeouts.containerFocusTimeoutId);
  }
};
const getMenuButton = menuBtnEls => {
  if (!menuBtnEls) return undefined;
  if (menuBtnEls.length <= 1) return menuBtnEls[0];
  return menuBtnEls.find(menuBtnEl => {
    if (!menuBtnEl || hasDisplayNone(menuBtnEl)) return;
    return menuBtnEl;
  });
};
const addMenuButtonEventsAndAttributes = ({
  state,
  menuButton,
  open
}) => {
  if (Array.isArray(menuButton) && !menuButton.length) return;
  const {
    focusedMenuBtn,
    containerEl
  } = state;
  const menuBtnEls = queryElement(state, {
    inputElement: menuButton,
    type: "menuButton"
  });

  if (!menuBtnEls) {
    return;
  }

  state.menuBtnEls = Array.isArray(menuBtnEls) ? menuBtnEls : [menuBtnEls];
  const item = dismissStack.find(item => item.uniqueId === state.uniqueId);

  if (item) {
    item.menuBtnEls = state.menuBtnEls;
  } // if (state.deadMenuButton) {
  //   // deadMenuButton doesn't do anything, why is this here
  //   state.menuBtnEls.forEach((menuBtnEl) => {
  //     menuBtnEl.addEventListener("click", state.onClickMenuButtonRef);
  //     menuBtnEl.addEventListener("mousedown", state.onMouseDownMenuButtonRef);
  //     menuBtnEl.addEventListener("focus", state.onFocusMenuButtonRef);
  //     // menuBtnEl.addEventListener("blur", state.onBlurMenuButtonRef);
  //   });
  //   return;
  // }


  state.menuBtnEls.forEach((menuBtnEl, _, self) => {
    addAriaLabels(state, menuBtnEl); // menuBtnEl.removeAttribute("type");
    // menuBtnEl.setAttribute("role", 'div');
    // menuBtnEl.setAttribute("tabindex", 'div');

    menuBtnEl.addEventListener("mousedown", state.onMouseDownMenuButtonRef);
    menuBtnEl.addEventListener("focus", state.onFocusMenuButtonRef);

    if (focusedMenuBtn.el && focusedMenuBtn.el !== menuBtnEl && (self.length > 1 ? !hasDisplayNone(menuBtnEl) : true)) {
      focusedMenuBtn.el = menuBtnEl; // TODO: will fail on other stacks

      if (containerEl && containerEl.contains(document.activeElement)) return;
      menuBtnEl.focus({
        preventScroll: true
      }); // TODO:?
      // menuBtnEl!.addEventListener("keydown", state.onKeydownMenuButtonRef);
    }
  });
};

const addAriaLabels = (state, targetEl) => {
  const {
    modal,
    uniqueId,
    deadMenuButton
  } = state; // TODO: maybe just get rid of adding attributes at runtime and tell users to add it themselves

  if (!deadMenuButton) {
    if (targetEl.hasAttribute("type")) return;
    targetEl.setAttribute("type", "button");
    targetEl.setAttribute("aria-expanded", "false");
  }

  if (modal) {
    targetEl.setAttribute("aria-controls", uniqueId);
    targetEl.setAttribute("aria-haspopup", "dialog");
  }
};

const setTargetAriaExpandTrue = state => {
  const {
    menuBtnEls,
    deadMenuButton
  } = state;
  if (!deadMenuButton) return;
  if (!menuBtnEls) return;
  menuBtnEls.forEach(el => {
    el.setAttribute("aria-expanded", "true");
  });
};
const setTargetAriaExpandFalse = state => {
  const {
    menuBtnEls,
    deadMenuButton
  } = state;
  if (!deadMenuButton) return;
  if (!menuBtnEls) return;
  menuBtnEls.forEach(el => {
    el.setAttribute("aria-expanded", "false");
  });
};
const removeMenuButtonEvents = (state, isCleanup) => {
  if (!state || !state.menuBtnEls) return;
  state.menuBtnMouseDownFired = false;
  state.menuBtnEls.forEach(menuBtnEl => {
    if (isCleanup) {
      menuBtnEl.removeEventListener("blur", state.onBlurMenuButtonRef);
      menuBtnEl.removeEventListener("keydown", state.onKeydownMenuButtonRef);
      menuBtnEl.removeEventListener("click", state.onClickMenuButtonRef);
      menuBtnEl.removeEventListener("focus", state.onFocusMenuButtonRef);
      menuBtnEl.removeEventListener("mousedown", state.onMouseDownMenuButtonRef);
    }
  });
};

const getActiveMountedPopupFromSafeList = safeList => {
  if (globalState.thirdPartyPopupEl) {
    globalState.thirdPartyPopupEl = null;
    return null;
  }

  if (!document.hasFocus()) return null;
  const activeElement = globalState.clickTarget;
  const els = safeList.map(selector => document.querySelector(selector));
  const foundEl = els.find(el => el && el.contains(activeElement)) || null;
  globalState.thirdPartyPopupEl = foundEl;
  return foundEl;
};
const getFirstVisibleMountedPopupFromSafeList = safeList => {
  for (let selector of safeList) {
    const el = document.querySelector(selector);
    if (el && !isHiddenOrInvisbleShallow(el)) return el;
  }

  return null;
};
const addEventsToActiveMountedPopup = () => {
  document.addEventListener("click", onClickDocument);
  document.addEventListener("keydown", onKeyDown$1, {
    capture: true
  });
};
const removeEventsOnActiveMountedPopup = () => {
  document.removeEventListener("click", onClickDocument);
  document.removeEventListener("keydown", onKeyDown$1, {
    capture: true
  });
  globalState.thirdPartyPopupEl = null;
  globalState.thirdPartyPopupElPressedEscape = false;
};

const onClickDocument = e => {
  const target = e.target;
  const {
    thirdPartyPopupEl
  } = globalState;

  if (thirdPartyPopupEl && thirdPartyPopupEl.contains(target)) {
    return;
  }

  checkThenClose(dismissStack, item => {
    const {
      containerEl
    } = item;
    if (containerEl.contains(target)) return {
      continue: false
    };
    return {
      item,
      continue: true
    };
  }, item => {
    const {
      setOpen
    } = item;
    globalState.closedByEvents = true;
    setOpen(false);
    removeEventsOnActiveMountedPopup();
  });
};

const onKeyDown$1 = e => {
  if (e.key !== "Escape") return;
  globalState.thirdPartyPopupElPressedEscape = true;
};

let scrollEventAddedViaTouch = false;
let scrollEventAdded = false;
let pollTimeoutId = null;
let timestampOfTabkey = 0;
let cachedScrollTarget = null;
let cachedPolledElement = null;
const globalState = {
  closeByFocusSentinel: false,
  closedBySetOpen: false,
  documentClickTimeout: null,
  closedByEvents: false,
  focusedMenuBtns: new Set(),
  cursorKeysPrevEl: null,
  clickTarget: null,
  overlayMouseDown: false,
  thirdPartyPopupEl: null,
  thirdPartyPopupElPressedEscape: false
};
let runLastAfterEventsTimerId = null;
const runLastAfterEvents = () => {
  clearTimeout(runLastAfterEventsTimerId);
  runLastAfterEventsTimerId = window.setTimeout(() => {
    globalState.clickTarget = null;
  });
};
const onDocumentPointerUp = () => {
  // clearing clickTarget inside pointerup event doesn't work because the focusout events fire many tasks later. In Desktop pointerup is fine, in Chrome mobile it fires a few tasks later, in iOS it fires many many tasks later.
  // so instead its cleared inside debounced focusout callback
  // globalState.clickTarget = null;
  // runLastAfterEvents()
  document.removeEventListener("pointerup", onDocumentPointerUp);
};
const onDocumentPointerDown = e => {
  const target = e.target;
  globalState.clickTarget = target;
  document.addEventListener("pointerup", onDocumentPointerUp);
};
const onWindowBlur = e => {
  const item = dismissStack[dismissStack.length - 1]; // menuPopup item was the last tabbable item in the document and current focused item is outside of document, such as browser URL bar, then menuPopup/stacks will close

  setTimeout(() => {
    const difference = e.timeStamp - timestampOfTabkey;

    if (!document.hasFocus()) {
      if (difference < 50) {
        checkThenClose(dismissStack, item => ({
          item,
          continue: true
        }), item => {
          const {
            setOpen
          } = item;
          globalState.closedByEvents = true;
          setOpen(false);
        });
        return;
      }
    }
  });

  const onBlurWindow = item => {
    if (item.overlay || item.overlayEl) return;
    if (!item.closeWhenDocumentBlurs) return;
    const menuBtnEl = getMenuButton(item.menuBtnEls);
    menuBtnEl.focus();
    globalState.closedByEvents = true;
    item.setOpen(false);
  };

  if (item.overlay) return;
  setTimeout(() => {
    const activeElement = document.activeElement;

    if (!activeElement || activeElement.tagName !== "IFRAME") {
      checkThenClose(dismissStack, item => ({
        item,
        continue: true
      }), item => onBlurWindow(item));
      return;
    }

    checkThenClose(dismissStack, item => {
      const {
        containerEl
      } = item;

      if (containerEl.contains(activeElement)) {
        cachedPolledElement = activeElement;
        pollingIframe();
        document.addEventListener("visibilitychange", onVisibilityChange);
        return {
          continue: false
        };
      }

      return {
        item,
        continue: true
      };
    }, item => {
      const {
        setOpen
      } = item;
      globalState.closedByEvents = true;
      setOpen(false);
    });
  });
};
const onKeyDownFocusIn = e => {
  if (e.key !== "Tab") return;
  setTimeout(() => {
    const activeElement = document.activeElement;
    const stackItem = dismissStack[0];
    document.removeEventListener("keydown", onKeyDownFocusIn);

    if (stackItem && !stackItem.menuBtnEls.some(el => el && el.contains(activeElement))) {
      checkThenClose(dismissStack, item => ({
        item,
        continue: true
      }), item => {
        const {
          setOpen
        } = item; // globalState.closedByEvents = true;

        setOpen(false);
      });
    }
  });
};
const onKeyDown = e => {
  const {
    setOpen,
    menuBtnEls,
    cursorKeys,
    closeWhenEscapeKeyIsPressed,
    focusElementOnClose,
    ignoreMenuPopupWhenTabbing,
    focusSentinelAfterEl,
    focusSentinelBeforeEl,
    mountedPopupsSafeList
  } = dismissStack[dismissStack.length - 1];

  if (e.key === "Tab") {
    if (ignoreMenuPopupWhenTabbing) {
      e.preventDefault();
      const shiftKey = e.shiftKey; // TODO: work with stacks?

      const menuBtnEl = getMenuButton(menuBtnEls);
      const el = getNextTabbableElement({
        from: shiftKey ? focusSentinelBeforeEl : focusSentinelAfterEl,
        direction: shiftKey ? "backwards" : "forwards",
        ignoreElement: menuBtnEl ? [menuBtnEl] : []
      });

      if (el) {
        el.focus();
      }

      return;
    }

    timestampOfTabkey = e.timeStamp;
  }

  if (cursorKeys) {
    onCursorKeys(e);
  }

  if (e.key !== "Escape" || !closeWhenEscapeKeyIsPressed) return;

  if (globalState.thirdPartyPopupElPressedEscape) {
    globalState.thirdPartyPopupElPressedEscape = false;
    removeEventsOnActiveMountedPopup();
    return;
  }

  if (mountedPopupsSafeList && mountedPopupsSafeList.length) {
    const el = getFirstVisibleMountedPopupFromSafeList(mountedPopupsSafeList);

    if (el) {
      window.setTimeout(() => {
        if (!el.isConnected || isHiddenOrInvisbleShallow(el)) return;
        close();
      }, 100);
      return;
    }
  }

  function close() {
    const menuBtnEl = getMenuButton(menuBtnEls);
    const el = queryElement({}, {
      inputElement: focusElementOnClose,
      type: "focusElementOnClose",
      subType: "escapeKey"
    }) || menuBtnEl;

    if (el) {
      el.focus();
    }

    globalState.closedByEvents = true;
    setOpen(false);
  }

  close();
};
const onScrollClose = e => {
  const target = e.target;
  if (cachedScrollTarget === target) return;
  checkThenClose(dismissStack, item => {
    const {
      menuPopupEl
    } = item;

    if (menuPopupEl.contains(target)) {
      cachedScrollTarget = target;
      return {
        continue: false
      };
    }

    return {
      item,
      continue: true
    };
  }, item => {
    const {
      setOpen,
      focusElementOnClose,
      menuBtnEls
    } = item;
    const menuBtnEl = getMenuButton(menuBtnEls);
    globalState.closedByEvents = true;
    setOpen(false);
    const el = queryElement({}, {
      inputElement: focusElementOnClose,
      type: "focusElementOnClose",
      subType: "scrolling"
    }) || menuBtnEl;

    if (el) {
      el.focus();
    }
  });
};
const addGlobalEvents = closeWhenScrolling => {
  cachedScrollTarget = null;

  if (!scrollEventAdded && closeWhenScrolling) {
    scrollEventAdded = false;
    window.addEventListener("wheel", onScrollClose, {
      capture: true,
      passive: true
    });
    document.body.addEventListener("touchmove", onTouchMove);
  }

  if (dismissStack.length) return;
  document.addEventListener("pointerdown", onDocumentPointerDown);
  document.addEventListener("pointerup", onDocumentPointerUp);
  document.addEventListener("keydown", onKeyDown);
  window.addEventListener("blur", onWindowBlur);
};
const removeGlobalEvents = () => {
  if (dismissStack.length) return;
  scrollEventAdded = false;
  globalState.cursorKeysPrevEl = null;
  globalState.clickTarget = null; // globalState.menuBtnEl = null;

  window.clearTimeout(globalState.documentClickTimeout);
  globalState.documentClickTimeout = null;
  document.removeEventListener("keydown", onKeyDown);
  document.removeEventListener("pointerdown", onDocumentPointerDown);
  document.removeEventListener("keydown", onKeyDownFocusIn);
  window.removeEventListener("blur", onWindowBlur);
  window.removeEventListener("wheel", onScrollClose, {
    capture: true
  });
  document.body.removeEventListener("touchmove", onTouchMove);
};

const onTouchMove = () => {
  if (scrollEventAddedViaTouch) return;
  scrollEventAddedViaTouch = true;
  document.body.addEventListener("touchend", () => {
    scrollEventAddedViaTouch = false;
  }, {
    once: true
  });
  window.addEventListener("scroll", onScrollClose, {
    capture: true,
    passive: true,
    once: true
  });
};

const onCursorKeys = e => {
  const keys = ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
  const horizontalKeys = ["ArrowLeft", "ArrowRight"];
  if (!keys.includes(e.key)) return;
  e.preventDefault();
  if (horizontalKeys.includes(e.key)) return;
  const {
    menuBtnEls,
    menuPopupEl,
    containerEl,
    focusSentinelBeforeEl,
    focusSentinelAfterEl,
    cursorKeys
  } = dismissStack[dismissStack.length - 1];
  const menuBtnEl = getMenuButton(menuBtnEls);
  let activeElement = globalState.cursorKeysPrevEl || document.activeElement;
  let direction;

  if (e.key === "ArrowDown") {
    direction = "forwards";
  } else {
    direction = "backwards";
  }

  if (activeElement === menuBtnEl || activeElement === menuPopupEl || activeElement === containerEl) {
    if (e.key === "ArrowUp") {
      direction = "backwards";
      activeElement = focusSentinelAfterEl;
    } else {
      direction = "forwards";
      activeElement = focusSentinelBeforeEl;
    }
  }

  const isCursorKeysArgObj = typeof cursorKeys === "object";
  const willWrap = isCursorKeysArgObj && cursorKeys.wrap;
  let el = getNextTabbableElement({
    from: activeElement,
    direction,
    stopAtRootElement: menuPopupEl
  });

  if (!el && willWrap) {
    const from = e.key === "ArrowDown" ? focusSentinelBeforeEl : focusSentinelAfterEl;
    direction = e.key === "ArrowDown" ? "forwards" : "backwards";
    el = getNextTabbableElement({
      from,
      direction,
      stopAtRootElement: containerEl
    });
  }

  if (isCursorKeysArgObj && cursorKeys.onKeyDown) {
    cursorKeys.onKeyDown({
      currentEl: el,
      prevEl: globalState.cursorKeysPrevEl
    });
    globalState.cursorKeysPrevEl = el;
    return;
  }

  if (el) {
    el.focus();
  }
};

const onVisibilityChange = () => {
  if (document.visibilityState === "visible" && pollTimeoutId != null) {
    pollingIframe();
    return;
  }

  clearTimeout(pollTimeoutId);
}; // polls iframe to deal with edge case if menuPopup item selected is an iframe and then select another iframe that is "outside" of menuPopup


const pollingIframe = () => {
  // worst case scenerio is user has to wait for up to 250ms for menuPopup to close, while average case is 125ms
  const duration = 250;

  const poll = () => {
    const activeElement = document.activeElement;

    if (!activeElement) {
      return;
    }

    if (cachedPolledElement === activeElement) {
      pollTimeoutId = window.setTimeout(poll, duration);
      return;
    }

    checkThenClose(dismissStack, item => {
      const {
        containerEl
      } = item;

      if (activeElement.tagName === "IFRAME") {
        if (containerEl && !containerEl.contains(activeElement)) {
          return {
            item,
            continue: true
          };
        }

        cachedPolledElement = activeElement;
        pollTimeoutId = window.setTimeout(poll, duration);
        return {
          continue: false
        };
      }

      if (containerEl && !containerEl.contains(activeElement)) {
        return {
          item,
          continue: true
        };
      }

      return {
        continue: false
      };
    }, item => {
      const {
        setOpen
      } = item;
      globalState.closedByEvents = true;
      setOpen(false);
      cachedPolledElement = null;
      pollTimeoutId = null;
      document.removeEventListener("visibilitychange", onVisibilityChange);
    });
  };

  pollTimeoutId = window.setTimeout(poll, duration);
};

const addMenuPopupEl = state => {
  const {
    menuPopup
  } = state;
  if (state.menuPopupAdded) return;
  state.menuPopupEl = queryElement(state, {
    inputElement: menuPopup,
    type: "menuPopup"
  });

  if (state.menuPopupEl) {
    state.menuPopupAdded = true;
    state.menuPopupEl.setAttribute("tabindex", "-1");
  }
};
const removeMenuPopupEl = state => {
  if (!state.menuPopupEl) return;
  if (!state.menuPopupAdded) return;
  state.menuPopupEl = null;
  state.menuPopupAdded = false;
};

const camelize = s => s.replace(/-./g, x => x.toUpperCase()[1]);

const runToggleScrollbar = (state, open) => {
  const {
    onToggleScrollbar,
    removeScrollbar
  } = state;

  if (onToggleScrollbar) {
    if (open) {
      if (dismissStack.length > 1) return;
      onToggleScrollbar.onRemove();
    } else {
      if (dismissStack.length) return;
      onToggleScrollbar.onRestore();
    }

    return;
  }

  if (!removeScrollbar) return;
  if (dismissStack.length > 1) return;
  const el = document.scrollingElement;

  if (open) {
    el.style.overflow = "hidden";
  } else {
    el.style.overflow = "";
  }
};

function nextFrame(fn) {
  requestAnimationFrame(() => {
    requestAnimationFrame(fn);
  });
}

const Transition = props => {
  let el;
  let first = true;
  let isPortal = false;
  let portalMarker;
  let isExiting = false;
  let hasOverlayAnimation = !!props.overlay;
  const [s1, set1] = createSignal();
  const [s2, set2] = createSignal();
  const resolved = children(() => props.children);
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit,
    appendToElement,
    appear,
    state
  } = props;
  const {
    onBeforeEnter: onBeforeEnterOverlay,
    onEnter: onEnterOverlay,
    onAfterEnter: onAfterEnterOverlay,
    onBeforeExit: onBeforeExitOverlay,
    onExit: onExitOverlay,
    onAfterExit: onAfterExitOverlay,
    appendToElement: appendToElementOverlay
  } = props.overlay || {};

  const createOnBeforeEnter = type => type === "content" ? onBeforeEnter : onBeforeEnterOverlay;

  const createOnEnter = type => type === "content" ? onEnter : onEnterOverlay;

  const createOnAfterEnter = type => type === "content" ? onAfterEnter : onAfterEnterOverlay;

  const createOnBeforeExit = type => type === "content" ? onBeforeExit : onBeforeExitOverlay;

  const createOnExit = type => type === "content" ? onExit : onExitOverlay;

  const createOnAfterExit = type => type === "content" ? onAfterExit : onAfterExitOverlay;

  function getClassState(animatedElType, type) {
    const getName = () => {
      return animatedElType === "content" ? props.name : props.overlay?.name;
    };

    const name = getName() || "s";
    const propStr = camelize(type) + "Class";
    const classAnimationStates = animatedElType === "content" ? props : props.overlay; // @ts-ignore

    const classState = classAnimationStates[propStr];
    return classState ? classState.split(" ") : [`${name}-${type}`];
  }

  const getElement = (type, el) => {
    const appendToElement_ = type === "content" ? appendToElement : appendToElementOverlay;

    if (appendToElement_) {
      if (appendToElement_ === "menuPopup" && type !== "overlay") {
        return queryElement({
          containerEl: el
        }, {
          inputElement: null,
          type: "menuPopup"
        });
      }

      return typeof appendToElement_ === "string" ? el && el.querySelector(appendToElement_) : appendToElement_;
    }

    return el;
  };

  let endExitTransitionRef;
  let endExitTransitionOverlayRef;

  function enterTransition(type, _el, prev) {
    // TODO: refactor this
    if (isExiting) {
      if (type === "content") {
        endExitTransitionRef();
      } else {
        endExitTransitionOverlayRef();
      }
    }

    if (!first || props.appear) {
      const onEnter = createOnEnter(type);
      const onBeforeEnter = createOnBeforeEnter(type);
      const onAfterEnter = createOnAfterEnter(type);
      const enterClasses = getClassState(type, "enter");
      const enterActiveClasses = getClassState(type, "enter-active");
      const enterToClasses = getClassState(type, "enter-to");
      const el = getElement(type, _el);
      onBeforeEnter && onBeforeEnter(el);
      el.classList.add(...enterClasses);
      el.classList.add(...enterActiveClasses);
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          el.classList.remove(...enterClasses);
          el.classList.add(...enterToClasses);
        });
        onEnter && onEnter(el, () => endTransition());
        requestAnimationFrame(() => {
          if (!onEnter || onEnter.length < 2) {
            el.addEventListener("transitionend", endTransition);
            el.addEventListener("animationend", endTransition);
          }
        });
      });

      function endTransition(e) {
        if (el && (!e || e.target === el)) {
          el.removeEventListener("transitionend", endTransition);
          el.removeEventListener("animationend", endTransition);
          el.classList.remove(...enterActiveClasses);
          el.classList.remove(...enterToClasses);
          batch(() => {
            const el_ = isPortal ? portalMarker : _el;
            s1() !== el_ && set1(el_);
            s2() === el_ && set2(undefined);
          });
          onAfterEnter && onAfterEnter(el);
          if (props.mode === "inout") exitTransition(type, el, prev);
        }
      }
    }

    if (type === "content") {
      const el_ = isPortal ? portalMarker : _el;
      prev && !props.mode ? set2(el_) : set1(el_);
    }
  }

  function exitTransition(type, _el, _prev) {
    isExiting = true;
    const onExit = createOnExit(type);
    const onBeforeExit = createOnBeforeExit(type);
    const onAfterExit = createOnAfterExit(type);
    const exitClasses = getClassState(type, "exit");
    const exitActiveClasses = getClassState(type, "exit-active");
    const exitToClasses = getClassState(type, "exit-to");
    const el = getElement(type, _el);
    const prev = getElement(type, _prev);
    if (!prev.parentNode) return endTransition();
    onBeforeExit && onBeforeExit(prev);
    prev.classList.add(...exitClasses);
    prev.classList.add(...exitActiveClasses);
    nextFrame(() => {
      prev.classList.remove(...exitClasses);
      prev.classList.add(...exitToClasses);
    });
    onExit && onExit(prev, () => endTransition());

    if (!onExit || onExit.length < 2) {
      prev.addEventListener("transitionend", endTransition);
      prev.addEventListener("animationend", endTransition);
    }

    function endTransition(e) {
      if (!e || e.target === prev) {
        isExiting = false;
        prev.removeEventListener("transitionend", endTransition);
        prev.removeEventListener("animationend", endTransition);

        if (type === "content") {
          prev.classList.remove(...exitActiveClasses);
          prev.classList.remove(...exitToClasses);
        }

        if (type === "content") {
          if (isPortal) {
            // @ts-ignore
            _prev.parentElement.remove();

            runToggleScrollbar(state, false);
          }

          s1() === _prev && set1(undefined);
        }

        onAfterExit && onAfterExit(prev);
        if (props.mode === "outin") enterTransition(type, el, prev);
      }
    }

    if (type === "content") {
      endExitTransitionRef = endTransition;
    } else {
      endExitTransitionOverlayRef = endTransition;
    }
  }

  createComputed(prev => {
    el = resolved();

    while (typeof el === "function") el = el();

    if (el && el.nodeType === 3) {
      isPortal = true;
      portalMarker = el; // @ts-ignore

      portalMarker.willRemove = false; // @ts-ignore

      const portalContainerChild = el["portalContainerChild"];

      if (hasOverlayAnimation) {
        // @ts-ignore
        const overlayChildren = el["portalOverlay"];
        Object.defineProperty(portalContainerChild, "portalOverlay", {
          get() {
            return overlayChildren;
          },

          configurable: true
        });
      }

      el = portalContainerChild;
    }

    return untrack(() => {
      if (el && el !== prev) {
        if (props.mode !== "outin") {
          enterTransition("content", el, prev);

          if (hasOverlayAnimation) {
            enterTransition("overlay", // @ts-ignore
            el.portalOverlay, // @ts-ignore
            prev && prev.portalOverlay);
          }
        } else if (first) {
          const _el = isPortal ? portalMarker : el;

          set1(_el);
        }
      }

      if (prev && prev !== el && props.mode !== "inout") {
        exitTransition("content", el, prev);

        if (hasOverlayAnimation) {
          // @ts-ignore
          exitTransition("overlay", el && el.portalOverlay, prev.portalOverlay);
        }
      }

      first = false;
      return el;
    });
  });
  return [s1, s2];
};

const removeLocalEvents = (state, {
  isCleanup = false
} = {}) => {
  removeMenuButtonEvents(state, isCleanup);
};

const onFocusOutContainer = (state, e) => {
  const {
    overlayElement,
    trapFocus,
    timeouts,
    closeWhenDocumentBlurs,
    mountedPopupsSafeList
  } = state;
  timeoutFocusOutFired = false;
  queueMicrotask(() => {
    runLastAfterEvents();
  });

  if (globalState.thirdPartyPopupEl) {
    removeEventsOnActiveMountedPopup();
  }

  if (globalState.closedBySetOpen) return;
  if (globalState.overlayMouseDown) return;
  if (overlayElement && trapFocus) return;
  if (!closeWhenDocumentBlurs && !document.hasFocus()) return;
  const dismissStackLength = dismissStack.length;
  setTimeoutFocusOut(timeouts, () => {
    if (mountedPopupsSafeList) {
      if (getActiveMountedPopupFromSafeList(mountedPopupsSafeList)) {
        addEventsToActiveMountedPopup();
        return;
      }
    } // fixes issue where race condition of new item mounts before timeout focusout fires
    // therefore focused item which is menuButton, the new container doesn't contain, so removes stack


    if (dismissStackLength < dismissStack.length) return;
    globalState.closedByEvents = true;
    checkThenClose(dismissStack, item => {
      const {
        containerEl,
        closeWhenClickingOutside
      } = item;
      const clickTarget = globalState.clickTarget;

      if (!closeWhenClickingOutside && clickTarget) {
        document.addEventListener("keydown", onKeyDownFocusIn);
        return {
          continue: false
        };
      }

      if (clickTarget && containerEl.contains(clickTarget)) {
        return {
          continue: false
        };
      }

      if (containerEl.contains(document.activeElement)) {
        return {
          continue: false
        };
      }

      return {
        item,
        continue: true
      };
    }, item => {
      const {
        setOpen
      } = item;
      setOpen(false);
    });
  });
};
const onFocusInContainer = (state, e) => {
  const {
    timeouts
  } = state;
  clearTimeout(timeouts.containerFocusTimeoutId);
  clearTimeout(timeouts.menuButtonBlurTimeoutId);
};
const runFocusOnActive = state => {
  const {
    focusElementOnOpen,
    focusedMenuBtn
  } = state;

  if (focusElementOnOpen == null) {
    return;
  }

  const el = queryElement(state, {
    inputElement: focusElementOnOpen,
    type: "focusElementOnOpen"
  });

  if (el) {
    setTimeout(() => {
      const preventScroll = isObjectLiteral(focusElementOnOpen) ? // @ts-ignore
      !!focusElementOnOpen.preventScroll : el === state.menuPopupEl;
      el.focus({
        preventScroll
      });
      focusedMenuBtn.el = null;
    });
  }
};
let timeoutFocusOutFired = false;

const setTimeoutFocusOut = (timeouts, cb) => {
  timeouts.containerFocusTimeoutId = window.setTimeout(() => {
    if (timeoutFocusOutFired) return;
    timeoutFocusOutFired = true;
    cb();
  });
};

const onMouseDownOverlay = () => {
  globalState.overlayMouseDown = true;
};
const onMouseUpOverlay = () => {
  globalState.overlayMouseDown = false;
};
const onClickOverlay = state => {
  const {
    closeWhenOverlayClicked,
    menuPopupEl,
    focusElementOnClose,
    menuBtnEls
  } = state;
  globalState.overlayMouseDown = false;

  if (!closeWhenOverlayClicked) {
    menuPopupEl.focus({
      preventScroll: true
    });
    return;
  }

  const menuBtnEl = getMenuButton(menuBtnEls);
  const el = queryElement(state, {
    inputElement: focusElementOnClose,
    type: "focusElementOnClose",
    subType: "click"
  }) || menuBtnEl;

  if (el) {
    el.focus();
  }

  checkThenClose(dismissStack, item => {
    if (item.overlayElement) return {
      continue: false
    };
    return {
      item,
      continue: true
    };
  }, item => {
    const {
      setOpen
    } = item;
    globalState.closedByEvents = true;
    setOpen(false);
  });
  globalState.closedByEvents = true;
  state.setOpen(false);
};

const matchByFirstChild = ({
  parent,
  matchEl
}) => {
  if (parent === matchEl) return true;

  const query = el => {
    if (!el) return false;
    const child = el.children[0];

    if (child === matchEl) {
      return true;
    }

    return query(child);
  };

  return query(parent);
};

const activateLastFocusSentinel = state => {
  const {
    enableLastFocusSentinel,
    menuBtnEls,
    containerEl,
    focusSentinelAfterEl
  } = state; // Before
  // if (enableLastFocusSentinel) return;

  if (enableLastFocusSentinel) {
    focusSentinelAfterEl.setAttribute("tabindex", "0");
    return;
  }

  if (!menuBtnEls) return;
  const menuBtnEl = getMenuButton(menuBtnEls);
  const menuBtnSibling = menuBtnEl.nextElementSibling;
  if (matchByFirstChild({
    parent: menuBtnSibling,
    matchEl: containerEl
  })) return;
  focusSentinelAfterEl.setAttribute("tabindex", "0");
};
const onFocusSentinel = (state, type, relatedTarget) => {
  const {
    uniqueId,
    containerEl,
    menuBtnEls,
    focusSentinelBeforeEl,
    trapFocus,
    focusSentinelAfterEl,
    closeWhenMenuButtonIsTabbed,
    focusElementOnClose,
    mount,
    open,
    setOpen
  } = state;
  const menuBtnEl = getMenuButton(menuBtnEls);
  dismissStack.forEach(item => window.clearTimeout(item.timeouts.containerFocusTimeoutId));

  const runIfMounted = (el, isFirst) => {
    checkThenClose(dismissStack, item => {
      if (isFirst) {
        if (getMenuButton(item.menuBtnEls) === el && !item.closeWhenMenuButtonIsTabbed) {
          return {
            continue: false
          };
        }
      }

      if (item.uniqueId === uniqueId || !item.containerEl.contains(el)) {
        return {
          item,
          continue: true
        };
      }

      return {
        continue: false
      };
    }, item => {
      globalState.closedByEvents = true;
      item.setOpen(false);
    });

    if (el) {
      el.focus();
    }
  };

  if (!open()) return;

  if (menuBtnEl && (relatedTarget === containerEl || relatedTarget === menuBtnEl)) {
    const el = getNextTabbableElement({
      from: focusSentinelBeforeEl,
      direction: "forwards",
      stopAtRootElement: containerEl
    });
    el.focus();
    return;
  }

  if (type === "before") {
    if (trapFocus) {
      const el = getNextTabbableElement({
        from: focusSentinelAfterEl,
        direction: "backwards",
        stopAtRootElement: containerEl
      });
      el.focus();
      return;
    }

    if (closeWhenMenuButtonIsTabbed) {
      globalState.closedByEvents = true;
      setOpen(false);
      menuBtnEl.focus();
      return;
    }

    const el = queryElement(state, {
      inputElement: focusElementOnClose,
      type: "focusElementOnClose",
      subType: "tabBackwards"
    }) || menuBtnEl; // conditional and early return just for no button feature

    if (!state.menuBtnEls) {
      // this wasn't here before
      el.focus();
      return;
    } // this wasn't wrapped with mount condition when it should be
    // if (mount) {


    runIfMounted(el, true); // }
    // so

    return;
  }

  if (trapFocus) {
    const el = getNextTabbableElement({
      from: focusSentinelBeforeEl,
      stopAtRootElement: containerEl
    });
    el.focus();
    return;
  }

  const el = queryElement(state, {
    inputElement: focusElementOnClose,
    type: "focusElementOnClose",
    subType: "tabForwards"
  }) || getNextTabbableElement({
    from: menuBtnEl,
    ignoreElement: [containerEl]
  });

  if (mount) {
    runIfMounted(el);
    return;
  }

  if (el) {
    el.focus();
  }

  globalState.closedByEvents = true;
  setOpen(false);
};

const SVG_NAMESPACE = "http://www.w3.org/2000/svg";

function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}

function CustomPortal(props) {
  const {
    useShadow,
    isModal
  } = props,
        marker = document.createTextNode(""),
        mount = props.mount || document.body; // don't render when hydrating

  function renderPortal() {
    if (sharedConfig.context) {
      const [s, set] = createSignal(false);
      queueMicrotask(() => set(true));
      return () => s() && props.children;
    } else return () => props.children;
  }

  if (mount instanceof HTMLHeadElement) {
    const [clean, setClean] = createSignal(false);

    const cleanup = () => setClean(true);

    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));
    onCleanup(() => {
      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();
    });
  } else {
    const container = createElement(props.isSVG ? "g" : "div", props.isSVG),
          renderRoot = useShadow && container.attachShadow ? container.attachShadow({
      mode: "open"
    }) : container;
    const containerObjectValue = {
      get() {
        return marker.parentNode;
      },

      configurable: true
    };
    Object.defineProperty(container, "host", containerObjectValue);
    Object.defineProperty(container, "_$host", containerObjectValue); // will be "_$portalContainerChild"

    Object.defineProperty(marker, "portalContainerChild", {
      get() {
        if (overlayChildren) {
          return container.children[1];
        } // return container.querySelector('[role="dialog"]');


        return container.firstElementChild;
      },

      configurable: true
    });
    Object.defineProperty(marker, "portalContainer", {
      get() {
        return container;
      },

      configurable: true
    });
    Object.defineProperty(marker, "portalMount", {
      get() {
        return mount;
      },

      configurable: true
    }); // @ts-ignore

    marker.willRemove = true;
    insert(renderRoot, renderPortal());
    const overlayChildren = props.overlayChildren;

    if (overlayChildren) {
      // Object.defineProperty(containerFirstChild, "portalOverlay", {
      //   get() {
      //     return overlayChildren;
      //   },
      //   configurable: true,
      // });
      Object.defineProperty(marker, "portalOverlay", {
        get() {
          return overlayChildren;
        },

        configurable: true
      });
      container.insertAdjacentElement("afterbegin", overlayChildren);
    }

    mount.appendChild(container);
    props.ref && props.ref(container);
    onCleanup(() => {
      // @ts-ignore
      if (!marker.willRemove) return;
      mount.removeChild(container);
    });
  }

  return marker;
}

var _tmpl$ = /*#__PURE__*/template(`<div role=presentation>`),
    _tmpl$2 = /*#__PURE__*/template(`<div><div style=position:fixed;top:0;left:0;outline:none;pointer-events:none;width:0;height:0; aria-hidden=true></div><div style=position:fixed;top:0;left:0;outline:none;pointer-events:none;width:0;height:0; aria-hidden=true>`);
/**
 * ### Notes
 *
 * In documentation, for menuButton ref, use `createSignal` from now on. Users get to place Dismiss JSX anywhere (including before button element), and pass accessor to their custom Dismiss hooks without any issues.
 *
 * When using modals, inform users they must use `roll="dialog"`
 *
 */

/**
 *
 * Handles "click outside" behavior for button popup pairings. Closing is triggered by click/focus outside of popup element or pressing "Escape" key.
 */
const Dismiss = props => {
  const modal = props.modal || false;
  const {
    id,
    menuButton,
    menuPopup,
    focusElementOnClose,
    focusElementOnOpen = modal ? "menuPopup" : undefined,
    focusMenuButtonOnMouseDown = true,
    cursorKeys = false,
    closeWhenMenuButtonIsTabbed = false,
    closeWhenMenuButtonIsClicked = true,
    closeWhenScrolling = false,
    closeWhenDocumentBlurs = false,
    closeWhenOverlayClicked = true,
    closeWhenEscapeKeyIsPressed = true,
    closeWhenClickingOutside = true,
    overlay = modal,
    overlayElement = modal,
    trapFocus = modal,
    removeScrollbar = modal,
    enableLastFocusSentinel = false,
    mount = modal ? "body" : undefined,
    // stopComponentEventPropagation = false,
    show = false,
    onToggleScrollbar,
    onOpen,
    deadMenuButton,
    ignoreMenuPopupWhenTabbing,
    mountedPopupsSafeList
  } = props;
  const state = {
    mount,
    modal,
    addedFocusOutAppEvents: false,
    closeWhenOverlayClicked,
    closeWhenDocumentBlurs,
    closeWhenEscapeKeyIsPressed,
    closeWhenMenuButtonIsClicked,
    closeWhenMenuButtonIsTabbed,
    closeWhenScrolling,
    closeWhenClickingOutside,
    cursorKeys,
    focusElementOnClose,
    focusMenuButtonOnMouseDown,
    deadMenuButton,
    focusElementOnOpen,
    ignoreMenuPopupWhenTabbing,
    // @ts-ignore
    id,
    uniqueId: createUniqueId(),
    menuBtnId: "",
    focusedMenuBtn: {
      el: null
    },
    menuBtnKeyupTabFired: false,
    menuButton,
    timeouts: {
      containerFocusTimeoutId: null,
      menuButtonBlurTimeoutId: null
    },
    upperStackRemovedByFocusOut: false,
    menuPopup,
    closeByDismissEvent: false,
    menuPopupAdded: false,
    enableLastFocusSentinel,
    overlay,
    overlayElement,
    onToggleScrollbar,
    removeScrollbar,
    trapFocus,
    hasFocusSentinels: !!focusElementOnClose || overlay || !!overlayElement || trapFocus || enableLastFocusSentinel,
    mountedPopupsSafeList,
    open: props.open,
    setOpen: props.setOpen,
    onClickOutsideMenuButtonRef: () => onClickOutsideMenuButton(state),
    onClickOverlayRef: () => onClickOverlay(state),
    onFocusInContainerRef: e => onFocusInContainer(state),
    onFocusOutContainerRef: e => onFocusOutContainer(state),
    onBlurMenuButtonRef: e => onBlurMenuButton(state, e),
    onClickMenuButtonRef: e => onClickMenuButton(state, e),
    onMouseDownMenuButtonRef: e => onMouseDownMenuButton(state, e),
    onFocusMenuButtonRef: e => onFocusMenuButton(state, e),
    onKeydownMenuButtonRef: e => onKeydownMenuButton(state, e),
    refContainerCb: el => {
      if (overlayElement) {
        el.style.zIndex = "1000";

        if (modal) {
          el.style.pointerEvents = "none";
          el.style.position = "relative";

          const setDialogElStyle = el => {
            // TODO if it already has id, then update button with aria-controls value
            if (!el.id) {
              el.id = state.uniqueId;
            }

            el.style.pointerEvents = "all";
            el.setAttribute("role", "dialog");
          }; // setDialogElStyle(el);


          requestAnimationFrame(() => {
            const dialog = el.querySelector('[role="dialog"]');

            if (!dialog) {
              const children = el.children;
              if (!children) return;
              const dialog = children[1]; // const child = children[1];
              // const dialog = child.firstElementChild as HTMLElement;

              setDialogElStyle(dialog);
              return;
            }

            setDialogElStyle(dialog);
          });
        }
      }

      if (props.ref) {
        // @ts-ignore
        props.ref(el);
      }

      state.containerEl = el;
    },
    refOverlayCb: el => {
      el.style.position = "fixed";
      el.style.top = "0";
      el.style.left = "0";
      el.style.width = "100%";
      el.style.height = "calc(100% + 100px)";
      el.style.zIndex = "1000";

      if (typeof overlayElement === "object" && overlayElement.ref) {
        overlayElement.ref(el);
      }

      state.overlayEl = el;
    }
  };
  const initDefer = !props.open();

  const resetFocusOnClose = () => {
    const activeElement = document.activeElement;

    if (activeElement !== document.body) {
      if (state.menuBtnEls.every(menuBtnEl => activeElement !== menuBtnEl) && !state.containerEl?.contains(activeElement)) {
        return;
      }
    }

    const {
      menuBtnEls,
      focusedMenuBtn,
      timeouts
    } = state;
    const menuBtnEl = getMenuButton(menuBtnEls);
    const el = queryElement(state, {
      inputElement: focusElementOnClose,
      type: "focusElementOnClose",
      subType: "click"
    }) || menuBtnEl;

    if (el) {
      el.focus();
    }
  };

  const getMountNode = () => {
    return typeof mount === "string" ? document.querySelector(mount) : mount;
  };

  const programmaticRemoval = () => {
    if (globalState.closedByEvents) return;
    const activeElement = document.activeElement;

    if ( // activeElement !== state.menuBtnEls
    state.menuBtnEls.every(menuBtnEl => activeElement !== menuBtnEl) && !state.containerEl?.contains(activeElement)) {
      setTimeout(() => {
        globalState.closedBySetOpen = false;
      });
      return;
    }

    if (!globalState.closedBySetOpen) {
      globalState.closedBySetOpen = true;
      setTimeout(() => {
        globalState.closedBySetOpen = false;
        resetFocusOnClose();
      });
    }
  };

  createComputed(on(() => !!props.open(), (open, prevOpen) => {
    if (open === prevOpen) return;

    if (!open) {
      if (state.focusSentinelAfterEl) {
        state.focusSentinelAfterEl.tabIndex = -1;
      }

      programmaticRemoval();
    }
  }, {
    defer: initDefer
  }));
  createEffect(on(() => typeof props.menuButton === "function" ? props.menuButton() : props.menuButton, menuButton => {
    addMenuButtonEventsAndAttributes({
      state,
      menuButton,
      open: props.open
    });
    onCleanup(() => {
      if (!state || isServer) return; // removeMenuButtonEvents(state, true);
    });
  }));
  createEffect(on(() => !!props.open(), (open, prevOpen) => {
    if (open === prevOpen) return;

    if (open) {
      globalState.closedByEvents = false;
      addMenuPopupEl(state);
      runFocusOnActive(state);
      setTargetAriaExpandTrue(state);
      addGlobalEvents(closeWhenScrolling);
      addDismissStack({
        // @ts-ignore
        id,
        uniqueId: state.uniqueId,
        open: props.open,
        setOpen: props.setOpen,
        containerEl: state.containerEl,
        menuBtnEls: state.menuBtnEls,
        focusedMenuBtn: state.focusedMenuBtn,
        overlayEl: state.overlayEl,
        menuPopupEl: state.menuPopupEl,
        overlay,
        closeWhenDocumentBlurs,
        closeWhenEscapeKeyIsPressed,
        closeWhenMenuButtonIsTabbed,
        closeWhenClickingOutside,
        overlayElement,
        cursorKeys,
        focusElementOnClose,
        focusSentinelBeforeEl: state.focusSentinelBeforeEl,
        focusSentinelAfterEl: state.focusSentinelAfterEl,
        ignoreMenuPopupWhenTabbing,
        upperStackRemovedByFocusOut: false,
        detectIfMenuButtonObscured: false,
        queueRemoval: false,
        mountedPopupsSafeList: state.mountedPopupsSafeList,
        timeouts: state.timeouts
      });
      onOpen && onOpen(open, {
        uniqueId: state.uniqueId,
        dismissStack
      });
      runToggleScrollbar(state, open);
      activateLastFocusSentinel(state);
    } else {
      setTargetAriaExpandFalse(state); // TODO?:

      globalState.closedByEvents = false;
      removeLocalEvents(state);
      removeMenuPopupEl(state);
      removeDismissStack(state.uniqueId);
      removeGlobalEvents();
      removeEventsOnActiveMountedPopup();
      onOpen && onOpen(open, {
        uniqueId: state.uniqueId,
        dismissStack
      });

      if (!props.animation) {
        runToggleScrollbar(state, open);
      }
    }
  }, {
    defer: initDefer
  }));
  onCleanup(() => {
    if (isServer) return;
    removeLocalEvents(state, {
      isCleanup: true
    });
    removeMenuPopupEl(state);
    removeDismissStack(state.uniqueId);
    removeGlobalEvents();
  });

  function renderOverlay() {
    if (typeof props.overlayElement === "object" && props.overlayElement.element) {
      return props.overlayElement.element;
    }

    return (() => {
      var _el$ = _tmpl$();

      var _ref$ = state.refOverlayCb;
      typeof _ref$ === "function" ? use(_ref$, _el$) : state.refOverlayCb = _el$;

      addEventListener(_el$, "mouseup", onMouseUpOverlay, true);

      addEventListener(_el$, "mousedown", onMouseDownOverlay, true);

      addEventListener(_el$, "click", state.onClickOverlayRef, true);

      effect(_p$ => {
        var _v$ = typeof props.overlayElement === "object" ? props.overlayElement.class : undefined,
            _v$2 = typeof props.overlayElement === "object" ? props.overlayElement.classList || {} : {};

        _v$ !== _p$.e && className(_el$, _p$.e = _v$);
        _p$.t = classList(_el$, _v$2, _p$.t);
        return _p$;
      }, {
        e: undefined,
        t: undefined
      });

      return _el$;
    })();
  }

  function render(children) {
    return (() => {
      var _el$2 = _tmpl$2(),
          _el$3 = _el$2.firstChild,
          _el$4 = _el$3.nextSibling;

      var _ref$2 = state.refContainerCb;
      typeof _ref$2 === "function" ? use(_ref$2, _el$2) : state.refContainerCb = _el$2;

      addEventListener(_el$2, "focusout", state.onFocusOutContainerRef, true);

      addEventListener(_el$2, "focusin", state.onFocusInContainerRef, true);

      var _ref$3 = state.focusSentinelBeforeEl;
      typeof _ref$3 === "function" ? use(_ref$3, _el$3) : state.focusSentinelBeforeEl = _el$3;

      _el$3.addEventListener("focus", e => {
        onFocusSentinel(state, "before", e.relatedTarget);
      });

      insert(_el$2, children, _el$4);

      var _ref$4 = state.focusSentinelAfterEl;
      typeof _ref$4 === "function" ? use(_ref$4, _el$4) : state.focusSentinelAfterEl = _el$4;

      _el$4.addEventListener("focus", () => {
        onFocusSentinel(state, "after");
      });

      effect(_p$ => {
        var _v$3 = state.id,
            _v$4 = props.class,
            _v$5 = props.classList || {},
            _v$6 = props.open() ? "0" : "-1",
            _v$7 = props.open() && state.hasFocusSentinels ? "0" : "-1";

        _v$3 !== _p$.e && setAttribute(_el$2, "id", _p$.e = _v$3);
        _v$4 !== _p$.t && className(_el$2, _p$.t = _v$4);
        _p$.a = classList(_el$2, _v$5, _p$.a);
        _v$6 !== _p$.o && setAttribute(_el$3, "tabindex", _p$.o = _v$6);
        _v$7 !== _p$.i && setAttribute(_el$4, "tabindex", _p$.i = _v$7);
        return _p$;
      }, {
        e: undefined,
        t: undefined,
        a: undefined,
        o: undefined,
        i: undefined
      });

      return _el$2;
    })();
  }

  if (show) return render(props.children); // basically <Show>
  // why custom Show??

  let strictEqual = false;
  const condition = createMemo(() => props.open(), false, {
    equals: (a, b) => strictEqual ? a === b : !a === !b
  });
  const finalRender = createMemo(() => {
    const c = condition();

    if (c) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      strictEqual = fn;
      return fn ? untrack(() => child(c)) : mount ? createComponent(CustomPortal, {
        get mount() {
          return getMountNode();
        },

        get overlayChildren() {
          return overlayElement ? renderOverlay() : null;
        },

        get children() {
          return render(child);
        }

      }) : render(child);
    }
  });

  if (props.animation) {
    return createComponent(Transition, mergeProps(() => props.animation, {
      get name() {
        return props.animation.name;
      },

      get enterClass() {
        return props.animation.enterClass;
      },

      get enterActiveClass() {
        return props.animation.enterActiveClass;
      },

      get enterToClass() {
        return props.animation.enterToClass;
      },

      get exitClass() {
        return props.animation.exitClass;
      },

      get exitActiveClass() {
        return props.animation.exitActiveClass;
      },

      get exitToClass() {
        return props.animation.exitToClass;
      },

      get appear() {
        return props.animation.appear;
      },

      get overlay() {
        return typeof props.overlayElement === "object" ? props.overlayElement.animation : undefined;
      },

      state: state,

      get children() {
        return finalRender();
      }

    }));
  }

  return finalRender;
};

delegateEvents(["click", "mousedown", "mouseup", "focusin", "focusout"]);

export { Dismiss as default, getNextTabbableElement };
//# sourceMappingURL=index.js.map
