import { $PROXY, $TRACK, createRoot, createSignal, createMemo, untrack } from 'solid-js';
import { unwrap } from 'solid-js/store';
import { createLazyMemo } from '@solid-primitives/memo';
import { isServer, isDev } from 'solid-js/web';

// src/track-deep.ts
function trackDeep(store) {
  traverse(store, /* @__PURE__ */ new Set());
  return store;
}
function traverse(value, seen) {
  let isArray;
  let proto;
  if (value != null && typeof value === "object" && !seen.has(value) && ((isArray = Array.isArray(value)) || value[$PROXY] || !(proto = Object.getPrototypeOf(value)) || proto === Object.prototype)) {
    seen.add(value);
    for (const child of isArray ? value : Object.values(value))
      traverse(child, seen);
  }
}
var deepTrack = trackDeep;
var EQUALS_FALSE = { equals: false };
var TrackStoreCache = /* @__PURE__ */ new WeakMap();
var TrackVersion = 0;
function getTrackStoreNode(node) {
  let track = TrackStoreCache.get(node);
  if (!track) {
    createRoot(() => {
      const unwrapped = unwrap(node);
      let is_reading = false;
      let is_stale = true;
      let version = 0;
      const [signal, trigger] = createSignal(void 0, EQUALS_FALSE);
      const memo = createMemo(
        () => {
          if (is_reading) {
            node[$TRACK];
            for (const [key, child] of Object.entries(unwrapped)) {
              let childNode;
              if (child != null && typeof child === "object" && ((childNode = child[$PROXY]) || $TRACK in (childNode = untrack(() => node[key])))) {
                getTrackStoreNode(childNode)?.();
              }
            }
          } else {
            signal();
            is_stale = true;
          }
        },
        void 0,
        EQUALS_FALSE
      );
      track = () => {
        is_reading = true;
        if (is_stale) {
          trigger();
          is_stale = false;
        }
        const already_tracked = version === TrackVersion;
        version = TrackVersion;
        already_tracked || memo();
        is_reading = false;
      };
      TrackStoreCache.set(node, track);
    });
  }
  return track;
}
function trackStore(store) {
  TrackVersion++;
  $TRACK in store && getTrackStoreNode(store)?.();
  return store;
}
function* entries(obj) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      yield [i, obj[i]];
    }
  } else {
    yield* Object.entries(obj)[Symbol.iterator]();
  }
}
var StoreNodeChildrenCache = /* @__PURE__ */ new WeakMap();
function getStoreNodechildren(node) {
  let signal = StoreNodeChildrenCache.get(node);
  if (!signal) {
    const unwrapped = unwrap(node), isArray = Array.isArray(unwrapped);
    signal = createRoot(
      () => createLazyMemo(() => {
        node[$TRACK];
        const children = isArray ? [] : {};
        for (const [key, child] of entries(unwrapped)) {
          let childNode;
          if (child != null && typeof child === "object" && ((childNode = child[$PROXY]) || (childNode = untrack(() => node[key])) && $TRACK in childNode)) {
            children[key] = childNode;
          }
        }
        return children;
      })
    );
    StoreNodeChildrenCache.set(node, signal);
  }
  return signal();
}
var CurrentUpdates;
var SeenNodes;
function newCacheNode(children) {
  const record = { ...children };
  for (const [key, node] of entries(children)) {
    if (SeenNodes.has(node))
      continue;
    SeenNodes.add(node);
    record[key] = newCacheNode(getStoreNodechildren(node));
  }
  return { children, record };
}
function compareStoreWithCache(node, parent, key, path) {
  if (SeenNodes.has(node))
    return;
  SeenNodes.add(node);
  const cacheNode = parent[key], children = getStoreNodechildren(node);
  if (cacheNode && children === cacheNode.children) {
    for (const [key2, child] of entries(children)) {
      compareStoreWithCache(child, cacheNode.record, key2, [...path, key2]);
    }
  } else {
    parent[key] = newCacheNode(children);
    CurrentUpdates.push({ path, value: node });
  }
}
function captureStoreUpdates(store) {
  if (isServer || !($TRACK in store)) {
    if (isDev) {
      console.warn("createStoreDelta expects a store, got", store);
    }
    let init = true;
    return () => init ? (init = false, [{ path: [], value: store }]) : [];
  }
  const cache = {};
  return () => {
    CurrentUpdates = [];
    SeenNodes = /* @__PURE__ */ new WeakSet();
    compareStoreWithCache(store, cache, "root", []);
    return CurrentUpdates;
  };
}

export { captureStoreUpdates, deepTrack, trackDeep, trackStore };
