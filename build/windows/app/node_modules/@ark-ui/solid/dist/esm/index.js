import { createContext as createContext$1, useContext, splitProps, Show, createSignal, createMemo, createUniqueId, createEffect, untrack, children, Index, For } from 'solid-js';
import { createComponent, Dynamic, mergeProps, memo, use, template, insert, effect, spread } from 'solid-js/web';
import { mergeProps as mergeProps$1, useMachine, normalizeProps, useActor } from '@zag-js/solid';
import * as collapsible$1 from '@zag-js/collapsible';
export { anatomy as collapsibleAnatomy } from '@zag-js/collapsible';
import * as accordion$1 from '@zag-js/accordion';
export { anatomy as accordionAnatomy } from '@zag-js/accordion';
import * as avatar$1 from '@zag-js/avatar';
export { anatomy as avatarAnatomy } from '@zag-js/avatar';
import * as carousel$1 from '@zag-js/carousel';
import { anatomy } from '@zag-js/carousel';
import * as checkbox$1 from '@zag-js/checkbox';
import { anatomy as anatomy$1 } from '@zag-js/checkbox';
import * as clipboard$1 from '@zag-js/clipboard';
export { anatomy as clipboardAnatomy } from '@zag-js/clipboard';
import * as colorPicker$1 from '@zag-js/color-picker';
import { anatomy as anatomy$2 } from '@zag-js/color-picker';
import * as presence from '@zag-js/presence';
import * as combobox$1 from '@zag-js/combobox';
export { anatomy as comboboxAnatomy } from '@zag-js/combobox';
import * as datePicker$1 from '@zag-js/date-picker';
import { anatomy as anatomy$3 } from '@zag-js/date-picker';
import * as dialog$1 from '@zag-js/dialog';
export { anatomy as dialogAnatomy } from '@zag-js/dialog';
import * as editable$1 from '@zag-js/editable';
export { anatomy as editableAnatomy } from '@zag-js/editable';
import { getDocument, getWindow, dataAttr as dataAttr$1, ariaAttr } from '@zag-js/dom-query';
import { createAnatomy } from '@zag-js/anatomy';
import * as fileUpload$1 from '@zag-js/file-upload';
export { anatomy as fileUploadAnatomy } from '@zag-js/file-upload';
import { isRTL, formatBytes, formatNumber } from '@zag-js/i18n-utils';
import * as hoverCard$1 from '@zag-js/hover-card';
export { anatomy as hoverCardAnatomy } from '@zag-js/hover-card';
import * as menu$1 from '@zag-js/menu';
export { anatomy as menuAnatomy } from '@zag-js/menu';
import * as numberInput$1 from '@zag-js/number-input';
export { anatomy as numberInputAnatomy } from '@zag-js/number-input';
import * as pagination$1 from '@zag-js/pagination';
export { anatomy as paginationAnatomy } from '@zag-js/pagination';
import * as pinInput$1 from '@zag-js/pin-input';
export { anatomy as pinInputAnatomy } from '@zag-js/pin-input';
import * as popover$1 from '@zag-js/popover';
export { anatomy as popoverAnatomy } from '@zag-js/popover';
import * as progress$1 from '@zag-js/progress';
export { anatomy as progressAnatomy } from '@zag-js/progress';
import * as qrCode$1 from '@zag-js/qr-code';
export { anatomy as qrCodeAnatomy } from '@zag-js/qr-code';
import * as radio from '@zag-js/radio-group';
import { anatomy as anatomy$4 } from '@zag-js/radio-group';
export { anatomy as radioGroupAnatomy } from '@zag-js/radio-group';
import * as rating from '@zag-js/rating-group';
export { anatomy as ratingGroupAnatomy } from '@zag-js/rating-group';
import * as select$1 from '@zag-js/select';
export { anatomy as selectAnatomy } from '@zag-js/select';
import * as signaturePad$1 from '@zag-js/signature-pad';
export { anatomy as signaturePadAnatomy } from '@zag-js/signature-pad';
import * as slider$1 from '@zag-js/slider';
export { anatomy as sliderAnatomy } from '@zag-js/slider';
import * as splitter$1 from '@zag-js/splitter';
export { anatomy as splitterAnatomy } from '@zag-js/splitter';
import * as zagSwitch from '@zag-js/switch';
export { anatomy as switchAnatomy } from '@zag-js/switch';
import * as tabs$1 from '@zag-js/tabs';
export { anatomy as tabsAnatomy } from '@zag-js/tabs';
import * as tagsInput$1 from '@zag-js/tags-input';
export { anatomy as tagsInputAnatomy } from '@zag-js/tags-input';
import { parseTime } from '@internationalized/date';
import * as timePicker$1 from '@zag-js/time-picker';
import * as toast$1 from '@zag-js/toast';
export { anatomy as toastAnatomy } from '@zag-js/toast';
import * as toggleGroup$1 from '@zag-js/toggle-group';
export { anatomy as toggleGroupAnatomy } from '@zag-js/toggle-group';
import * as tooltip$1 from '@zag-js/tooltip';
export { anatomy as tooltipAnatomy } from '@zag-js/tooltip';
import * as treeView$1 from '@zag-js/tree-view';
export { anatomy as treeViewAnatomy } from '@zag-js/tree-view';
import * as timer$1 from '@zag-js/timer';
import * as steps$1 from '@zag-js/steps';
export { anatomy as stepsAnatomy } from '@zag-js/steps';

function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    strict = true,
    hookName = 'useContext',
    providerName = 'Provider',
    errorMessage,
    defaultValue
  } = options;
  const Context = createContext$1(defaultValue);
  function useContext$1() {
    const context = useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = 'ContextError';
      Error.captureStackTrace?.(error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

const [AccordionProvider, useAccordionContext] = createContext({
  hookName: 'useAccordionContext',
  providerName: '<AccordionProvider />'
});

const AccordionContext = props => props.children(useAccordionContext());

const createSplitProps = () => (props, keys) => splitProps(props, keys);

const [RenderStrategyProvider, useRenderStrategyContext] = createContext({
  hookName: 'useRenderStrategyContext',
  providerName: '<RenderStrategyProvider />'
});
const splitRenderStrategyProps = props => createSplitProps()(props, ['lazyMount', 'unmountOnExit']);

const withAsProp = Component => {
  const ArkComponent = props => {
    const [localProps, parentProps] = splitProps(props, ['asChild']);
    if (localProps.asChild) {
      // @ts-expect-error
      const propsFn = userProps => {
        const [, restProps] = splitProps(parentProps, ['ref']);
        return mergeProps$1(restProps, userProps);
      };
      return localProps.asChild(propsFn);
    }
    // @ts-expect-error
    return createComponent(Dynamic, mergeProps({
      component: Component
    }, parentProps));
  };
  return ArkComponent;
};
function jsxFactory() {
  const cache = new Map();
  return new Proxy(withAsProp, {
    apply(_target, _thisArg, argArray) {
      return withAsProp(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache.has(asElement)) {
        cache.set(asElement, withAsProp(asElement));
      }
      return cache.get(asElement);
    }
  });
}
const ark = jsxFactory();

const [CollapsibleProvider, useCollapsibleContext] = createContext({
  hookName: 'useCollapsibleContext',
  providerName: '<CollapsibleProvider />'
});

const CollapsibleContent = props => {
  const api = useCollapsibleContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), props);
  return createComponent(Show, {
    get when() {
      return !api().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const CollapsibleContext = props => props.children(useCollapsibleContext());

const isFunction = value => typeof value === 'function';
const runIfFn = (valueOrFn, ...args) => isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;

const [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  hookName: 'useEnvironmentContext',
  providerName: '<EnvironmentProvider />',
  strict: false,
  defaultValue: () => ({
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  })
});

var _tmpl$$6 = /*#__PURE__*/template(`<span hidden>`);
const EnvironmentProvider = props => {
  const [spanRef, setSpanRef] = createSignal();
  const getRootNode = () => runIfFn(props.value) ?? spanRef()?.ownerDocument ?? document;
  const environment = createMemo(() => ({
    getRootNode,
    getDocument: () => getDocument(getRootNode()),
    getWindow: () => getWindow(getRootNode())
  }));
  return createComponent(EnvironmentContextProvider, {
    value: environment,
    get children() {
      return [memo(() => props.children), createComponent(Show, {
        get when() {
          return !props.value;
        },
        get children() {
          var _el$ = _tmpl$$6();
          use(setSpanRef, _el$);
          return _el$;
        }
      })];
    }
  });
};

const [LocaleContextProvider, useLocaleContext] = createContext({
  hookName: 'useEnvironmentContext',
  providerName: '<EnvironmentProvider />',
  strict: false,
  defaultValue: () => ({
    dir: 'ltr',
    locale: 'en-US'
  })
});

const LocaleProvider = props => {
  const context = createMemo(() => ({
    locale: props.locale,
    dir: isRTL(props.locale) ? 'rtl' : 'ltr'
  }));
  return createComponent(LocaleContextProvider, {
    value: context,
    get children() {
      return props.children;
    }
  });
};

const useCollapsible = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const [renderStrategyProps, collapsibleProps] = splitRenderStrategyProps(props);
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...collapsibleProps
  }));
  const [state, send] = useMachine(collapsible$1.machine(context()), {
    context
  });
  const [wasVisible, setWasVisible] = createSignal(false);
  createEffect(() => {
    const isPresent = api().visible;
    if (isPresent) setWasVisible(true);
  });
  const api = createMemo(() => collapsible$1.connect(state, send, normalizeProps));
  return createMemo(() => ({
    ...api(),
    unmounted: !api().visible && !wasVisible() && renderStrategyProps.lazyMount || renderStrategyProps.unmountOnExit && !api().visible && wasVisible()
  }));
};

const CollapsibleRoot = props => {
  const [useCollapsibleProps, localProps] = createSplitProps()(props, ['defaultOpen', 'disabled', 'id', 'ids', 'lazyMount', 'onExitComplete', 'onOpenChange', 'open', 'unmountOnExit']);
  const api = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(CollapsibleProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const CollapsibleRootProvider = props => {
  const [{
    value: collapsible
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => collapsible().getRootProps(), localProps);
  return createComponent(CollapsibleProvider, {
    value: collapsible,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const CollapsibleTrigger = props => {
  const api = useCollapsibleContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var collapsible = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: CollapsibleContent,
  Context: CollapsibleContext,
  Root: CollapsibleRoot,
  RootProvider: CollapsibleRootProvider,
  Trigger: CollapsibleTrigger
});

const [AccordionItemProvider, useAccordionItemContext] = createContext({
  hookName: 'useAccordionItemContext',
  providerName: '<AccordionItemProvider />'
});

const [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext({
  hookName: 'useAccordionItemPropsContext',
  providerName: '<AccordionItemPropsProvider />'
});

const AccordionItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'disabled']);
  const accordion = useAccordionContext();
  const renderStrategyProps = useRenderStrategyContext();
  const mergedProps = mergeProps$1(() => accordion().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => accordion().getItemState(itemProps));
  const itemContentProps = accordion().getItemContentProps(itemProps);
  return createComponent(AccordionItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(AccordionItemProvider, {
        value: itemState,
        get children() {
          return createComponent(CollapsibleRoot, mergeProps({
            get open() {
              return itemState().expanded;
            },
            get ids() {
              return {
                content: itemContentProps.id
              };
            }
          }, renderStrategyProps, mergedProps));
        }
      });
    }
  });
};

const splitVisibilityProps = createSplitProps();
const AccordionItemContent = props => {
  const accordion = useAccordionContext();
  const itemProps = useAccordionItemPropsContext();
  const itemContentProps = createMemo(() => {
    const contentProps = accordion().getItemContentProps(itemProps);
    const [, ownProps] = splitVisibilityProps(contentProps, ['hidden', 'data-state']);
    return ownProps;
  });
  const mergedProps = mergeProps$1(itemContentProps, props);
  return createComponent(CollapsibleContent, mergedProps);
};

const AccordionItemContext = props => props.children(useAccordionItemContext());

const AccordionItemIndicator = props => {
  const accordion = useAccordionContext();
  const itemProps = useAccordionItemPropsContext();
  const mergedProps = mergeProps$1(() => accordion().getItemIndicatorProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const AccordionItemTrigger = props => {
  const accordion = useAccordionContext();
  const itemProps = useAccordionItemPropsContext();
  const collapsible = useCollapsibleContext();
  const mergedProps = mergeProps$1(() => accordion().getItemTriggerProps(itemProps), props);
  const [ariaControls, buttonProps] = splitProps(mergedProps, ['aria-controls']);
  return createComponent(ark.button, mergeProps(buttonProps, () => !collapsible().unmounted && ariaControls));
};

const useAccordion = props => {
  const id = createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    value: props.defaultValue,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(accordion$1.machine(context()), {
    context
  });
  return createMemo(() => accordion$1.connect(state, send, normalizeProps));
};

const AccordionRoot = props => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props);
  const [useAccordionProps, localProps] = createSplitProps()(accordionProps, ['collapsible', 'defaultValue', 'disabled', 'id', 'ids', 'multiple', 'onFocusChange', 'onValueChange', 'orientation', 'value']);
  const api = useAccordion(useAccordionProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(AccordionProvider, {
    value: api,
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const AccordionRootProvider = props => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props);
  const [{
    value: accordion
  }, localProps] = createSplitProps()(accordionProps, ['value']);
  const mergedProps = mergeProps$1(() => accordion().getRootProps(), localProps);
  return createComponent(AccordionProvider, {
    value: accordion,
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

var accordion = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: AccordionContext,
  Item: AccordionItem,
  ItemContent: AccordionItemContent,
  ItemContext: AccordionItemContext,
  ItemIndicator: AccordionItemIndicator,
  ItemTrigger: AccordionItemTrigger,
  Root: AccordionRoot,
  RootProvider: AccordionRootProvider
});

const [AvatarProvider, useAvatarContext] = createContext({
  hookName: 'useAvatarContext',
  providerName: '<AvatarProvider />'
});

const AvatarContext = props => props.children(useAvatarContext());

const AvatarFallback = props => {
  const context = useAvatarContext();
  const mergedProps = mergeProps$1(() => context().getFallbackProps(), props);
  return createComponent(ark.span, mergedProps);
};

const AvatarImage = props => {
  const context = useAvatarContext();
  const mergedProps = mergeProps$1(() => context().getImageProps(), props);
  return createComponent(ark.img, mergedProps);
};

const useAvatar = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(avatar$1.machine(context()), {
    context
  });
  return createMemo(() => avatar$1.connect(state, send, normalizeProps));
};

const AvatarRoot = props => {
  const [useAvatarProps, localProps] = createSplitProps()(props, ['id', 'ids', 'onStatusChange']);
  const context = useAvatar(useAvatarProps);
  const mergedProps = mergeProps$1(() => context().getRootProps(), localProps);
  return createComponent(AvatarProvider, {
    value: context,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const AvatarRootProvider = props => {
  const [{
    value: avatar
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => avatar().getRootProps(), localProps);
  return createComponent(AvatarProvider, {
    value: avatar,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var avatar = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: AvatarContext,
  Fallback: AvatarFallback,
  Image: AvatarImage,
  Root: AvatarRoot,
  RootProvider: AvatarRootProvider
});

const [CarouselProvider, useCarouselContext] = createContext({
  hookName: 'useCarouselContext',
  providerName: '<CarouselProvider />'
});

const CarouselContext = props => props.children(useCarouselContext());

const carouselAnatomy = anatomy.extendWith('control');

const CarouselControl = props => {
  const mergedProps = mergeProps$1(() => carouselAnatomy.build().control.attrs, props);
  return createComponent(ark.div, mergedProps);
};

const CarouselIndicator = props => {
  const [indicatorProps, localProps] = createSplitProps()(props, ['index', 'readOnly']);
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getIndicatorProps(indicatorProps), localProps);
  return createComponent(ark.button, mergedProps);
};

const CarouselIndicatorGroup = props => {
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getIndicatorGroupProps(), props);
  return createComponent(ark.div, mergedProps);
};

const CarouselItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getItemProps(itemProps), localProps);
  return createComponent(ark.div, mergedProps);
};

const CarouselItemGroup = props => {
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getItemGroupProps(), props);
  return createComponent(ark.div, mergedProps);
};

const CarouselNextTrigger = props => {
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getNextTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const CarouselPrevTrigger = props => {
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getPrevTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const useCarousel = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    index: props.defaultIndex,
    ...props
  }));
  const [state, send] = useMachine(carousel$1.machine(context()), {
    context
  });
  return createMemo(() => carousel$1.connect(state, send, normalizeProps));
};

const CarouselRoot = props => {
  const [useCarouselProps, localProps] = createSplitProps()(props, ['align', 'defaultIndex', 'id', 'ids', 'index', 'loop', 'onIndexChange', 'orientation', 'slidesPerView', 'spacing']);
  const api = useCarousel(useCarouselProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(CarouselProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const CarouselRootProvider = props => {
  const [{
    value: carousel
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => carousel().getRootProps(), localProps);
  return createComponent(CarouselProvider, {
    value: carousel,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const CarouselViewport = props => {
  const api = useCarouselContext();
  const mergedProps = mergeProps$1(() => api().getViewportProps(), props);
  return createComponent(ark.div, mergedProps);
};

var carousel = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: CarouselContext,
  Control: CarouselControl,
  Indicator: CarouselIndicator,
  IndicatorGroup: CarouselIndicatorGroup,
  Item: CarouselItem,
  ItemGroup: CarouselItemGroup,
  NextTrigger: CarouselNextTrigger,
  PrevTrigger: CarouselPrevTrigger,
  Root: CarouselRoot,
  RootProvider: CarouselRootProvider,
  Viewport: CarouselViewport
});

const [CheckboxProvider, useCheckboxContext] = createContext({
  hookName: 'useCheckboxContext',
  providerName: '<CheckboxProvider />'
});

const CheckboxContext = props => props.children(useCheckboxContext());

const CheckboxControl = props => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps$1(() => checkbox().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const checkboxAnatomy = anatomy$1.extendWith('group');

function useControllableState(props) {
  const [uncontrolledValue, setUncontrolledValue] = createSignal(runIfFn(props.defaultValue));
  const controlled = createMemo(() => props.value?.() !== undefined);
  const currentValue = createMemo(() => controlled() ? props.value?.() : uncontrolledValue());
  const setValue = next => {
    untrack(() => {
      const nextValue = runIfFn(next, currentValue());
      if (controlled()) {
        return props.onChange?.(nextValue);
      }
      setUncontrolledValue(nextValue);
      return props.onChange?.(nextValue);
    });
  };
  return [currentValue, setValue];
}

function useCheckboxGroup(props = {}) {
  const interative = createMemo(() => !(props.disabled || props.readOnly));
  const [value, setValue] = useControllableState({
    value: props.value,
    defaultValue: props.defaultValue || [],
    onChange: props.onValueChange
  });
  return createMemo(() => {
    const isChecked = val => {
      return value().some(v => String(v) === String(val));
    };
    const toggleValue = val => {
      isChecked(val) ? removeValue(val) : addValue(val);
    };
    const addValue = val => {
      if (!interative()) return;
      if (isChecked(val)) return;
      setValue(value().concat(val));
    };
    const removeValue = val => {
      if (!interative()) return;
      setValue(value().filter(v => String(v) !== String(val)));
    };
    const getItemProps = itemProps => {
      return {
        checked: itemProps.value != null ? isChecked(itemProps.value) : undefined,
        onCheckedChange() {
          if (itemProps.value != null) {
            toggleValue(itemProps.value);
          }
        },
        name: props.name,
        disabled: props.disabled,
        readOnly: props.readOnly,
        invalid: props.invalid
      };
    };
    return {
      isChecked,
      value,
      name: props.name,
      disabled: props.disabled,
      readOnly: props.readOnly,
      invalid: props.invalid,
      setValue,
      addValue,
      toggleValue,
      getItemProps
    };
  });
}

const [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext({
  hookName: 'useCheckboxGroupContext',
  providerName: '<CheckboxGroupProvider />',
  strict: false
});

const CheckboxGroup = props => {
  const [checkboxGroupProps, localProps] = createSplitProps()(props, ['defaultValue', 'value', 'onValueChange', 'disabled', 'invalid', 'readOnly', 'name']);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return createComponent(CheckboxGroupContextProvider, {
    value: checkboxGroup,
    get children() {
      return createComponent(ark.div, mergeProps({
        role: "group"
      }, localProps, () => checkboxAnatomy.build().group.attrs));
    }
  });
};

const [FieldProvider, useFieldContext] = createContext({
  hookName: 'useFieldContext',
  providerName: '<FieldProvider />',
  strict: false
});

const FieldContext = props => props.children(useFieldContext());

const FieldErrorText = props => {
  const field = useFieldContext();
  const mergedProps = mergeProps$1(() => field().getErrorTextProps(), props);
  return createComponent(Show, {
    get when() {
      return field?.().invalid;
    },
    get children() {
      return createComponent(ark.span, mergedProps);
    }
  });
};

const FieldHelperText = props => {
  const field = useFieldContext();
  const mergedProps = mergeProps$1(() => field().getHelperTextProps(), props);
  return createComponent(ark.span, mergedProps);
};

const FieldInput = props => {
  const field = useFieldContext();
  const mergedProps = mergeProps$1(() => field?.().getInputProps(), props);
  return createComponent(ark.input, mergedProps);
};

const FieldLabel = props => {
  const field = useFieldContext();
  const mergedProps = mergeProps$1(() => field?.().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const FieldSelect = props => {
  const field = useFieldContext();
  const mergedProps = mergeProps$1(() => field?.().getSelectProps(), props);
  return createComponent(ark.select, mergedProps);
};

const [FieldsetProvider, useFieldsetContext] = createContext({
  hookName: 'useFieldsetContext',
  providerName: '<FieldsetProvider />',
  strict: false
});

const FieldsetContext = props => props.children(useFieldsetContext());

const FieldsetErrorText = props => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps$1(() => fieldset().getErrorTextProps(), props);
  return createComponent(Show, {
    get when() {
      return fieldset().invalid;
    },
    get children() {
      return createComponent(ark.span, mergedProps);
    }
  });
};

const FieldsetHelperText = props => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps$1(() => fieldset().getHelperTextProps(), props);
  return createComponent(ark.span, mergedProps);
};

const fieldsetAnatomy = createAnatomy('fieldset').parts('root', 'errorText', 'helperText', 'legend');
const parts$2 = fieldsetAnatomy.build();

const useFieldset = props => {
  const {
    disabled = false,
    invalid = false
  } = props;
  let rootRef;
  const id = props.id ?? createUniqueId();
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  const [hasErrorText, setHasErrorText] = createSignal(false);
  const [hasHelperText, setHasHelperText] = createSignal(false);
  createEffect(() => {
    return;
  });
  const labelIds = [];
  if (hasErrorText() && invalid) labelIds.push(errorTextId);
  if (hasHelperText()) labelIds.push(helperTextId);
  const getRootProps = () => ({
    ...parts$2.root.attrs,
    disabled,
    'data-disabled': dataAttr(disabled),
    'data-invalid': dataAttr(invalid),
    'aria-describedby': labelIds.join(' ') || undefined
  });
  const getLegendProps = () => ({
    ...parts$2.legend.attrs,
    'data-disabled': dataAttr(disabled),
    'data-invalid': dataAttr(invalid)
  });
  const getHelperTextProps = () => ({
    id: helperTextId,
    ...parts$2.helperText.attrs
  });
  const getErrorTextProps = () => ({
    id: errorTextId,
    ...parts$2.errorText.attrs,
    'aria-live': 'polite'
  });
  return createMemo(() => ({
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  }));
};
const dataAttr = condition => condition ? '' : undefined;

const FieldsetRoot = props => {
  const [useFieldsetProps, localProps] = createSplitProps()(props, ['id', 'disabled', 'invalid']);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps$1(() => fieldset().getRootProps(), localProps);
  return createComponent(FieldsetProvider, {
    value: fieldset,
    get children() {
      return createComponent(ark.fieldset, mergedProps);
    }
  });
};
FieldsetRoot.displayName = 'FieldsetRoot';

const FieldsetRootProvider = props => {
  const [{
    value: fieldset
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => fieldset().getRootProps(), localProps);
  return createComponent(FieldsetProvider, {
    value: fieldset,
    get children() {
      return createComponent(ark.fieldset, mergedProps);
    }
  });
};

const FieldsetLegend = props => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps$1(() => fieldset().getLegendProps(), props);
  return createComponent(ark.legend, mergedProps);
};

var fieldset = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: FieldsetContext,
  ErrorText: FieldsetErrorText,
  HelperText: FieldsetHelperText,
  Legend: FieldsetLegend,
  Root: FieldsetRoot,
  RootProvider: FieldsetRootProvider
});

const fieldAnatomy = createAnatomy('field').parts('root', 'errorText', 'helperText', 'input', 'label', 'select', 'textarea');
const parts$1 = fieldAnatomy.build();

const useField = props => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset?.().disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props;
  const [hasErrorText, setHasErrorText] = createSignal(false);
  const [hasHelperText, setHasHelperText] = createSignal(false);
  const id = props.id ?? createUniqueId();
  let rootRef;
  const rootId = ids?.control ?? `field::${id}`;
  const errorTextId = ids?.errorText ?? `field::${id}::error-text`;
  const helperTextId = ids?.helperText ?? `field::${id}::helper-text`;
  const labelId = ids?.label ?? `field::${id}::label`;
  createEffect(() => {
    return;
  });
  const getRootProps = () => ({
    ...parts$1.root.attrs,
    id: rootId,
    role: 'group',
    'data-disabled': dataAttr$1(disabled),
    'data-invalid': dataAttr$1(invalid),
    'data-readonly': dataAttr$1(readOnly)
  });
  const getLabelProps = () => ({
    ...parts$1.label.attrs,
    id: labelId,
    'data-disabled': dataAttr$1(disabled),
    'data-invalid': dataAttr$1(invalid),
    'data-readonly': dataAttr$1(readOnly),
    htmlFor: id
  });
  const labelIds = [];
  if (hasErrorText() && invalid) labelIds.push(errorTextId);
  if (hasHelperText()) labelIds.push(helperTextId);
  const getControlProps = () => ({
    'aria-describedby': labelIds.join(' ') || undefined,
    'aria-invalid': ariaAttr(invalid),
    'data-invalid': dataAttr$1(invalid),
    'data-required': dataAttr$1(required),
    'data-readonly': dataAttr$1(readOnly),
    id,
    required,
    disabled,
    readOnly
  });
  const getInputProps = () => ({
    ...getControlProps(),
    ...parts$1.input.attrs
  });
  const getTextareaProps = () => ({
    ...getControlProps(),
    ...parts$1.textarea.attrs
  });
  const getSelectProps = () => ({
    ...getControlProps(),
    ...parts$1.select.attrs
  });
  const getHelperTextProps = () => ({
    id: helperTextId,
    ...parts$1.helperText.attrs
  });
  const getErrorTextProps = () => ({
    id: errorTextId,
    ...parts$1.errorText.attrs,
    'aria-live': 'polite'
  });
  return createMemo(() => ({
    ariaDescribedby: labelIds.join(' '),
    ids: {
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps
  }));
};

const FieldRoot = props => {
  const [useFieldProps, localProps] = createSplitProps()(props, ['id', 'ids', 'disabled', 'invalid', 'readOnly', 'required']);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps$1(() => field().getRootProps(), localProps);
  return createComponent(FieldProvider, {
    value: field,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const FieldRootProvider = props => {
  const [{
    value: field
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => field().getRootProps(), localProps);
  return createComponent(FieldProvider, {
    value: field,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const FieldTextarea = props => {
  const field = useFieldContext();
  const mergedProps = mergeProps$1(() => field?.().getTextareaProps(), props);
  return createComponent(ark.textarea, mergedProps);
};

var field = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: FieldContext,
  ErrorText: FieldErrorText,
  HelperText: FieldHelperText,
  Input: FieldInput,
  Label: FieldLabel,
  Root: FieldRoot,
  RootProvider: FieldRootProvider,
  Select: FieldSelect,
  Textarea: FieldTextarea
});

const CheckboxHiddenInput = props => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps$1(() => checkbox().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const CheckboxIndicator = props => {
  const [indicatorProps, localProps] = createSplitProps()(props, ['indeterminate']);
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps$1(() => checkbox().getIndicatorProps(), localProps);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get hidden() {
      return !(indicatorProps.indeterminate ? checkbox().indeterminate : checkbox().checked);
    }
  }));
};

const CheckboxLabel = props => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps$1(() => checkbox().getLabelProps(), props);
  return createComponent(ark.span, mergedProps);
};

const useCheckbox = ownProps => {
  const checkboxGroup = useCheckboxGroupContext();
  const props = createMemo(() => {
    return mergeProps$1(ownProps, checkboxGroup?.().getItemProps({
      value: ownProps.value
    }) ?? {});
  }, [ownProps, checkboxGroup]);
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    invalid: field?.().invalid,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    checked: props().defaultChecked,
    ...props()
  }));
  const [state, send] = useMachine(checkbox$1.machine(context()), {
    context
  });
  return createMemo(() => checkbox$1.connect(state, send, normalizeProps));
};

const CheckboxRoot = props => {
  const [useCheckboxProps, labelprops] = createSplitProps()(props, ['checked', 'defaultChecked', 'disabled', 'form', 'id', 'ids', 'invalid', 'name', 'onCheckedChange', 'readOnly', 'required', 'value']);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps$1(() => checkbox().getRootProps(), labelprops);
  return createComponent(CheckboxProvider, {
    value: checkbox,
    get children() {
      return createComponent(ark.label, mergedProps);
    }
  });
};

const CheckboxRootProvider = props => {
  const [{
    value: checkbox
  }, labelprops] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => checkbox().getRootProps(), labelprops);
  return createComponent(CheckboxProvider, {
    value: checkbox,
    get children() {
      return createComponent(ark.label, mergedProps);
    }
  });
};

var checkbox = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: CheckboxContext,
  Control: CheckboxControl,
  Group: CheckboxGroup,
  HiddenInput: CheckboxHiddenInput,
  Indicator: CheckboxIndicator,
  Label: CheckboxLabel,
  Root: CheckboxRoot,
  RootProvider: CheckboxRootProvider
});

const [ClipboardProvider, useClipboardContext] = createContext({
  hookName: 'useClipboardContext',
  providerName: '<ClipboardProvider />'
});

const ClipboardContext = props => props.children(useClipboardContext());

const ClipboardControl = props => {
  const api = useClipboardContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const ClipboardIndicator = props => {
  const [indicatorProps, localProps] = createSplitProps()(props, ['copied']);
  const api = useClipboardContext();
  const mergedProps = mergeProps$1(api().getIndicatorProps({
    copied: api().copied
  }), localProps);
  const getChildren = children(() => localProps.children);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return createComponent(Show, {
        get when() {
          return api().copied;
        },
        get fallback() {
          return getChildren();
        },
        get children() {
          return indicatorProps.copied;
        }
      });
    }
  }));
};

const ClipboardInput = props => {
  const api = useClipboardContext();
  const mergedProps = mergeProps$1(() => api().getInputProps(), props);
  return createComponent(ark.input, mergedProps);
};

const ClipboardLabel = props => {
  const api = useClipboardContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useClipboard = props => {
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(clipboard$1.machine(context()), {
    context
  });
  return createMemo(() => clipboard$1.connect(state, send, normalizeProps));
};

const ClipboardRoot = props => {
  const [useClipboardProps, localProps] = createSplitProps()(props, ['id', 'ids', 'onStatusChange', 'timeout', 'value']);
  const api = useClipboard(useClipboardProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(ClipboardProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ClipboardRootProvider = props => {
  const [{
    value: clipboard
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => clipboard().getRootProps(), localProps);
  return createComponent(ClipboardProvider, {
    value: clipboard,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ClipboardTrigger = props => {
  const api = useClipboardContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var clipboard = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: ClipboardContext,
  Control: ClipboardControl,
  Indicator: ClipboardIndicator,
  Input: ClipboardInput,
  Label: ClipboardLabel,
  Root: ClipboardRoot,
  RootProvider: ClipboardRootProvider,
  Trigger: ClipboardTrigger
});

const [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext({
  hookName: 'useColorPickerAreaContext',
  providerName: '<ColorPickerAreaProvider />'
});

const [ColorPickerProvider, useColorPickerContext] = createContext({
  hookName: 'useColorPickerContext',
  providerName: '<ColorPickerProvider />'
});

const ColorPickerArea = props => {
  const [channelProps, divprops] = createSplitProps()(props, ['xChannel', 'yChannel']);
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getAreaProps(channelProps), divprops);
  return createComponent(ColorPickerAreaPropsProvider, {
    value: channelProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerAreaBackground = props => {
  const api = useColorPickerContext();
  const areaProps = useColorPickerAreaPropsContext();
  const mergedProps = mergeProps$1(() => api().getAreaBackgroundProps(areaProps), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerAreaThumb = props => {
  const api = useColorPickerContext();
  const areaProps = useColorPickerAreaPropsContext();
  const mergedProps = mergeProps$1(() => api().getAreaThumbProps(areaProps), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerChannelInput = props => {
  const [channelProps, inputProps] = createSplitProps()(props, ['channel', 'orientation']);
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getChannelInputProps(channelProps), inputProps);
  return createComponent(ark.input, mergedProps);
};

const [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext({
  hookName: 'useColorPickerChannelSliderContext',
  providerName: '<ColorPickerChannelSliderProvider />'
});

const [ColorPickerFormatPropsProvider, useColorPickerFormatPropsContext] = createContext({
  hookName: 'useColorPickerFormatPropsContext',
  providerName: '<ColorPickerFormatPropsProvider />',
  strict: false
});

const ColorPickerChannelSlider = props => {
  const [channelProps, localProps] = createSplitProps()(props, ['channel', 'orientation']);
  const api = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = mergeProps$1(channelProps, formatProps);
  const mergedProps = mergeProps$1(() => api().getChannelSliderProps(channelSliderProps), localProps);
  return createComponent(ColorPickerChannelPropsProvider, {
    value: channelProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerChannelSliderLabel = props => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps$1(() => colorPicker().getChannelSliderLabelProps(channelProps), props);
  return createComponent(ark.label, mergedProps);
};

const ColorPickerChannelSliderThumb = props => {
  const api = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelProps = useColorPickerChannelPropsContext();
  const channelSliderProps = mergeProps$1(channelProps, formatProps);
  const mergedProps = mergeProps$1(() => api().getChannelSliderThumbProps(channelSliderProps), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerChannelSliderTrack = props => {
  const api = useColorPickerContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelProps = useColorPickerChannelPropsContext();
  const channelSliderProps = mergeProps$1(channelProps, formatProps);
  const mergedProps = mergeProps$1(() => api().getChannelSliderTrackProps(channelSliderProps), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerChannelSliderValueText = props => {
  const colorPicker = useColorPickerContext();
  const localeContext = useLocaleContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps$1(() => colorPicker().getChannelSliderValueTextProps(channelProps), props);
  return createComponent(ark.span, mergeProps(mergedProps, {
    get children() {
      return props.children || colorPicker().getChannelValueText(channelProps.channel, localeContext().locale);
    }
  }));
};

const splitPresenceProps = props => createSplitProps()(props, ['immediate', 'lazyMount', 'onExitComplete', 'present', 'unmountOnExit']);

const usePresence = props => {
  const [renderStrategyProps, context] = splitRenderStrategyProps(props);
  const [wasEverPresent, setWasEverPresent] = createSignal(false);
  const [state, send] = useMachine(presence.machine(context), {
    context
  });
  const api = createMemo(() => presence.connect(state, send, normalizeProps));
  createEffect(() => {
    const present = api().present;
    if (present) setWasEverPresent(true);
  });
  return createMemo(() => ({
    unmounted: !api().present && !wasEverPresent() && renderStrategyProps.lazyMount || renderStrategyProps.unmountOnExit && !api().present && wasEverPresent(),
    present: api().present,
    presenceProps: {
      ref: api().setNode,
      hidden: !api().present,
      'data-state': context.present ? 'open' : 'closed'
    }
  }));
};

const Presence = props => {
  const [presenceProps, localProps] = splitPresenceProps(props);
  const api = usePresence(presenceProps);
  const mergedProps = mergeProps$1(() => api().presenceProps, localProps);
  return createComponent(Show, {
    get when() {
      return !api().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergeProps(mergedProps, {
        "data-scope": "presence",
        "data-part": "root"
      }));
    }
  });
};

const [PresenceProvider, usePresenceContext] = createContext({
  hookName: 'usePresenceContext',
  providerName: '<PresenceProvider />'
});

const ColorPickerContent = props => {
  const api = useColorPickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerContext = props => props.children(useColorPickerContext());

const ColorPickerControl = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerEyeDropperTrigger = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getEyeDropperTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const ColorPickerFormatSelect = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getFormatSelectProps(), props);
  return createComponent(ark.select, mergeProps(mergedProps, {
    get children() {
      return createComponent(Index, {
        each: ['rgba', 'hsla', 'hsba'],
        children: format => createComponent(ark.option, {
          get value() {
            return format();
          },
          get children() {
            return format();
          }
        })
      });
    }
  }));
};

const ColorPickerFormatTrigger = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getFormatTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const ColorPickerHiddenInput = props => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps$1(() => colorPicker().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const ColorPickerLabel = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const ColorPickerPositioner = props => {
  const api = useColorPickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useColorPicker = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props,
    value: props.value ? colorPicker$1.parse(props.value) : props.defaultValue ? colorPicker$1.parse(props.defaultValue) : undefined
  }));
  const [state, send] = useMachine(colorPicker$1.machine(context()), {
    context
  });
  return createMemo(() => colorPicker$1.connect(state, send, normalizeProps));
};

const ColorPickerRoot = props => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props);
  const [useColorPickerProps, localProps] = createSplitProps()(colorPickerProps, ['closeOnSelect', 'defaultOpen', 'defaultValue', 'disabled', 'format', 'id', 'ids', 'initialFocusEl', 'name', 'name', 'onFocusOutside', 'onFormatChange', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'onValueChange', 'onValueChangeEnd', 'open', 'positioning', 'readOnly', 'required', 'value']);
  const api = useColorPicker(useColorPickerProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(ColorPickerProvider, {
    value: api,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ColorPickerRootProvider = props => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props);
  const [{
    value: colorPicker
  }, localProps] = createSplitProps()(colorPickerProps, ['value']);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: colorPicker().open
  })));
  const mergedProps = mergeProps$1(() => colorPicker().getRootProps(), localProps);
  return createComponent(ColorPickerProvider, {
    value: colorPicker,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext({
  hookName: 'useColorPickerSwatchContext',
  providerName: '<ColorPickerSwatchProvider />'
});

const ColorPickerSwatch = props => {
  const [swatchProps, localProps] = createSplitProps()(props, ['respectAlpha', 'value']);
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getSwatchProps(swatchProps), localProps);
  return createComponent(ColorPickerSwatchPropsProvider, {
    value: swatchProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerSwatchGroup = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getSwatchGroupProps(), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerSwatchIndicator = props => {
  const api = useColorPickerContext();
  const swatchProps = useColorPickerSwatchPropsContext();
  const mergedProps = mergeProps$1(() => api().getSwatchIndicatorProps(swatchProps), props);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerSwatchTrigger = props => {
  const [triggerProps, localProps] = createSplitProps()(props, ['value', 'disabled']);
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getSwatchTriggerProps(triggerProps), localProps);
  return createComponent(ark.button, mergedProps);
};

const ColorPickerTransparencyGrid = props => {
  const [gridProps, localProps] = createSplitProps()(props, ['size']);
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getTransparencyGridProps(gridProps), localProps);
  return createComponent(ark.div, mergedProps);
};

const ColorPickerTrigger = props => {
  const api = useColorPickerContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const ColorPickerValueSwatch = props => {
  const [{
    respectAlpha
  }, localProps] = createSplitProps()(props, ['respectAlpha']);
  const colorPicker = useColorPickerContext();
  const swatchProps = createMemo(() => ({
    respectAlpha,
    value: colorPicker().value
  }));
  const mergedProps = mergeProps$1(() => colorPicker().getSwatchProps(swatchProps()), localProps);
  return createComponent(ColorPickerSwatchPropsProvider, {
    get value() {
      return swatchProps();
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ColorPickerValueText = props => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps$1(() => colorPicker().getValueTextProps(), props);
  return createComponent(ark.span, mergeProps(mergedProps, {
    get children() {
      return colorPicker().valueAsString || props.children;
    }
  }));
};

const colorPickerAnatomy = anatomy$2.extendWith('view');

const ColorPickerView = props => {
  const api = useColorPickerContext();
  const [formatProps, localProps] = createSplitProps()(props, ['format']);
  const mergedProps = mergeProps$1(() => colorPickerAnatomy.build().view.attrs, localProps);
  return createComponent(ColorPickerFormatPropsProvider, {
    value: formatProps,
    get children() {
      return createComponent(Show, {
        get when() {
          return api().format === props.format;
        },
        get children() {
          return createComponent(ark.div, mergeProps({
            get ["data-format"]() {
              return props.format;
            }
          }, mergedProps));
        }
      });
    }
  });
};

var colorPicker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Area: ColorPickerArea,
  AreaBackground: ColorPickerAreaBackground,
  AreaThumb: ColorPickerAreaThumb,
  ChannelInput: ColorPickerChannelInput,
  ChannelSlider: ColorPickerChannelSlider,
  ChannelSliderLabel: ColorPickerChannelSliderLabel,
  ChannelSliderThumb: ColorPickerChannelSliderThumb,
  ChannelSliderTrack: ColorPickerChannelSliderTrack,
  ChannelSliderValueText: ColorPickerChannelSliderValueText,
  Content: ColorPickerContent,
  Context: ColorPickerContext,
  Control: ColorPickerControl,
  EyeDropperTrigger: ColorPickerEyeDropperTrigger,
  FormatSelect: ColorPickerFormatSelect,
  FormatTrigger: ColorPickerFormatTrigger,
  HiddenInput: ColorPickerHiddenInput,
  Label: ColorPickerLabel,
  Positioner: ColorPickerPositioner,
  Root: ColorPickerRoot,
  RootProvider: ColorPickerRootProvider,
  Swatch: ColorPickerSwatch,
  SwatchGroup: ColorPickerSwatchGroup,
  SwatchIndicator: ColorPickerSwatchIndicator,
  SwatchTrigger: ColorPickerSwatchTrigger,
  TransparencyGrid: ColorPickerTransparencyGrid,
  Trigger: ColorPickerTrigger,
  ValueSwatch: ColorPickerValueSwatch,
  ValueText: ColorPickerValueText,
  View: ColorPickerView
});

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
const [ComboboxProvider, useComboboxContext] = createContext({
  hookName: 'useComboboxContext',
  providerName: '<ComboboxProvider />'
});

const ComboboxClearTrigger = props => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps$1(() => combobox().getClearTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const ComboboxContent = props => {
  const api = useComboboxContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ComboboxContext = props => props.children(useComboboxContext());

const ComboboxControl = props => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps$1(() => combobox().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const ComboboxInput = props => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps$1(() => combobox().getInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const [ComboboxItemProvider, useComboboxItemContext] = createContext({
  hookName: 'useComboboxItemContext',
  providerName: '<ComboboxItemProvider />'
});

const [ComboboxItemPropsProvider, useComboboxItemPropsContext] = createContext({
  hookName: 'useComboboxItemPropsContext',
  providerName: '<ComboboxItemPropsProvider />'
});

const ComboboxItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['item', 'persistFocus']);
  const api = useComboboxContext();
  const mergedProps = mergeProps$1(() => api().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => api().getItemState(itemProps));
  return createComponent(ComboboxItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(ComboboxItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ComboboxItemContext = props => props.children(useComboboxItemContext());

const [ComboboxItemGroupPropsProvider, useComboboxItemGroupPropsContext] = createContext({
  hookName: 'useComboboxItemGroupPropsContext',
  providerName: '<ComboboxItemGroupPropsProvider />'
});

const ComboboxItemGroup = props => {
  const [_itemGroupProps, localProps] = createSplitProps()(props, ['id']);
  const combobox = useComboboxContext();
  const itemGroupProps = mergeProps$1({
    id: createUniqueId()
  }, _itemGroupProps);
  const mergedProps = mergeProps$1(() => combobox().getItemGroupProps(itemGroupProps), localProps);
  return createComponent(ComboboxItemGroupPropsProvider, {
    value: itemGroupProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ComboboxItemGroupLabel = props => {
  const combobox = useComboboxContext();
  const itemGroupProps = useComboboxItemGroupPropsContext();
  const mergedProps = mergeProps$1(() => combobox().getItemGroupLabelProps({
    htmlFor: itemGroupProps.id
  }), props);
  return createComponent(ark.div, mergedProps);
};

const ComboboxItemIndicator = props => {
  const combobox = useComboboxContext();
  const itemProps = useComboboxItemPropsContext();
  const mergedProps = mergeProps$1(() => combobox().getItemIndicatorProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const ComboboxItemText = props => {
  const api = useComboboxContext();
  const itemProps = useComboboxItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemTextProps(itemProps), props);
  return createComponent(ark.span, mergedProps);
};

const ComboboxLabel = props => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps$1(() => combobox().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const ComboboxList = props => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps$1(() => combobox().getListProps(), props);
  return createComponent(ark.div, mergedProps);
};

const ComboboxPositioner = props => {
  const api = useComboboxContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useCombobox = props => {
  const [collectionOptions, comboboxProps] = createSplitProps()(props, ['isItemDisabled', 'itemToValue', 'itemToString', 'items']);
  const collection = () => combobox$1.collection({
    ...collectionOptions
  });
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    collection: collection(),
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    value: props.defaultValue,
    'open.controlled': props.open !== undefined,
    ...comboboxProps
  }));
  const [state, send] = useMachine(combobox$1.machine(context()), {
    context
  });
  return createMemo(() => combobox$1.connect(state, send, normalizeProps));
};

const ComboboxRoot = props => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props);
  const [useComboboxProps, localProps] = createSplitProps()(comboboxProps, ['allowCustomValue', 'autoFocus', 'closeOnSelect', 'composite', 'defaultOpen', 'defaultValue', 'disabled', 'disableLayer', 'form', 'getSelectionValue', 'highlightedValue', 'id', 'ids', 'inputBehavior', 'inputValue', 'invalid', 'isItemDisabled', 'items', 'itemToString', 'itemToValue', 'loopFocus', 'multiple', 'name', 'onFocusOutside', 'onHighlightChange', 'onInputValueChange', 'onInteractOutside', 'onOpenChange', 'onOpenChange', 'onPointerDownOutside', 'onValueChange', 'open', 'openOnChange', 'openOnClick', 'openOnKeyPress', 'placeholder', 'positioning', 'readOnly', 'required', 'scrollToIndexFn', 'selectionBehavior', 'translations', 'value']);
  const api = useCombobox(useComboboxProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(ComboboxProvider, {
    value: api,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ComboboxRootProvider = props => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props);
  const [{
    value: combobox
  }, localProps] = createSplitProps()(comboboxProps, ['value']);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: combobox().open
  })));
  const mergedProps = mergeProps$1(() => combobox().getRootProps(), localProps);
  return createComponent(ComboboxProvider, {
    value: combobox,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const ComboboxTrigger = props => {
  const [triggerProps, localProps] = createSplitProps()(props, ['focusable']);
  const combobox = useComboboxContext();
  const mergedProps = mergeProps$1(() => combobox().getTriggerProps(triggerProps), localProps);
  return createComponent(ark.button, mergedProps);
};

var combobox = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: ComboboxClearTrigger,
  Content: ComboboxContent,
  Context: ComboboxContext,
  Control: ComboboxControl,
  Input: ComboboxInput,
  Item: ComboboxItem,
  ItemContext: ComboboxItemContext,
  ItemGroup: ComboboxItemGroup,
  ItemGroupLabel: ComboboxItemGroupLabel,
  ItemIndicator: ComboboxItemIndicator,
  ItemText: ComboboxItemText,
  Label: ComboboxLabel,
  List: ComboboxList,
  Positioner: ComboboxPositioner,
  Root: ComboboxRoot,
  RootProvider: ComboboxRootProvider,
  Trigger: ComboboxTrigger
});

const [DatePickerProvider, useDatePickerContext] = createContext({
  hookName: 'useDatePickerContext',
  providerName: '<DatePickerProvider />'
});

const DatePickerClearTrigger = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getClearTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const DatePickerContent = props => {
  const api = useDatePickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const DatePickerContext = props => props.children(useDatePickerContext());

const DatePickerControl = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const DatePickerInput = props => {
  const [inputProps, localProps] = createSplitProps()(props, ['index']);
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getInputProps(inputProps), localProps);
  return createComponent(ark.input, mergedProps);
};

const DatePickerLabel = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

var _tmpl$$5 = /*#__PURE__*/template(`<option>`);
const DatePickerMonthSelect = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getMonthSelectProps(), props);
  return createComponent(ark.select, mergeProps(mergedProps, {
    get children() {
      return createComponent(For, {
        get each() {
          return api().getMonths();
        },
        children: month => (() => {
          var _el$ = _tmpl$$5();
          insert(_el$, () => month.label);
          effect(() => _el$.value = month.value);
          return _el$;
        })()
      });
    }
  }));
};

const [DatePickerViewProvider, useDatePickerViewContext] = createContext({
  hookName: 'useDatePickerViewContext',
  providerName: '<DatePickerViewProvider />',
  strict: false,
  defaultValue: {
    view: 'day'
  }
});

const DatePickerNextTrigger = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = mergeProps$1(() => api().getNextTriggerProps(viewProps), props);
  return createComponent(ark.button, mergedProps);
};

const DatePickerPositioner = props => {
  const api = useDatePickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const DatePickerPresetTrigger = props => {
  const [presetTriggerProps, localProps] = createSplitProps()(props, ['value']);
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getPresetTriggerProps(presetTriggerProps), localProps);
  return createComponent(ark.button, mergedProps);
};

const DatePickerPrevTrigger = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = mergeProps$1(() => api().getPrevTriggerProps(viewProps), props);
  return createComponent(ark.button, mergedProps);
};

const DatePickerRangeText = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getRangeTextProps(), props);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return api().visibleRangeText.start;
    }
  }));
};

const useDatePicker = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    'open.controlled': props.open !== undefined,
    open: props.defaultOpen,
    ...props,
    focusedValue: props.focusedValue ? datePicker$1.parse(props.focusedValue) : undefined,
    value: props.value ? datePicker$1.parse(props.value) : props.defaultValue ? datePicker$1.parse(props.defaultValue) : undefined,
    max: props.max ? datePicker$1.parse(props.max) : undefined,
    min: props.min ? datePicker$1.parse(props.min) : undefined
  }));
  const [state, send] = useMachine(datePicker$1.machine(context()), {
    context
  });
  return createMemo(() => datePicker$1.connect(state, send, normalizeProps));
};

const DatePickerRoot = props => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props);
  const [useDatePickerProps, localProps] = createSplitProps()(datePickerProps, ['closeOnSelect', 'defaultOpen', 'defaultValue', 'disabled', 'fixedWeeks', 'focusedValue', 'format', 'id', 'ids', 'isDateUnavailable', 'isDateUnavailable', 'locale', 'max', 'min', 'modal', 'name', 'numOfMonths', 'onFocusChange', 'onOpenChange', 'onValueChange', 'onViewChange', 'open', 'positioning', 'readOnly', 'selectionMode', 'startOfWeek', 'timeZone', 'translations', 'value', 'view']);
  const api = useDatePicker(useDatePickerProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(DatePickerProvider, {
    value: api,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const DatePickerRootProvider = props => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props);
  const [{
    value: datePicker
  }, localProps] = createSplitProps()(datePickerProps, ['value']);
  const presence = usePresence(mergeProps$1(presenceProps, () => ({
    present: datePicker().open
  })));
  const mergedProps = mergeProps$1(() => datePicker().getRootProps(), localProps);
  return createComponent(DatePickerProvider, {
    value: datePicker,
    get children() {
      return createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const [DatePickerTableProvider, useDatePickerTableContext] = createContext({
  hookName: 'useDatePickerTableContext',
  providerName: '<DatePickerTableProvider />'
});

const DatePickerTable = props => {
  const [{
    columns
  }, localProps] = createSplitProps()(props, ['columns']);
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const tableProps = {
    columns,
    id: createUniqueId(),
    ...viewProps
  };
  const mergedProps = mergeProps$1(() => api().getTableProps(tableProps), localProps);
  return createComponent(DatePickerTableProvider, {
    value: tableProps,
    get children() {
      return createComponent(ark.table, mergedProps);
    }
  });
};

const DatePickerTableBody = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = mergeProps$1(() => api().getTableBodyProps(tableProps), props);
  return createComponent(ark.tbody, mergedProps);
};

const [DatePickerTableCellProvider, useDatePickerTableCellContext] = createContext({
  hookName: 'useDatePickerTableCellContext',
  providerName: '<DatePickerTableCellProvider />'
});

const DatePickerTableCell = props => {
  const [cellProps, localProps] = createSplitProps()(props, ['disabled', 'value', 'visibleRange', 'columns']);
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const tableCellProps = createMemo(() => {
    const viewMap = {
      day: api().getDayTableCellProps,
      month: api().getMonthTableCellProps,
      year: api().getYearTableCellProps
    };
    const viewFn = viewMap[viewProps.view];

    // @ts-expect-error
    return viewFn(cellProps);
  });
  const mergedProps = mergeProps$1(tableCellProps, localProps);
  return createComponent(DatePickerTableCellProvider, {
    value: cellProps,
    get children() {
      return createComponent(ark.td, mergedProps);
    }
  });
};

const DatePickerTableCellTrigger = props => {
  const api = useDatePickerContext();
  const cellProps = useDatePickerTableCellContext();
  const viewProps = useDatePickerViewContext();
  const triggerProps = createMemo(() => {
    const viewMap = {
      day: api().getDayTableCellTriggerProps,
      month: api().getMonthTableCellTriggerProps,
      year: api().getYearTableCellTriggerProps
    };
    const viewFn = viewMap[viewProps.view];

    // @ts-expect-error
    return viewFn(cellProps);
  });
  const mergedProps = mergeProps$1(triggerProps, props);
  return createComponent(ark.div, mergedProps);
};

const DatePickerTableHead = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = mergeProps$1(() => api().getTableHeadProps(tableProps), props);
  return createComponent(ark.thead, mergedProps);
};

const DatePickerTableHeader = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = mergeProps$1(() => api().getTableHeaderProps(tableProps), props);
  return createComponent(ark.th, mergedProps);
};

const DatePickerTableRow = props => {
  const api = useDatePickerContext();
  const tableProps = useDatePickerTableContext();
  const mergedProps = mergeProps$1(() => api().getTableRowProps(tableProps), props);
  return createComponent(ark.tr, mergedProps);
};

const DatePickerTrigger = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const datePickerAnatomy = anatomy$3.extendWith('view');

const DatePickerView = props => {
  const [viewProps, localProps] = createSplitProps()(props, ['view']);
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => datePickerAnatomy.build().view.attrs, localProps);
  return createComponent(DatePickerViewProvider, {
    value: viewProps,
    get children() {
      return createComponent(ark.div, mergeProps(mergedProps, {
        get hidden() {
          return api().view !== viewProps.view;
        }
      }));
    }
  });
};

const DatePickerViewControl = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = mergeProps$1(() => api().getViewControlProps(viewProps), props);
  return createComponent(ark.div, mergedProps);
};

const DatePickerViewTrigger = props => {
  const api = useDatePickerContext();
  const viewProps = useDatePickerViewContext();
  const mergedProps = mergeProps$1(() => api().getViewTriggerProps(viewProps), props);
  return createComponent(ark.button, mergedProps);
};

var _tmpl$$4 = /*#__PURE__*/template(`<option>`);
const DatePickerYearSelect = props => {
  const api = useDatePickerContext();
  const mergedProps = mergeProps$1(() => api().getYearSelectProps(), props);
  return createComponent(ark.select, mergeProps(mergedProps, {
    get children() {
      return createComponent(For, {
        get each() {
          return getYearsRange({
            from: 1_000,
            to: 4_000
          });
        },
        children: year => (() => {
          var _el$ = _tmpl$$4();
          _el$.value = year;
          insert(_el$, year);
          return _el$;
        })()
      });
    }
  }));
};
function getYearsRange(range) {
  const years = [];
  for (let year = range.from; year <= range.to; year += 1) {
    years.push(year);
  }
  return years;
}

var datePicker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: DatePickerClearTrigger,
  Content: DatePickerContent,
  Context: DatePickerContext,
  Control: DatePickerControl,
  Input: DatePickerInput,
  Label: DatePickerLabel,
  MonthSelect: DatePickerMonthSelect,
  NextTrigger: DatePickerNextTrigger,
  Positioner: DatePickerPositioner,
  PresetTrigger: DatePickerPresetTrigger,
  PrevTrigger: DatePickerPrevTrigger,
  RangeText: DatePickerRangeText,
  Root: DatePickerRoot,
  RootProvider: DatePickerRootProvider,
  Table: DatePickerTable,
  TableBody: DatePickerTableBody,
  TableCell: DatePickerTableCell,
  TableCellTrigger: DatePickerTableCellTrigger,
  TableHead: DatePickerTableHead,
  TableHeader: DatePickerTableHeader,
  TableRow: DatePickerTableRow,
  Trigger: DatePickerTrigger,
  View: DatePickerView,
  ViewControl: DatePickerViewControl,
  ViewTrigger: DatePickerViewTrigger,
  YearSelect: DatePickerYearSelect
});

const [DialogProvider, useDialogContext] = createContext({
  hookName: 'useDialogContext',
  providerName: '<DialogProvider />'
});

const DialogBackdrop = props => {
  const api = useDialogContext();
  const renderStrategyProps = useRenderStrategyContext();
  const presenceApi = usePresence(mergeProps$1(renderStrategyProps, () => ({
    present: api().open
  })));
  const mergedProps = mergeProps$1(() => api().getBackdropProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const DialogCloseTrigger = props => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps$1(() => dialog().getCloseTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const DialogContent = props => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const DialogContext = props => props.children(useDialogContext());

const DialogDescription = props => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps$1(() => dialog().getDescriptionProps(), props);
  return createComponent(ark.div, mergedProps);
};

const DialogPositioner = props => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useDialog = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = useMachine(dialog$1.machine(context()), {
    context
  });
  return createMemo(() => dialog$1.connect(state, send, normalizeProps));
};

const DialogRoot = props => {
  const [presenceProps, dialogProps] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const [useDialogProps, localProps] = createSplitProps()(dialogProps, ['aria-label', 'closeOnEscape', 'closeOnInteractOutside', 'defaultOpen', 'finalFocusEl', 'id', 'ids', 'initialFocusEl', 'modal', 'onEscapeKeyDown', 'onFocusOutside', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'open', 'persistentElements', 'preventScroll', 'restoreFocus', 'role', 'trapFocus']);
  const api = useDialog(useDialogProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  return createComponent(DialogProvider, {
    value: api,
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(PresenceProvider, {
            value: apiPresence,
            get children() {
              return localProps.children;
            }
          });
        }
      });
    }
  });
};

const DialogRootProvider = props => {
  const [presenceProps, dialogProps] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: dialogProps.value().open
  })));
  return createComponent(DialogProvider, {
    get value() {
      return dialogProps.value;
    },
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(PresenceProvider, {
            value: apiPresence,
            get children() {
              return dialogProps.children;
            }
          });
        }
      });
    }
  });
};

const DialogTitle = props => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps$1(() => dialog().getTitleProps(), props);
  return createComponent(ark.h2, mergedProps);
};

const DialogTrigger = props => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), () => ({
    'aria-controls': presenceApi().unmounted && null
  }), props);
  return createComponent(ark.button, mergedProps);
};

var dialog = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Backdrop: DialogBackdrop,
  CloseTrigger: DialogCloseTrigger,
  Content: DialogContent,
  Context: DialogContext,
  Description: DialogDescription,
  Positioner: DialogPositioner,
  Root: DialogRoot,
  RootProvider: DialogRootProvider,
  Title: DialogTitle,
  Trigger: DialogTrigger
});

const [EditableProvider, useEditableContext] = createContext({
  hookName: 'useEditableContext',
  providerName: '<EditableProvider />'
});

const EditableArea = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getAreaProps(), props);
  return createComponent(ark.div, mergedProps);
};

const EditableCancelTrigger = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getCancelTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const EditableContext = props => props.children(useEditableContext());

const EditableControl = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const EditableEditTrigger = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getEditTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const EditableInput = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const EditableLabel = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const EditablePreview = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getPreviewProps(), props);
  return createComponent(ark.span, mergedProps);
};

const useEditable = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    invalid: field?.().invalid,
    readOnly: field?.().readOnly,
    required: field?.().required,
    getRootNode: environment().getRootNode,
    edit: props.defaultEdit,
    value: props.defaultValue,
    'edit.controlled': props.edit !== undefined,
    ...props
  }));
  const [state, send] = useMachine(editable$1.machine(context()), {
    context
  });
  return createMemo(() => editable$1.connect(state, send, normalizeProps));
};

const EditableRoot = props => {
  const [useEditableProps, localProps] = createSplitProps()(props, ['activationMode', 'autoResize', 'defaultEdit', 'defaultValue', 'disabled', 'edit', 'finalFocusEl', 'form', 'id', 'ids', 'invalid', 'maxLength', 'name', 'onEditChange', 'onFocusOutside', 'onInteractOutside', 'onPointerDownOutside', 'onValueChange', 'onValueCommit', 'onValueRevert', 'placeholder', 'readOnly', 'required', 'selectOnFocus', 'submitMode', 'translations', 'value']);
  const api = useEditable(useEditableProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(EditableProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const EditableRootProvider = props => {
  const [{
    value: editable
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => editable().getRootProps(), localProps);
  return createComponent(EditableProvider, {
    value: editable,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const EditableSubmitTrigger = props => {
  const api = useEditableContext();
  const mergedProps = mergeProps$1(() => api().getSubmitTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var editable = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Area: EditableArea,
  CancelTrigger: EditableCancelTrigger,
  Context: EditableContext,
  Control: EditableControl,
  EditTrigger: EditableEditTrigger,
  Input: EditableInput,
  Label: EditableLabel,
  Preview: EditablePreview,
  Root: EditableRoot,
  RootProvider: EditableRootProvider,
  SubmitTrigger: EditableSubmitTrigger
});

const [FileUploadProvider, useFileUploadContext] = createContext({
  hookName: 'useFileUploadContext',
  providerName: '<FileUploadProvider />'
});

const FileUploadContext = props => props.children(useFileUploadContext());

const FileUploadDropzone = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps$1(() => fileUpload().getDropzoneProps(), props);
  return createComponent(ark.div, mergedProps);
};

const FileUploadHiddenInput = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps$1(() => fileUpload().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext({
  hookName: 'useFileUploadItemPropsContext',
  providerName: '<FileUploadItemPropsProvider />'
});

const FileUploadItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['file']);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps$1(() => fileUpload().getItemProps(itemProps), localProps);
  return createComponent(FileUploadItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(ark.li, mergedProps);
    }
  });
};

const FileUploadItemDeleteTrigger = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = mergeProps$1(() => fileUpload().getItemDeleteTriggerProps(itemProps), props);
  return createComponent(ark.button, mergedProps);
};

const FileUploadItemGroup = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps$1(() => fileUpload().getItemGroupProps(), props);
  return createComponent(ark.ul, mergedProps);
};

const FileUploadItemName = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = mergeProps$1(() => fileUpload().getItemNameProps(itemProps), props);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return props.children || itemProps.file.name;
    }
  }));
};

const FileUploadItemPreview = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = mergeProps$1(() => fileUpload().getItemPreviewProps(itemProps), props);
  if (!itemProps.file.type.match(props.type ?? '.*')) return null;
  return createComponent(ark.div, mergedProps);
};

const FileUploadItemPreviewImage = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const [url, setUrl] = createSignal('');
  fileUpload().createFileUrl(itemProps.file, url => setUrl(url));
  const mergedProps = mergeProps$1(fileUpload().getItemPreviewImageProps({
    ...itemProps,
    url: url()
  }), props);
  return createComponent(ark.img, mergedProps);
};

const FileUploadItemSizeText = props => {
  const fileUpload = useFileUploadContext();
  const itemProps = useFileUploadItemPropsContext();
  const mergedProps = mergeProps$1(() => fileUpload().getItemSizeTextProps(itemProps), props);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return props.children || fileUpload().getFileSize(itemProps.file);
    }
  }));
};

const FileUploadLabel = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps$1(() => fileUpload().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useFileUpload = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    required: field?.().required,
    invalid: field?.().invalid,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(fileUpload$1.machine(context()), {
    context
  });
  return createMemo(() => fileUpload$1.connect(state, send, normalizeProps));
};

const FileUploadRoot = props => {
  const [fileUploadProps, localProps] = createSplitProps()(props, ['accept', 'allowDrop', 'capture', 'directory', 'disabled', 'id', 'ids', 'invalid', 'locale', 'maxFiles', 'maxFileSize', 'minFileSize', 'name', 'onFileAccept', 'onFileChange', 'onFileReject', 'required', 'translations', 'validate']);
  const fileUpload = useFileUpload(fileUploadProps);
  const mergedProps = mergeProps$1(() => fileUpload().getRootProps(), localProps);
  return createComponent(FileUploadProvider, {
    value: fileUpload,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const FileUploadRootProvider = props => {
  const [{
    value: fileUpload
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => fileUpload().getRootProps(), localProps);
  return createComponent(FileUploadProvider, {
    value: fileUpload,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const FileUploadTrigger = props => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps$1(() => fileUpload().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var fileUpload = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: FileUploadContext,
  Dropzone: FileUploadDropzone,
  HiddenInput: FileUploadHiddenInput,
  Item: FileUploadItem,
  ItemDeleteTrigger: FileUploadItemDeleteTrigger,
  ItemGroup: FileUploadItemGroup,
  ItemName: FileUploadItemName,
  ItemPreview: FileUploadItemPreview,
  ItemPreviewImage: FileUploadItemPreviewImage,
  ItemSizeText: FileUploadItemSizeText,
  Label: FileUploadLabel,
  Root: FileUploadRoot,
  RootProvider: FileUploadRootProvider,
  Trigger: FileUploadTrigger
});

const FormatByte = props => {
  const [valueProps, intlProps] = splitProps(props, ['value']);
  const ctx = useLocaleContext();
  const text = createMemo(() => formatBytes(valueProps.value, ctx().locale, intlProps));
  return text;
};

const FormatNumber = props => {
  const [valueProps, intlProps] = splitProps(props, ['value']);
  const ctx = useLocaleContext();
  const text = createMemo(() => formatNumber(valueProps.value, ctx().locale, intlProps));
  return text;
};

var format = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Byte: FormatByte,
  Number: FormatNumber
});

const escapeRegexp = term => term.replace(/[|\\{}()[\]^$+*?.-]/g, char => `\\${char}`);
const buildRegex = (queryProp, flags) => {
  const query = queryProp.filter(Boolean).map(text => escapeRegexp(text));
  return new RegExp(`(${query.join('|')})`, flags);
};
const getRegexFlags = (ignoreCase = true, matchAll = true) => `${ignoreCase ? 'i' : ''}${matchAll ? 'g' : ''}`;
const normalizeSpan = (spans, len) => {
  const result = [];
  const append = (start, end, match) => {
    if (end - start > 0) result.push({
      start,
      end,
      match
    });
  };
  if (spans.length === 0) {
    append(0, len, false);
  } else {
    let lastIndex = 0;
    for (const chunk of spans) {
      append(lastIndex, chunk.start, false);
      append(chunk.start, chunk.end, true);
      lastIndex = chunk.end;
    }
    append(lastIndex, len, false);
  }
  return result;
};
const highlightWords = props => {
  const flags = getRegexFlags(props.ignoreCase, props.matchAll);
  const regex = buildRegex(Array.isArray(props.query) ? props.query : [props.query], flags);
  const spans = [...props.text.matchAll(regex)].map(match => ({
    start: match.index || 0,
    end: (match.index || 0) + match[0].length
  }));
  return normalizeSpan(spans, props.text.length).map(chunk => ({
    text: props.text.slice(chunk.start, chunk.end),
    match: !!chunk.match
  }));
};
const useHighlight = props => {
  return createMemo(() => highlightWords(props));
};

var _tmpl$$3 = /*#__PURE__*/template(`<mark>`);
const Highlight = props => {
  if (typeof props.text !== 'string') {
    throw new Error('[ark-ui/highlight] text must be a string');
  }
  const [highlightProps, localProps] = createSplitProps()(props, ['query', 'text', 'ignoreCase', 'matchAll']);
  const chunks = useHighlight(highlightProps);
  return createComponent(For, {
    get each() {
      return chunks();
    },
    children: chunk => createComponent(Show, {
      get when() {
        return chunk.match;
      },
      get fallback() {
        return chunk.text;
      },
      get children() {
        var _el$ = _tmpl$$3();
        spread(_el$, localProps, false, true);
        insert(_el$, () => chunk.text);
        return _el$;
      }
    })
  });
};

const [HoverCardProvider, useHoverCardContext] = createContext({
  hookName: 'useHoverCardContext',
  providerName: '<HoverCardProvider />'
});

const HoverCardArrow = props => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps$1(() => hoverCard().getArrowProps(), props);
  return createComponent(ark.div, mergedProps);
};

const HoverCardArrowTip = props => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps$1(() => hoverCard().getArrowTipProps(), props);
  return createComponent(ark.div, mergedProps);
};

const HoverCardContent = props => {
  const api = useHoverCardContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const HoverCardContext = props => props.children(useHoverCardContext());

const HoverCardPositioner = props => {
  const api = useHoverCardContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useHoverCard = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = useMachine(hoverCard$1.machine(context()), {
    context
  });
  return createMemo(() => hoverCard$1.connect(state, send, normalizeProps));
};

const HoverCardRoot = props => {
  const [presenceProps, hoverCardProps] = splitPresenceProps(props);
  const [useHoverCardProps, localProps] = createSplitProps()(hoverCardProps, ['closeDelay', 'defaultOpen', 'id', 'ids', 'onOpenChange', 'open', 'openDelay', 'positioning']);
  const api = useHoverCard(useHoverCardProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  return createComponent(HoverCardProvider, {
    value: api,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return localProps.children;
        }
      });
    }
  });
};

const HoverCardRootProvider = props => {
  const [presenceProps, hoverCardProps] = splitPresenceProps(props);
  const presence = usePresence(mergeProps$1(presenceProps, () => ({
    present: hoverCardProps.value().open
  })));
  return createComponent(HoverCardProvider, {
    get value() {
      return hoverCardProps.value;
    },
    get children() {
      return createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return hoverCardProps.children;
        }
      });
    }
  });
};

const HoverCardTrigger = props => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps$1(() => hoverCard().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var hoverCard = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: HoverCardArrow,
  ArrowTip: HoverCardArrowTip,
  Content: HoverCardContent,
  Context: HoverCardContext,
  Positioner: HoverCardPositioner,
  Root: HoverCardRoot,
  RootProvider: HoverCardRootProvider,
  Trigger: HoverCardTrigger
});

const [MenuProvider, useMenuContext] = createContext({
  hookName: 'useMenuContext',
  providerName: '<MenuProvider />',
  strict: false
});

const MenuArrow = props => {
  const context = useMenuContext();
  const mergedProps = mergeProps$1(() => context().getArrowProps(), props);
  return createComponent(ark.div, mergedProps);
};

const MenuArrowTip = props => {
  const context = useMenuContext();
  const mergedProps = mergeProps$1(() => context().getArrowTipProps(), props);
  return createComponent(ark.div, mergedProps);
};

const [MenuItemProvider, useMenuItemContext] = createContext({
  hookName: 'useMenuItemContext',
  providerName: '<MenuItemProvider />'
});

const [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext({
  hookName: 'useMenuOptionItemPropsContext',
  providerName: '<MenuOptionItemPropsProvider />'
});

const MenuCheckboxItem = props => {
  const [partialOptionItemProps, localProps] = createSplitProps()(props, ['checked', 'closeOnSelect', 'disabled', 'onCheckedChange', 'value', 'valueText']);
  const optionItemProps = mergeProps$1(partialOptionItemProps, {
    type: 'checkbox'
  });
  const context = useMenuContext();
  const mergedProps = mergeProps$1(() => context().getOptionItemProps(optionItemProps), localProps);
  const optionItemState = createMemo(() => context().getItemState(optionItemProps));
  return createComponent(MenuOptionItemPropsProvider, {
    value: optionItemProps,
    get children() {
      return createComponent(MenuItemProvider, {
        value: optionItemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const MenuContent = props => {
  const context = useMenuContext();
  const presenceContext = usePresenceContext();
  const mergedProps = mergeProps$1(() => context().getContentProps(), () => presenceContext().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceContext().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const MenuContext = props => props.children(useMenuContext());

const MenuContextTrigger = props => {
  const context = useMenuContext();
  const mergedProps = mergeProps$1(() => context().getContextTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const MenuIndicator = props => {
  const context = useMenuContext();
  const mergedProps = mergeProps$1(() => context().getIndicatorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const MenuItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['closeOnSelect', 'disabled', 'value', 'valueText']);
  const context = useMenuContext();
  const mergedProps = mergeProps$1(() => context().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => context().getItemState(itemProps));
  return createComponent(MenuItemProvider, {
    value: itemState,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const MenuItemContext = props => props.children(useMenuItemContext());

const [MenuItemGroupProvider, useMenuItemGroupContext] = createContext({
  hookName: 'useMenuItemGroupContext',
  providerName: '<MenuItemGroupProvider />'
});

const MenuItemGroup = props => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props, ['id']);
  const itemGroupProps = mergeProps$1({
    id: createUniqueId()
  }, optionalItemGroupProps);
  const menu = useMenuContext();
  const mergedProps = mergeProps$1(() => menu().getItemGroupProps(itemGroupProps), localProps);
  return createComponent(MenuItemGroupProvider, {
    value: itemGroupProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const MenuItemGroupLabel = props => {
  const context = useMenuContext();
  const itemGroupContext = useMenuItemGroupContext();
  const mergedProps = mergeProps$1(context().getItemGroupLabelProps({
    htmlFor: itemGroupContext.id
  }), props);
  return createComponent(ark.div, mergedProps);
};

const MenuItemIndicator = props => {
  const context = useMenuContext();
  const optionItemProps = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps$1(() => context().getItemIndicatorProps(optionItemProps), props);
  return createComponent(ark.div, mergedProps);
};

const MenuItemText = props => {
  const context = useMenuContext();
  const optionItemProps = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps$1(() => context().getItemTextProps(optionItemProps), props);
  return createComponent(ark.div, mergedProps);
};

const MenuPositioner = props => {
  const context = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps$1(() => context().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presence().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const MenuRadioItem = props => {
  const [partialItemProps, localProps] = createSplitProps()(props, ['closeOnSelect', 'disabled', 'value', 'valueText']);
  const context = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps = mergeProps$1(partialItemProps, () => ({
    type: 'radio',
    checked: itemGroup.value === partialItemProps.value,
    onCheckedChange: () => itemGroup.onValueChange?.({
      value: partialItemProps.value
    })
  }));
  const mergedProps = mergeProps$1(() => context().getOptionItemProps(optionItemProps), localProps);
  const optionItemState = createMemo(() => context().getOptionItemState(optionItemProps));
  return createComponent(MenuOptionItemPropsProvider, {
    value: optionItemProps,
    get children() {
      return createComponent(MenuItemProvider, {
        value: optionItemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const MenuRadioItemGroup = props => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props, ['id', 'onValueChange', 'value']);
  const context = useMenuContext();
  const itemGroupProps = mergeProps$1({
    id: createUniqueId()
  }, optionalItemGroupProps);
  const mergedProps = mergeProps$1(() => context().getItemGroupProps(itemGroupProps), localProps);
  return createComponent(MenuItemGroupProvider, {
    value: itemGroupProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useMenu = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send, machine] = useMachine(menu$1.machine(context()), {
    context
  });
  const api = createMemo(() => menu$1.connect(state, send, normalizeProps));
  return {
    api,
    machine
  };
};

const [MenuMachineProvider, useMenuMachineContext] = createContext({
  hookName: 'useMenuMachineContext',
  providerName: '<MenuMachineProvider />',
  strict: false
});

const [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext({
  hookName: 'useMenuMachineContext',
  providerName: '<MenuMachineProvider />',
  strict: false
});

const MenuRoot = props => {
  const [presenceProps, menuProps] = splitPresenceProps(props);
  const [useMenuProps, localProps] = createSplitProps()(menuProps, ['anchorPoint', 'aria-label', 'closeOnSelect', 'composite', 'defaultOpen', 'highlightedValue', 'id', 'ids', 'loopFocus', 'onEscapeKeyDown', 'onFocusOutside', 'onHighlightChange', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'onSelect', 'open', 'positioning', 'typeahead']);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const menu = useMenu(useMenuProps);
  const presenceApi = usePresence(mergeProps$1(presenceProps, () => ({
    present: menu.api().open
  })));
  createEffect(() => {
    if (!parentMachine) return;
    parentApi?.().setChild(menu.machine);
    menu.api().setParent(parentMachine);
  });
  const triggerItemContext = () => parentApi?.().getTriggerItemProps(menu.api());
  return createComponent(MenuTriggerItemProvider, {
    value: triggerItemContext,
    get children() {
      return createComponent(MenuMachineProvider, {
        get value() {
          return menu.machine;
        },
        get children() {
          return createComponent(MenuProvider, {
            get value() {
              return menu.api;
            },
            get children() {
              return createComponent(PresenceProvider, {
                value: presenceApi,
                get children() {
                  return localProps.children;
                }
              });
            }
          });
        }
      });
    }
  });
};

const MenuRootProvider = props => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, menuProps] = splitPresenceProps(props);
  const presenceApi = usePresence(mergeProps$1(presenceProps, () => ({
    present: menuProps.value.api().open
  })));
  createEffect(() => {
    if (!parentMachine) return;
    parentApi?.().setChild(menuProps.value.machine);
    menuProps.value.api().setParent(parentMachine);
  });
  const triggerItemContext = () => parentApi?.().getTriggerItemProps(menuProps.value.api());
  return createComponent(MenuTriggerItemProvider, {
    value: triggerItemContext,
    get children() {
      return createComponent(MenuMachineProvider, {
        get value() {
          return menuProps.value.machine;
        },
        get children() {
          return createComponent(MenuProvider, {
            get value() {
              return menuProps.value.api;
            },
            get children() {
              return createComponent(PresenceProvider, {
                value: presenceApi,
                get children() {
                  return menuProps.children;
                }
              });
            }
          });
        }
      });
    }
  });
};

const MenuSeparator = props => {
  const menu = useMenuContext();
  const mergedProps = mergeProps$1(() => menu().getSeparatorProps(), props);
  return createComponent(ark.hr, mergedProps);
};

const MenuTrigger = props => {
  const api = useMenuContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), () => ({
    'aria-controls': presenceApi().unmounted && null
  }), props);
  return createComponent(ark.button, mergedProps);
};

const MenuTriggerItem = props => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps$1(() => getTriggerItemProps?.(), props);
  return createComponent(ark.div, mergedProps);
};

var menu = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: MenuArrow,
  ArrowTip: MenuArrowTip,
  CheckboxItem: MenuCheckboxItem,
  Content: MenuContent,
  Context: MenuContext,
  ContextTrigger: MenuContextTrigger,
  Indicator: MenuIndicator,
  Item: MenuItem,
  ItemContext: MenuItemContext,
  ItemGroup: MenuItemGroup,
  ItemGroupLabel: MenuItemGroupLabel,
  ItemIndicator: MenuItemIndicator,
  ItemText: MenuItemText,
  Positioner: MenuPositioner,
  RadioItem: MenuRadioItem,
  RadioItemGroup: MenuRadioItemGroup,
  Root: MenuRoot,
  RootProvider: MenuRootProvider,
  Separator: MenuSeparator,
  Trigger: MenuTrigger,
  TriggerItem: MenuTriggerItem
});

const [NumberInputProvider, useNumberInputContext] = createContext({
  hookName: 'useNumberInputContext',
  providerName: '<NumberInputProvider />'
});

const NumberInputContext = props => props.children(useNumberInputContext());

const NumberInputControl = props => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const NumberInputDecrementTrigger = props => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps$1(() => api().getDecrementTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const NumberInputIncrementTrigger = props => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps$1(() => api().getIncrementTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const NumberInputInput = props => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps$1(() => api().getInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const NumberInputLabel = props => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useNumberInput = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(numberInput$1.machine(context()), {
    context
  });
  return createMemo(() => numberInput$1.connect(state, send, normalizeProps));
};

const NumberInputRoot = props => {
  const [useNumberInputProps, localProps] = createSplitProps()(props, ['allowMouseWheel', 'allowOverflow', 'clampValueOnBlur', 'defaultValue', 'disabled', 'focusInputOnChange', 'form', 'formatOptions', 'id', 'ids', 'inputMode', 'invalid', 'locale', 'max', 'min', 'name', 'onFocusChange', 'onValueChange', 'onValueInvalid', 'pattern', 'readOnly', 'required', 'spinOnPress', 'step', 'translations', 'value']);
  const api = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(NumberInputProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const NumberInputRootProvider = props => {
  const [{
    value: numberInput
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => numberInput().getRootProps(), localProps);
  return createComponent(NumberInputProvider, {
    value: numberInput,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const NumberInputScrubber = props => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps$1(() => api().getScrubberProps(), props);
  return createComponent(ark.div, mergedProps);
};

const NumberInputValueText = props => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps$1(() => numberInput().getValueTextProps(), props);
  return createComponent(ark.span, mergedProps);
};

var numberInput = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: NumberInputContext,
  Control: NumberInputControl,
  DecrementTrigger: NumberInputDecrementTrigger,
  IncrementTrigger: NumberInputIncrementTrigger,
  Input: NumberInputInput,
  Label: NumberInputLabel,
  Root: NumberInputRoot,
  RootProvider: NumberInputRootProvider,
  Scrubber: NumberInputScrubber,
  ValueText: NumberInputValueText
});

const [PaginationProvider, usePaginationContext] = createContext({
  hookName: 'usePaginationContext',
  providerName: '<PaginationProvider />'
});

const PaginationContext = props => props.children(usePaginationContext());

const PaginationEllipsis = props => {
  const [ellipsisProps, localProps] = createSplitProps()(props, ['index']);
  const api = usePaginationContext();
  const mergedProps = mergeProps$1(() => api().getEllipsisProps(ellipsisProps), localProps);
  return createComponent(ark.div, mergedProps);
};

const PaginationItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'type']);
  const api = usePaginationContext();
  const mergedProps = mergeProps$1(() => api().getItemProps(itemProps), localProps);
  return createComponent(ark.button, mergedProps);
};

const PaginationNextTrigger = props => {
  const api = usePaginationContext();
  const mergedProps = mergeProps$1(() => api().getNextTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const PaginationPrevTrigger = props => {
  const api = usePaginationContext();
  const mergedProps = mergeProps$1(() => api().getPrevTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const usePagination = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    page: props.defaultPage,
    ...props
  }));
  const [state, send] = useMachine(pagination$1.machine(context()), {
    context
  });
  return createMemo(() => pagination$1.connect(state, send, normalizeProps));
};

const PaginationRoot = props => {
  const [usePaginationProps, localProps] = createSplitProps()(props, ['count', 'defaultPage', 'id', 'ids', 'onPageChange', 'onPageSizeChange', 'page', 'pageSize', 'siblingCount', 'translations', 'type']);
  const api = usePagination(usePaginationProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(PaginationProvider, {
    value: api,
    get children() {
      return createComponent(ark.nav, mergedProps);
    }
  });
};

const PaginationRootProvider = props => {
  const [{
    value: pagination
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => pagination().getRootProps(), localProps);
  return createComponent(PaginationProvider, {
    value: pagination,
    get children() {
      return createComponent(ark.nav, mergedProps);
    }
  });
};

var pagination = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: PaginationContext,
  Ellipsis: PaginationEllipsis,
  Item: PaginationItem,
  NextTrigger: PaginationNextTrigger,
  PrevTrigger: PaginationPrevTrigger,
  Root: PaginationRoot,
  RootProvider: PaginationRootProvider
});

const [PinInputProvider, usePinInputContext] = createContext({
  hookName: 'usePinInputContext',
  providerName: '<PinInputProvider />'
});

const PinInputContext = props => props.children(usePinInputContext());

const PinInputControl = props => {
  const api = usePinInputContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PinInputHiddenInput = props => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps$1(() => pinInput().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const PinInputInput = props => {
  const [inputProps, localProps] = createSplitProps()(props, ['index']);
  const api = usePinInputContext();
  const mergedProps = mergeProps$1(() => api().getInputProps(inputProps), localProps);
  return createComponent(ark.input, mergedProps);
};

const PinInputLabel = props => {
  const api = usePinInputContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const usePinInput = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(pinInput$1.machine(context()), {
    context
  });
  return createMemo(() => pinInput$1.connect(state, send, normalizeProps));
};

const PinInputRoot = props => {
  const [usePinInputProps, localProps] = createSplitProps()(props, ['autoFocus', 'blurOnComplete', 'defaultValue', 'disabled', 'form', 'id', 'ids', 'invalid', 'mask', 'name', 'onValueChange', 'onValueComplete', 'onValueInvalid', 'otp', 'pattern', 'placeholder', 'readOnly', 'required', 'selectOnFocus', 'translations', 'type', 'value']);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps$1(() => pinInput().getRootProps(), localProps);
  return createComponent(PinInputProvider, {
    value: pinInput,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const PinInputRootProvider = props => {
  const [{
    value: pinInput
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => pinInput().getRootProps(), localProps);
  return createComponent(PinInputProvider, {
    value: pinInput,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var pinInput = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: PinInputContext,
  Control: PinInputControl,
  HiddenInput: PinInputHiddenInput,
  Input: PinInputInput,
  Label: PinInputLabel,
  Root: PinInputRoot,
  RootProvider: PinInputRootProvider
});

const [PopoverProvider, usePopoverContext] = createContext({
  hookName: 'usePopoverContext',
  providerName: '<PopoverProvider />'
});

const PopoverAnchor = props => {
  const api = usePopoverContext();
  const mergedProps = mergeProps$1(() => api().getAnchorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PopoverArrow = props => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps$1(() => popover().getArrowProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PopoverArrowTip = props => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps$1(() => popover().getArrowTipProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PopoverCloseTrigger = props => {
  const api = usePopoverContext();
  const mergedProps = mergeProps$1(() => api().getCloseTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const PopoverContent = props => {
  const api = usePopoverContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const PopoverContext = props => props.children(usePopoverContext());

const PopoverDescription = props => {
  const api = usePopoverContext();
  const mergedProps = mergeProps$1(() => api().getDescriptionProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PopoverIndicator = props => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps$1(() => popover().getIndicatorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PopoverPositioner = props => {
  const api = usePopoverContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const usePopover = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = useMachine(popover$1.machine(context()), {
    context
  });
  return createMemo(() => popover$1.connect(state, send, normalizeProps));
};

const PopoverRoot = props => {
  const [presenceProps, popoverProps] = splitPresenceProps(props);
  const [usePopoverProps, localProps] = createSplitProps()(popoverProps, ['autoFocus', 'closeOnEscape', 'closeOnInteractOutside', 'defaultOpen', 'id', 'ids', 'initialFocusEl', 'modal', 'onEscapeKeyDown', 'onFocusOutside', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'open', 'persistentElements', 'portalled', 'positioning']);
  const api = usePopover(usePopoverProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  return createComponent(PopoverProvider, {
    value: api,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return localProps.children;
        }
      });
    }
  });
};

const PopoverRootProvider = props => {
  const [presenceProps, popoverProps] = splitPresenceProps(props);
  const presence = usePresence(mergeProps$1(presenceProps, () => ({
    present: popoverProps.value().open
  })));
  return createComponent(PopoverProvider, {
    get value() {
      return popoverProps.value;
    },
    get children() {
      return createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return popoverProps.children;
        }
      });
    }
  });
};

const PopoverTitle = props => {
  const api = usePopoverContext();
  const mergedProps = mergeProps$1(() => api().getTitleProps(), props);
  return createComponent(ark.div, mergedProps);
};

const PopoverTrigger = props => {
  const api = usePopoverContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), () => ({
    'aria-controls': presenceApi().unmounted && null
  }), props);
  return createComponent(ark.button, mergedProps);
};

var popover = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Anchor: PopoverAnchor,
  Arrow: PopoverArrow,
  ArrowTip: PopoverArrowTip,
  CloseTrigger: PopoverCloseTrigger,
  Content: PopoverContent,
  Context: PopoverContext,
  Description: PopoverDescription,
  Indicator: PopoverIndicator,
  Positioner: PopoverPositioner,
  Root: PopoverRoot,
  RootProvider: PopoverRootProvider,
  Title: PopoverTitle,
  Trigger: PopoverTrigger
});

const [ProgressProvider, useProgressContext] = createContext({
  hookName: 'useProgressContext',
  providerName: '<ProgressProvider />'
});

const ProgressCircle = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getCircleProps(), props);
  return createComponent(ark.svg, mergedProps);
};

const ProgressCircleRange = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getCircleRangeProps(), props);
  return createComponent(ark.circle, mergedProps);
};

const ProgressCircleTrack = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getCircleTrackProps(), props);
  return createComponent(ark.circle, mergedProps);
};

const ProgressContext = props => props.children(useProgressContext());

const ProgressLabel = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const ProgressRange = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getRangeProps(), props);
  return createComponent(ark.div, mergedProps);
};

const useProgress = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(progress$1.machine(context()), {
    context
  });
  return createMemo(() => progress$1.connect(state, send, normalizeProps));
};

const ProgressRoot = props => {
  const [progressProps, localProps] = createSplitProps()(props, ['id', 'ids', 'max', 'min', 'orientation', 'translations', 'value']);
  const api = useProgress(progressProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(ProgressProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ProgressRootProvider = props => {
  const [{
    value: progress
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => progress().getRootProps(), localProps);
  return createComponent(ProgressProvider, {
    value: progress,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ProgressTrack = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getTrackProps(), props);
  return createComponent(ark.div, mergedProps);
};

const ProgressValueText = props => {
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getValueTextProps(), props);
  return createComponent(ark.span, mergeProps(mergedProps, {
    get children() {
      return props.children || api().percentAsString;
    }
  }));
};

const ProgressView = props => {
  const [state, localProps] = createSplitProps()(props, ['state']);
  const api = useProgressContext();
  const mergedProps = mergeProps$1(() => api().getViewProps(state), localProps);
  return createComponent(ark.span, mergedProps);
};

var progress = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Circle: ProgressCircle,
  CircleRange: ProgressCircleRange,
  CircleTrack: ProgressCircleTrack,
  Context: ProgressContext,
  Label: ProgressLabel,
  Range: ProgressRange,
  Root: ProgressRoot,
  RootProvider: ProgressRootProvider,
  Track: ProgressTrack,
  ValueText: ProgressValueText,
  View: ProgressView
});

const [QrCodeProvider, useQrCodeContext] = createContext({
  hookName: 'useQrCodeContext',
  providerName: '<QrCodeProvider />'
});

const QrCodeContext = props => props.children(useQrCodeContext());

const QrCodeFrame = props => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps$1(() => qrCode().getFrameProps(), props);
  return createComponent(ark.svg, mergedProps);
};

const QrCodeOverlay = props => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps$1(() => qrCode().getOverlayProps(), props);
  return createComponent(ark.div, mergedProps);
};

const QrCodePattern = props => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps$1(() => qrCode().getPatternProps(), props);
  return createComponent(ark.path, mergedProps);
};

const useQrCode = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(qrCode$1.machine(context()), {
    context
  });
  return createMemo(() => qrCode$1.connect(state, send, normalizeProps));
};

const QrCodeRoot = props => {
  const [useQrCodeProps, restProps] = createSplitProps()(props, ['encoding', 'id', 'ids', 'value']);
  const api = useQrCode(useQrCodeProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), restProps);
  return createComponent(QrCodeProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const QrCodeRootProvider = props => {
  const [{
    value: qrCode
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => qrCode().getRootProps(), localProps);
  return createComponent(QrCodeProvider, {
    value: qrCode,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var qrCode = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Frame: QrCodeFrame,
  Overlay: QrCodeOverlay,
  Pattern: QrCodePattern,
  QrCodeContext: QrCodeContext,
  Root: QrCodeRoot,
  RootProvider: QrCodeRootProvider
});

const [RadioGroupProvider, useRadioGroupContext] = createContext({
  hookName: 'useRadioGroupContext',
  providerName: '<RadioGroupProvider />'
});

const RadioGroupContext = props => props.children(useRadioGroupContext());

const RadioGroupIndicator = props => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps$1(() => radioGroup().getIndicatorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const [RadioGroupItemProvider, useRadioGroupItemContext] = createContext({
  hookName: 'useRadioGroupItemContext',
  providerName: '<RadioGroupItemProvider />'
});

const [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext({
  hookName: 'useRadioGroupItemPropsContext',
  providerName: '<RadioGroupItemPropsProvider />'
});

const RadioGroupItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'disabled', 'invalid']);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps$1(() => radioGroup().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => radioGroup().getItemState(itemProps));
  return createComponent(RadioGroupItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(RadioGroupItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.label, mergedProps);
        }
      });
    }
  });
};

const RadioGroupItemContext = props => props.children(useRadioGroupItemContext());

const RadioGroupItemControl = props => {
  const radioGroup = useRadioGroupContext();
  const itemProps = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps$1(() => radioGroup().getItemControlProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const RadioGroupItemHiddenInput = props => {
  const radioGroup = useRadioGroupContext();
  const itemProps = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps$1(() => radioGroup().getItemHiddenInputProps(itemProps), props);
  return createComponent(ark.input, mergedProps);
};

const RadioGroupItemText = props => {
  const radioGroup = useRadioGroupContext();
  const itemProps = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps$1(() => radioGroup().getItemTextProps(itemProps), props);
  return createComponent(ark.span, mergedProps);
};

const RadioGroupLabel = props => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps$1(() => radioGroup().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useRadioGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(radio.machine(context()), {
    context
  });
  return createMemo(() => radio.connect(state, send, normalizeProps));
};

const RadioGroupRoot = props => {
  const [useRadioGroupProps, localProps] = createSplitProps()(props, ['defaultValue', 'disabled', 'form', 'id', 'ids', 'name', 'onValueChange', 'orientation', 'readOnly', 'value']);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps$1(() => radioGroup().getRootProps(), localProps);
  return createComponent(RadioGroupProvider, {
    value: radioGroup,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const RadioGroupRootProvider = props => {
  const [{
    value: radioGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => radioGroup().getRootProps(), localProps);
  return createComponent(RadioGroupProvider, {
    value: radioGroup,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var radioGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: RadioGroupContext,
  Indicator: RadioGroupIndicator,
  Item: RadioGroupItem,
  ItemContext: RadioGroupItemContext,
  ItemControl: RadioGroupItemControl,
  ItemHiddenInput: RadioGroupItemHiddenInput,
  ItemText: RadioGroupItemText,
  Label: RadioGroupLabel,
  Root: RadioGroupRoot,
  RootProvider: RadioGroupRootProvider
});

const [RatingGroupProvider, useRatingGroupContext] = createContext({
  hookName: 'useRatingGroupContext',
  providerName: '<RatingGroupProvider />'
});

const RatingGroupContext = props => props.children(useRatingGroupContext());

const RatingGroupControl = props => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps$1(() => ratingGroup().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const RatingGroupHiddenInput = props => {
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps$1(() => ratingGroup().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const [RatingGroupItemProvider, useRatingGroupItemContext] = createContext({
  hookName: 'useRatingGroupItemContext',
  providerName: '<RatingGroupItemProvider />'
});

const RatingGroupItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const api = useRatingGroupContext();
  const mergedProps = mergeProps$1(() => api().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => api().getItemState(itemProps));
  return createComponent(RatingGroupItemProvider, {
    value: itemState,
    get children() {
      return createComponent(ark.span, mergedProps);
    }
  });
};

const RatingGroupItemContext = props => props.children(useRatingGroupItemContext());

const RatingGroupLabel = props => {
  const api = useRatingGroupContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useRatingGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(rating.machine(context()), {
    context
  });
  return createMemo(() => rating.connect(state, send, normalizeProps));
};

const RatingGroupRoot = props => {
  const [useRatingProps, localProps] = createSplitProps()(props, ['allowHalf', 'autoFocus', 'count', 'defaultValue', 'disabled', 'form', 'id', 'ids', 'name', 'onHoverChange', 'onValueChange', 'readOnly', 'required', 'translations', 'value']);
  const api = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(RatingGroupProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const RatingGroupRootProvider = props => {
  const [{
    value: ratingGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => ratingGroup().getRootProps(), localProps);
  return createComponent(RatingGroupProvider, {
    value: ratingGroup,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var ratingGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: RatingGroupContext,
  Control: RatingGroupControl,
  HiddenInput: RatingGroupHiddenInput,
  Item: RatingGroupItem,
  ItemContext: RatingGroupItemContext,
  Label: RatingGroupLabel,
  Root: RatingGroupRoot,
  RootProvider: RatingGroupRootProvider
});

const [SegmentGroupProvider, useSegmentGroupContext] = createContext({
  hookName: 'useSegmentGroupContext',
  providerName: '<SegmentGroupProvider />'
});

const SegmentGroupContext = props => props.children(useSegmentGroupContext());

const segmentGroupAnatomy = anatomy$4.rename('segment-group');
const parts = segmentGroupAnatomy.build();

const SegmentGroupIndicator = props => {
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = mergeProps$1(() => segmentGroup().getIndicatorProps(), parts.indicator.attrs, props);
  return createComponent(ark.div, mergedProps);
};

const [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext({
  hookName: 'useSegmentGroupItemContext',
  providerName: '<SegmentGroupItemProvider />'
});

const [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext({
  hookName: 'useSegmentGroupItemPropsContext',
  providerName: '<SegmentGroupItemPropsProvider />'
});

const SegmentGroupItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['value', 'disabled', 'invalid']);
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = mergeProps$1(() => segmentGroup().getItemProps(itemProps), parts.item.attrs, localProps);
  const itemState = createMemo(() => segmentGroup().getItemState(itemProps));
  return createComponent(SegmentGroupItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(SegmentGroupItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.label, mergedProps);
        }
      });
    }
  });
};

const SegmentGroupItemContext = props => props.children(useSegmentGroupItemContext());

const SegmentGroupItemControl = props => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps$1(() => segmentGroup().getItemControlProps(itemProps), parts.itemControl.attrs, props);
  return createComponent(ark.div, mergedProps);
};

const SegmentGroupItemHiddenInput = props => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps$1(() => segmentGroup().getItemHiddenInputProps(itemProps), props);
  return createComponent(ark.input, mergedProps);
};

const SegmentGroupItemText = props => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps$1(() => segmentGroup().getItemTextProps(itemProps), parts.itemText.attrs, props);
  return createComponent(ark.span, mergedProps);
};

const SegmentGroupLabel = props => {
  const segmentGroup = useSegmentGroupContext();
  const mergedProps = mergeProps$1(() => segmentGroup().getLabelProps(), parts.label.attrs, props);
  return createComponent(ark.label, mergedProps);
};

const useSegmentGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(radio.machine(context()), {
    context
  });
  return createMemo(() => radio.connect(state, send, normalizeProps));
};

const SegmentGroupRoot = props => {
  const [useSegmentGroupProps, localProps] = createSplitProps()(props, ['defaultValue', 'disabled', 'form', 'id', 'ids', 'name', 'onValueChange', 'orientation', 'readOnly', 'value']);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps$1(() => segmentGroup().getRootProps(), parts.root.attrs, localProps);
  return createComponent(SegmentGroupProvider, {
    value: segmentGroup,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SegmentGroupRootProvider = props => {
  const [{
    value: segmentGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => segmentGroup().getRootProps(), parts.root.attrs, localProps);
  return createComponent(SegmentGroupProvider, {
    value: segmentGroup,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var segmentGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SegmentGroupContext,
  Indicator: SegmentGroupIndicator,
  Item: SegmentGroupItem,
  ItemContext: SegmentGroupItemContext,
  ItemControl: SegmentGroupItemControl,
  ItemHiddenInput: SegmentGroupItemHiddenInput,
  ItemText: SegmentGroupItemText,
  Label: SegmentGroupLabel,
  Root: SegmentGroupRoot,
  RootProvider: SegmentGroupRootProvider
});

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
const [SelectProvider, useSelectContext] = createContext({
  hookName: 'useSelectContext',
  providerName: '<SelectProvider />'
});

const SelectClearTrigger = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getClearTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const SelectContent = props => {
  const select = useSelectContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => select().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SelectContext = props => props.children(useSelectContext());

const SelectControl = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

var _tmpl$$2 = /*#__PURE__*/template(`<option value="">`),
  _tmpl$2$1 = /*#__PURE__*/template(`<option>`);
const SelectHiddenSelect = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getHiddenSelectProps(), props);
  const isValueEmpty = createMemo(() => select().value.length === 0);
  const field = useFieldContext();
  return createComponent(ark.select, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps, {
    get children() {
      return [createComponent(Show, {
        get when() {
          return isValueEmpty();
        },
        get children() {
          return _tmpl$$2();
        }
      }), createComponent(Index, {
        get each() {
          return select().collection.items;
        },
        children: item => (() => {
          var _el$2 = _tmpl$2$1();
          effect(() => _el$2.disabled = select().collection.getItemDisabled(item()));
          effect(() => _el$2.value = select().collection.getItemValue(item()) ?? '');
          return _el$2;
        })()
      })];
    }
  }));
};

const SelectIndicator = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getIndicatorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const [SelectItemProvider, useSelectItemContext] = createContext({
  hookName: 'useSelectItemContext',
  providerName: '<SelectItemProvider />'
});

const [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  hookName: 'useSelectItemPropsContext',
  providerName: '<SelectItemPropsProvider />'
});

const SelectItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['item', 'persistFocus']);
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => select().getItemState(itemProps));
  return createComponent(SelectItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(SelectItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const SelectItemContext = props => props.children(useSelectItemContext());

const [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  hookName: 'useSelectItemGroupPropsContext',
  providerName: '<SelectItemGroupPropsProvider />'
});

const SelectItemGroup = props => {
  const [_itemGroupProps, localProps] = createSplitProps()(props, ['id']);
  const select = useSelectContext();
  const itemGroupProps = mergeProps$1({
    id: createUniqueId()
  }, _itemGroupProps);
  const mergedProps = mergeProps$1(() => select().getItemGroupProps(itemGroupProps), localProps);
  return createComponent(SelectItemGroupPropsProvider, {
    value: itemGroupProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SelectItemGroupLabel = props => {
  const select = useSelectContext();
  const itemGroupProps = useSelectItemGroupPropsContext();
  const mergedProps = mergeProps$1(() => select().getItemGroupLabelProps({
    htmlFor: itemGroupProps.id
  }), props);
  return createComponent(ark.div, mergedProps);
};

const SelectItemIndicator = props => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = mergeProps$1(() => select().getItemIndicatorProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const SelectItemText = props => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = mergeProps$1(() => select().getItemTextProps(itemProps), props);
  return createComponent(ark.span, mergedProps);
};

const SelectLabel = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const SelectList = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getListProps(), props);
  return createComponent(ark.div, mergedProps);
};

const SelectPositioner = props => {
  const select = useSelectContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => select().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useSelect = props => {
  const [collectionOptions, selectProps] = createSplitProps()(props, ['isItemDisabled', 'itemToValue', 'itemToString', 'items']);
  const collection = createMemo(() => select$1.collection({
    ...collectionOptions
  }));
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const initialContext = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenSelect: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    invalid: field?.().invalid,
    required: field?.().required,
    collection: collection(),
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    value: props.defaultValue,
    'open.controlled': props.open !== undefined,
    ...selectProps
  }));
  const context = createMemo(() => {
    const [, restProps] = splitProps(initialContext(), ['collection']);
    return restProps;
  });
  const [state, send] = useMachine(select$1.machine(initialContext()), {
    context
  });
  const api = createMemo(() => select$1.connect(state, send, normalizeProps));
  createEffect(() => {
    api().setCollection(collection());
  });
  return api;
};

const SelectRoot = props => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [useSelectProps, localProps] = createSplitProps()(selectProps, ['closeOnSelect', 'composite', 'defaultOpen', 'defaultValue', 'disabled', 'form', 'highlightedValue', 'id', 'ids', 'invalid', 'isItemDisabled', 'items', 'itemToString', 'itemToValue', 'loopFocus', 'multiple', 'name', 'onFocusOutside', 'onHighlightChange', 'onInteractOutside', 'onOpenChange', 'onPointerDownOutside', 'onValueChange', 'open', 'positioning', 'readOnly', 'required', 'scrollToIndexFn', 'value']);
  const select = useSelect(useSelectProps);
  const presenceApi = usePresence(mergeProps$1(() => ({
    present: select().open
  }), presenceProps));
  const mergedProps = mergeProps$1(() => select().getRootProps(), localProps);
  return createComponent(SelectProvider, {
    value: select,
    get children() {
      return createComponent(PresenceProvider, {
        value: presenceApi,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const SelectRootProvider = props => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [{
    value: select
  }, localProps] = createSplitProps()(selectProps, ['value']);
  const presence = usePresence(mergeProps$1(() => ({
    present: select().open
  }), presenceProps));
  const mergedProps = mergeProps$1(() => select().getRootProps(), localProps);
  return createComponent(SelectProvider, {
    value: select,
    get children() {
      return createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const SelectTrigger = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const SelectValueText = props => {
  const select = useSelectContext();
  const mergedProps = mergeProps$1(() => select().getValueTextProps(), props);
  return createComponent(ark.span, mergeProps(mergedProps, {
    get children() {
      return select().valueAsString || props.placeholder;
    }
  }));
};

var select = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: SelectClearTrigger,
  Content: SelectContent,
  Context: SelectContext,
  Control: SelectControl,
  HiddenSelect: SelectHiddenSelect,
  Indicator: SelectIndicator,
  Item: SelectItem,
  ItemContext: SelectItemContext,
  ItemGroup: SelectItemGroup,
  ItemGroupLabel: SelectItemGroupLabel,
  ItemIndicator: SelectItemIndicator,
  ItemText: SelectItemText,
  Label: SelectLabel,
  List: SelectList,
  Positioner: SelectPositioner,
  Root: SelectRoot,
  RootProvider: SelectRootProvider,
  Trigger: SelectTrigger,
  ValueText: SelectValueText
});

const [SignaturePadProvider, useSignaturePadContext] = createContext({
  hookName: 'useSignaturePadContext',
  providerName: '<SignaturePadProvider />'
});

const SignaturePadClearTrigger = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps$1(() => signaturePad().getClearTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const SignaturePadContext = props => props.children(useSignaturePadContext());

const SignaturePadControl = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps$1(() => signaturePad().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const SignaturePadGuide = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps$1(() => signaturePad().getGuideProps(), props);
  return createComponent(ark.div, mergedProps);
};

const SignaturePadLabel = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps$1(() => signaturePad().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const SignaturePadHiddenInput = props => {
  const [hiddenInputProps, localProps] = createSplitProps()(props, ['value']);
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps$1(() => signaturePad().getHiddenInputProps(hiddenInputProps), localProps);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const useSignaturePad = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(signaturePad$1.machine(context()), {
    context
  });
  return createMemo(() => signaturePad$1.connect(state, send, normalizeProps));
};

const SignaturePadRoot = props => {
  const [useSignaturePadProps, localProps] = createSplitProps()(props, ['id', 'ids', 'drawing', 'disabled', 'readOnly', 'name', 'onDraw', 'onDrawEnd', 'readOnly', 'required', 'translations']);
  const signaturePad = useSignaturePad(useSignaturePadProps);
  const mergedProps = mergeProps$1(() => signaturePad().getRootProps(), localProps);
  return createComponent(SignaturePadProvider, {
    value: signaturePad,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SignaturePadRootProvider = props => {
  const [{
    value: signaturePad
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => signaturePad().getRootProps(), localProps);
  return createComponent(SignaturePadProvider, {
    value: signaturePad,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var _tmpl$$1 = /*#__PURE__*/template(`<title>Signature`),
  _tmpl$2 = /*#__PURE__*/template(`<svg><path></svg>`, false, true);
const SignaturePadSegment = props => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps$1(() => signaturePad().getSegmentProps(), props);
  return createComponent(ark.svg, mergeProps(mergedProps, {
    get children() {
      return [_tmpl$$1(), createComponent(For, {
        get each() {
          return signaturePad().paths;
        },
        children: path => (() => {
          var _el$3 = _tmpl$2();
          spread(_el$3, mergeProps(() => signaturePad().getSegmentPathProps({
            path
          })), true, false);
          return _el$3;
        })()
      }), createComponent(Show, {
        get when() {
          return signaturePad().currentPath;
        },
        get children() {
          var _el$2 = _tmpl$2();
          spread(_el$2, mergeProps(() => signaturePad().getSegmentPathProps({
            path: signaturePad().currentPath
          })), true, false);
          return _el$2;
        }
      })];
    }
  }));
};

var signaturePad = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: SignaturePadClearTrigger,
  Context: SignaturePadContext,
  Control: SignaturePadControl,
  Guide: SignaturePadGuide,
  HiddenInput: SignaturePadHiddenInput,
  Label: SignaturePadLabel,
  Root: SignaturePadRoot,
  RootProvider: SignaturePadRootProvider,
  Segment: SignaturePadSegment
});

const [SliderProvider, useSliderContext] = createContext({
  hookName: 'useSliderContext',
  providerName: '<SliderProvider />'
});

const SliderContext = props => props.children(useSliderContext());

const SliderControl = props => {
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext({
  hookName: 'useSliderThumbPropsContext',
  providerName: '<SliderThumbPropsProvider />'
});

const SliderHiddenInput = props => {
  const slider = useSliderContext();
  const thumbProps = useSliderThumbPropsContext();
  const mergedProps = mergeProps$1(slider().getHiddenInputProps(thumbProps), props);
  return createComponent(ark.input, mergedProps);
};

const SliderLabel = props => {
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const SliderMarker = props => {
  const [markerProps, localProps] = createSplitProps()(props, ['value']);
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getMarkerProps(markerProps), localProps);
  return createComponent(ark.span, mergedProps);
};

const SliderMarkerGroup = props => {
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getMarkerGroupProps(), props);
  return createComponent(ark.div, mergedProps);
};

const SliderRange = props => {
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getRangeProps(), props);
  return createComponent(ark.div, mergedProps);
};

const useSlider = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(slider$1.machine(context()), {
    context
  });
  return createMemo(() => slider$1.connect(state, send, normalizeProps));
};

const SliderRoot = props => {
  const [useSliderProps, localProps] = createSplitProps()(props, ['aria-label', 'aria-labelledby', 'defaultValue', 'disabled', 'form', 'getAriaValueText', 'id', 'ids', 'invalid', 'max', 'min', 'minStepsBetweenThumbs', 'name', 'onFocusChange', 'onValueChange', 'onValueChangeEnd', 'orientation', 'origin', 'readOnly', 'step', 'thumbAlignment', 'thumbAlignment', 'thumbSize', 'value']);
  const api = useSlider(useSliderProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(SliderProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SliderRootProvider = props => {
  const [{
    value: slider
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => slider().getRootProps(), localProps);
  return createComponent(SliderProvider, {
    value: slider,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SliderThumb = props => {
  const [thumbProps, localProps] = createSplitProps()(props, ['index', 'name']);
  const slider = useSliderContext();
  const mergedProps = mergeProps$1(() => slider().getThumbProps(thumbProps), localProps);
  return createComponent(SliderThumbPropsProvider, {
    value: thumbProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SliderTrack = props => {
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getTrackProps(), props);
  return createComponent(ark.div, mergedProps);
};

const SliderValueText = props => {
  const api = useSliderContext();
  const mergedProps = mergeProps$1(() => api().getValueTextProps(), props);
  return createComponent(ark.span, mergeProps(mergedProps, {
    get children() {
      return props.children || api().value.join(',');
    }
  }));
};

var slider = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SliderContext,
  Control: SliderControl,
  HiddenInput: SliderHiddenInput,
  Label: SliderLabel,
  Marker: SliderMarker,
  MarkerGroup: SliderMarkerGroup,
  Range: SliderRange,
  Root: SliderRoot,
  RootProvider: SliderRootProvider,
  Thumb: SliderThumb,
  Track: SliderTrack,
  ValueText: SliderValueText
});

const [SplitterProvider, useSplitterContext] = createContext({
  hookName: 'useSplitterContext',
  providerName: '<SplitterProvider />'
});

const SplitterContext = props => props.children(useSplitterContext());

const SplitterPanel = props => {
  const [panelProps, restProps] = createSplitProps()(props, ['id', 'snapSize']);
  const api = useSplitterContext();
  const mergedProps = mergeProps$1(() => api().getPanelProps(panelProps), restProps);
  return createComponent(ark.div, mergedProps);
};

const SplitterResizeTrigger = props => {
  const [resizeTriggerProps, restProps] = createSplitProps()(props, ['disabled', 'id', 'step']);
  const api = useSplitterContext();
  const mergedProps = mergeProps$1(() => api().getResizeTriggerProps(resizeTriggerProps), restProps);
  return createComponent(ark.button, mergedProps);
};

const useSplitter = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    size: props.defaultSize,
    ...props
  }));
  const [state, send] = useMachine(splitter$1.machine(context()), {
    context
  });
  return createMemo(() => splitter$1.connect(state, send, normalizeProps));
};

const SplitterRoot = props => {
  const [useSplitterProps, localProps] = createSplitProps()(props, ['defaultSize', 'id', 'ids', 'onSizeChange', 'onSizeChangeEnd', 'orientation', 'size']);
  const api = useSplitter(useSplitterProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(SplitterProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const SplitterRootProvider = props => {
  const [{
    value: splitter
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => splitter().getRootProps(), localProps);
  return createComponent(SplitterProvider, {
    value: splitter,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var splitter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SplitterContext,
  Panel: SplitterPanel,
  ResizeTrigger: SplitterResizeTrigger,
  Root: SplitterRoot,
  RootProvider: SplitterRootProvider
});

const [SwitchProvider, useSwitchContext] = createContext({
  hookName: 'useSwitchContext',
  providerName: '<SwitchProvider />'
});

const SwitchContext = props => props.children(useSwitchContext());

const SwitchControl = props => {
  const api = useSwitchContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.span, mergedProps);
};

const SwitchHiddenInput = props => {
  const api = useSwitchContext();
  const mergedProps = mergeProps$1(() => api().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const SwitchLabel = props => {
  const api = useSwitchContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.span, mergedProps);
};

const useSwitch = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    invalid: field?.().invalid,
    required: field?.().required,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    checked: props.defaultChecked,
    ...props
  }));
  const [state, send] = useMachine(zagSwitch.machine(context()), {
    context
  });
  return createMemo(() => zagSwitch.connect(state, send, normalizeProps));
};

const SwitchRoot = props => {
  const [switchProps, localProps] = createSplitProps()(props, ['checked', 'defaultChecked', 'disabled', 'form', 'id', 'ids', 'invalid', 'label', 'name', 'onCheckedChange', 'readOnly', 'required', 'value']);
  const api = useSwitch(switchProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(SwitchProvider, {
    value: api,
    get children() {
      return createComponent(ark.label, mergedProps);
    }
  });
};

const SwitchRootProvider = props => {
  const [{
    value: api
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(SwitchProvider, {
    value: api,
    get children() {
      return createComponent(ark.label, mergedProps);
    }
  });
};

const SwitchThumb = props => {
  const api = useSwitchContext();
  const mergedProps = mergeProps$1(() => api().getThumbProps(), props);
  return createComponent(ark.span, mergedProps);
};

var _switch = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: SwitchContext,
  Control: SwitchControl,
  HiddenInput: SwitchHiddenInput,
  Label: SwitchLabel,
  Root: SwitchRoot,
  RootProvider: SwitchRootProvider,
  Thumb: SwitchThumb
});

const [TabsProvider, useTabsContext] = createContext({
  hookName: 'useTabsContext',
  providerName: '<TabsProvider />'
});

const TabContent = props => {
  const [contentProps, localProps] = createSplitProps()(props, ['value']);
  const api = useTabsContext();
  const renderStrategyProps = useRenderStrategyContext();
  const presenceApi = usePresence(mergeProps$1(renderStrategyProps, () => ({
    present: api().value === contentProps.value,
    immediate: true
  })));
  const mergedProps = mergeProps$1(() => api().getContentProps(contentProps), () => presenceApi().presenceProps, localProps);
  return createComponent(PresenceProvider, {
    value: presenceApi,
    get children() {
      return createComponent(Show, {
        get when() {
          return !presenceApi().unmounted;
        },
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TabIndicator = props => {
  const api = useTabsContext();
  const mergedProps = mergeProps$1(() => api().getIndicatorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TabList = props => {
  const api = useTabsContext();
  const mergedProps = mergeProps$1(() => api().getListProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TabTrigger = props => {
  const [triggerProps, localProps] = createSplitProps()(props, ['disabled', 'value']);
  const api = useTabsContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(triggerProps), localProps);
  return createComponent(ark.button, mergedProps);
};

const TabsContext = props => props.children(useTabsContext());

const useTabs = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(tabs$1.machine(context()), {
    context
  });
  return createMemo(() => tabs$1.connect(state, send, normalizeProps));
};

const TabsRoot = props => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [useTabsProps, restProps] = createSplitProps()(tabsProps, ['activationMode', 'composite', 'defaultValue', 'id', 'ids', 'loopFocus', 'onFocusChange', 'onValueChange', 'orientation', 'translations', 'value']);
  const api = useTabs(useTabsProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), restProps);
  return createComponent(TabsProvider, {
    value: api,
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TabsRootProvider = props => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [{
    value: tabs
  }, localprops] = createSplitProps()(tabsProps, ['value']);
  const mergedProps = mergeProps$1(() => tabs().getRootProps(), localprops);
  return createComponent(TabsProvider, {
    value: tabs,
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

var tabs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: TabContent,
  Context: TabsContext,
  Indicator: TabIndicator,
  List: TabList,
  Root: TabsRoot,
  RootProvider: TabsRootProvider,
  Trigger: TabTrigger
});

const [TagsInputProvider, useTagsInputContext] = createContext({
  hookName: 'useTagsInputContext',
  providerName: '<TagsInputProvider />'
});

const TagsInputClearTrigger = props => {
  const api = useTagsInputContext();
  const mergedProps = mergeProps$1(() => api().getClearTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const TagsInputContext = props => props.children(useTagsInputContext());

const TagsInputControl = props => {
  const api = useTagsInputContext();
  const mergedProps = mergeProps$1(() => api().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TagsInputHiddenInput = props => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps$1(() => tagsInput().getHiddenInputProps(), props);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};

const TagsInputInput = props => {
  const api = useTagsInputContext();
  const mergedProps = mergeProps$1(() => api().getInputProps(), props);
  return createComponent(ark.input, mergedProps);
};

const [TagsInputItemProvider, useTagsInputItemContext] = createContext({
  hookName: 'useTagsInputItemContext',
  providerName: '<TagsInputItemProvider />'
});

const [TagsInputItemPropsProvider, useTagsInputItemPropsContext] = createContext({
  hookName: 'useTagsInputItemPropsContext',
  providerName: '<TagsInputItemPropsProvider />'
});

const TagsInputItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['disabled', 'index', 'value']);
  const api = useTagsInputContext();
  const mergedProps = mergeProps$1(() => api().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => api().getItemState(itemProps));
  return createComponent(TagsInputItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(TagsInputItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TagsInputItemContext = props => props.children(useTagsInputItemContext());

const TagsInputItemDeleteTrigger = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemDeleteTriggerProps(itemProps), props);
  return createComponent(ark.button, mergedProps);
};

const TagsInputItemInput = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemInputProps(itemProps), props);
  return createComponent(ark.input, mergedProps);
};

const TagsInputItemPreview = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemPreviewProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const TagsInputItemText = props => {
  const api = useTagsInputContext();
  const itemProps = useTagsInputItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemTextProps(itemProps), props);
  return createComponent(ark.span, mergedProps);
};

const TagsInputLabel = props => {
  const api = useTagsInputContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useTagsInput = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const field = useFieldContext();
  const context = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      hiddenInput: field?.().ids.control
    },
    dir: locale().dir,
    disabled: field?.().disabled,
    invalid: field?.().invalid,
    readOnly: field?.().readOnly,
    required: field?.().required,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(tagsInput$1.machine(context()), {
    context
  });
  return createMemo(() => tagsInput$1.connect(state, send, normalizeProps));
};

const TagsInputRoot = props => {
  const [useTagsInputProps, localProps] = createSplitProps()(props, ['addOnPaste', 'allowOverflow', 'autoFocus', 'blurBehavior', 'delimiter', 'defaultValue', 'disabled', 'editable', 'form', 'id', 'ids', 'inputValue', 'invalid', 'max', 'maxLength', 'name', 'onFocusOutside', 'onHighlightChange', 'onInputValueChange', 'onInteractOutside', 'onPointerDownOutside', 'onValueChange', 'onValueInvalid', 'readOnly', 'required', 'translations', 'validate', 'value']);
  const api = useTagsInput(useTagsInputProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(TagsInputProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TagsInputRootProvider = props => {
  const [{
    value: tagsInput
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => tagsInput().getRootProps(), localProps);
  return createComponent(TagsInputProvider, {
    value: tagsInput,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var tagsInput = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClearTrigger: TagsInputClearTrigger,
  Context: TagsInputContext,
  Control: TagsInputControl,
  HiddenInput: TagsInputHiddenInput,
  Input: TagsInputInput,
  Item: TagsInputItem,
  ItemContext: TagsInputItemContext,
  ItemDeleteTrigger: TagsInputItemDeleteTrigger,
  ItemInput: TagsInputItemInput,
  ItemPreview: TagsInputItemPreview,
  ItemText: TagsInputItemText,
  Label: TagsInputLabel,
  Root: TagsInputRoot,
  RootProvider: TagsInputRootProvider
});

const [TimePickerColumnPropsProvider, useTimePickerColumnPropsContext] = createContext({
  hookName: 'useTimePickerColumnPropsContext',
  providerName: '<TimePickerColumnPropsProvider />'
});

const [TimePickerProvider, useTimePickerContext] = createContext({
  hookName: 'useTimePickerContext',
  providerName: '<TimePickerProvider />'
});

const TimePickerCell = props => {
  const [cellProps, localProps] = createSplitProps()(props, ['value']);
  const timePicker = useTimePickerContext();
  const columnProps = useTimePickerColumnPropsContext();
  const unitToPropsMap = {
    hour: () => timePicker().getHourCellProps(cellProps),
    minute: () => timePicker().getMinuteCellProps(cellProps),
    second: () => timePicker().getSecondCellProps(cellProps),
    period: () => timePicker().getPeriodCellProps(cellProps)
  };
  const mergedProps = mergeProps$1(() => unitToPropsMap[columnProps.unit](), localProps);
  return createComponent(ark.button, mergedProps);
};

const TimePickerClearTrigger = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getClearTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const TimePickerColumn = props => {
  const [columnProps, localProps] = createSplitProps()(props, ['unit']);
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getColumnProps(columnProps), localProps);
  return createComponent(TimePickerColumnPropsProvider, {
    value: columnProps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TimePickerContent = props => {
  const timePicker = useTimePickerContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => timePicker().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TimePickerContext = props => props.children(useTimePickerContext());

const TimePickerControl = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getControlProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TimePickerInput = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getInputProps(), props);
  return createComponent(ark.input, mergedProps);
};

const TimePickerLabel = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const TimePickerPositioner = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getPositionerProps(), props);
  const presenceApi = usePresenceContext();
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useTimePicker = (props = {}) => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props,
    value: props.defaultValue ? parseTime(props.defaultValue) : undefined,
    min: props.min ? parseTime(props.min) : undefined,
    max: props.max ? parseTime(props.max) : undefined
  }));
  const [state, send] = useMachine(timePicker$1.machine(context()), {
    context
  });
  return createMemo(() => timePicker$1.connect(state, send, normalizeProps));
};

const TimePickerRoot = props => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props);
  const [useTimePickerProps, localProps] = createSplitProps()(timePickerProps, ['allowSeconds', 'defaultOpen', 'defaultValue', 'disableLayer', 'disabled', 'id', 'ids', 'locale', 'max', 'min', 'name', 'onFocusChange', 'onOpenChange', 'onValueChange', 'open', 'placeholder', 'positioning', 'readOnly', 'steps', 'value']);
  const timePicker = useTimePicker(useTimePickerProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: timePicker().open
  })));
  const mergedProps = mergeProps$1(() => timePicker().getRootProps(), localProps);
  return createComponent(TimePickerProvider, {
    value: timePicker,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TimePickerRootProvider = props => {
  const [presenceProps, timePickerProps] = splitPresenceProps(props);
  const [{
    value: timePicker
  }, localProps] = createSplitProps()(timePickerProps, ['value']);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: timePicker().open
  })));
  const mergedProps = mergeProps$1(() => timePicker().getRootProps(), localProps);
  return createComponent(TimePickerProvider, {
    value: timePicker,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};

const TimePickerSpacer = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getSpacerProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TimePickerTrigger = props => {
  const timePicker = useTimePickerContext();
  const mergedProps = mergeProps$1(() => timePicker().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var timePicker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Cell: TimePickerCell,
  ClearTrigger: TimePickerClearTrigger,
  Column: TimePickerColumn,
  Content: TimePickerContent,
  Context: TimePickerContext,
  Control: TimePickerControl,
  Input: TimePickerInput,
  Label: TimePickerLabel,
  Positioner: TimePickerPositioner,
  Root: TimePickerRoot,
  RootProvider: TimePickerRootProvider,
  Spacer: TimePickerSpacer,
  Trigger: TimePickerTrigger
});

const createToaster = props => {
  const machine = toast$1.group.machine({
    id: '1',
    ...props
  });
  const api = toast$1.group.connect(machine, machine.send, normalizeProps);
  return {
    ...api,
    machine
  };
};

const [ToastProvider, useToastContext] = createContext({
  hookName: 'useToastContext',
  providerName: '<ToastProvider />'
});

const ToastActionTrigger = props => {
  const toast = useToastContext();
  const mergedProps = mergeProps$1(() => toast().getActionTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const ToastCloseTrigger = props => {
  const toast = useToastContext();
  const mergedProps = mergeProps$1(() => toast().getCloseTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const ToastContext = props => props.children(useToastContext());

const ToastDescription = props => {
  const toast = useToastContext();
  const mergedProps = mergeProps$1(() => toast().getDescriptionProps(), props);
  return createComponent(ark.div, mergedProps);
};

var _tmpl$ = /*#__PURE__*/template(`<div><div></div><div>`);
const ToastRoot = props => {
  const toast = useToastContext();
  const mergedProps = mergeProps$1(() => toast().getRootProps(), props);
  return (() => {
    var _el$ = _tmpl$(),
      _el$2 = _el$.firstChild,
      _el$3 = _el$2.nextSibling;
    spread(_el$, mergedProps, false, true);
    spread(_el$2, mergeProps(() => toast().getGhostBeforeProps()), false, false);
    insert(_el$, () => props.children, _el$3);
    spread(_el$3, mergeProps(() => toast().getGhostAfterProps()), false, false);
    return _el$;
  })();
};

const ToastTitle = props => {
  const toast = useToastContext();
  const mergedProps = mergeProps$1(() => toast().getTitleProps(), props);
  return createComponent(ark.div, mergedProps);
};

const Toaster = props => {
  const [toasterProps, localProps] = splitProps(props, ['toaster', 'children']);
  const [state, send] = useMachine(toasterProps.toaster.machine);
  const placement = state.context.placement;
  const api = createMemo(() => toast$1.group.connect(state, send, normalizeProps));
  const toasts = createMemo(() => api().getToastsByPlacement(placement));
  const mergedProps = mergeProps$1(api().getGroupProps({
    placement
  }), localProps);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return createComponent(For, {
        get each() {
          return toasts();
        },
        children: toast => createComponent(ToastActor, {
          value: toast,
          children: ctx => toasterProps.children(ctx)
        })
      });
    }
  }));
};
const ToastActor = props => {
  const [state, send] = useActor(props.value);
  const api = createMemo(() => toast$1.connect(state, send, normalizeProps));
  const ctx = createMemo(() => state.context);
  return createComponent(ToastProvider, {
    value: api,
    get children() {
      return props.children(ctx);
    }
  });
};

var toast = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ActionTrigger: ToastActionTrigger,
  CloseTrigger: ToastCloseTrigger,
  Context: ToastContext,
  Description: ToastDescription,
  Root: ToastRoot,
  Title: ToastTitle
});

const [ToggleGroupProvider, useToggleGroupContext] = createContext({
  hookName: 'useToggleGroupContext',
  providerName: '<ToggleGroupProvider />'
});

const ToggleGroupContext = props => props.children(useToggleGroupContext());

const ToggleGroupItem = props => {
  const [toggleProps, restProps] = createSplitProps()(props, ['value', 'disabled']);
  const api = useToggleGroupContext();
  const mergedProps = mergeProps$1(() => api().getItemProps(toggleProps), restProps);
  return createComponent(ark.button, mergedProps);
};

const useToggleGroup = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    value: props.defaultValue,
    ...props
  }));
  const [state, send] = useMachine(toggleGroup$1.machine(context()), {
    context
  });
  return createMemo(() => toggleGroup$1.connect(state, send, normalizeProps));
};

const ToggleGroupRoot = props => {
  const [useToggleGroupProps, restProps] = createSplitProps()(props, ['defaultValue', 'disabled', 'id', 'ids', 'loopFocus', 'multiple', 'onValueChange', 'orientation', 'rovingFocus', 'value']);
  const api = useToggleGroup(useToggleGroupProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), restProps);
  return createComponent(ToggleGroupProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const ToggleGroupRootProvider = props => {
  const [{
    value: toggleGroup
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => toggleGroup().getRootProps(), localProps);
  return createComponent(ToggleGroupProvider, {
    value: toggleGroup,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var toggleGroup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Context: ToggleGroupContext,
  Item: ToggleGroupItem,
  Root: ToggleGroupRoot,
  RootProvider: ToggleGroupRootProvider
});

const [TooltipProvider, useTooltipContext] = createContext({
  hookName: 'useTooltipContext',
  providerName: '<TooltipProvider />'
});

const TooltipArrow = props => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps$1(() => tooltip().getArrowProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TooltipArrowTip = props => {
  const api = useTooltipContext();
  const mergedProps = mergeProps$1(() => api().getArrowTipProps(), props);
  return createComponent(ark.div, mergedProps);
};

const TooltipContent = props => {
  const api = useTooltipContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getContentProps(), () => presenceApi().presenceProps, props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TooltipContext = props => props.children(useTooltipContext());

const TooltipPositioner = props => {
  const api = useTooltipContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps$1(() => api().getPositionerProps(), props);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const useTooltip = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    open: props.defaultOpen,
    'open.controlled': props.open !== undefined,
    ...props
  }));
  const [state, send] = useMachine(tooltip$1.machine(context()), {
    context
  });
  return createMemo(() => tooltip$1.connect(state, send, normalizeProps));
};

const TooltipRoot = props => {
  const [presenceProps, tooltipProps] = splitPresenceProps(props);
  const [useTooltipProps, localProps] = createSplitProps()(tooltipProps, ['aria-label', 'closeDelay', 'closeOnClick', 'closeOnEscape', 'closeOnPointerDown', 'closeOnScroll', 'defaultOpen', 'disabled', 'id', 'ids', 'interactive', 'onOpenChange', 'open', 'openDelay', 'positioning']);
  const api = useTooltip(useTooltipProps);
  const apiPresence = usePresence(mergeProps$1(presenceProps, () => ({
    present: api().open
  })));
  return createComponent(TooltipProvider, {
    value: api,
    get children() {
      return createComponent(PresenceProvider, {
        value: apiPresence,
        get children() {
          return localProps.children;
        }
      });
    }
  });
};

const TooltipRootProvider = props => {
  const [presenceProps, tooltipProps] = splitPresenceProps(props);
  const presence = usePresence(mergeProps$1(presenceProps, () => ({
    present: tooltipProps.value().open
  })));
  return createComponent(TooltipProvider, {
    get value() {
      return tooltipProps.value;
    },
    get children() {
      return createComponent(PresenceProvider, {
        value: presence,
        get children() {
          return tooltipProps.children;
        }
      });
    }
  });
};

const TooltipTrigger = props => {
  const api = useTooltipContext();
  const mergedProps = mergeProps$1(() => api().getTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

var tooltip = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: TooltipArrow,
  ArrowTip: TooltipArrowTip,
  Content: TooltipContent,
  Context: TooltipContext,
  Positioner: TooltipPositioner,
  Root: TooltipRoot,
  RootProvider: TooltipRootProvider,
  Trigger: TooltipTrigger
});

const [TreeViewBranchProvider, useTreeViewBranchContext] = createContext({
  hookName: 'useTreeViewBranchContext',
  providerName: '<TreeViewBranchProvider />'
});

const [TreeViewProvider, useTreeViewContext] = createContext({
  hookName: 'useTreeViewContext',
  providerName: '<TreeViewProvider />'
});

const [TreeViewDepthProvider, useTreeViewDepthContext] = createContext({
  hookName: 'useTreeViewDepthContext',
  providerName: '<TreeViewDepthProvider />'
});

const TreeViewBranch = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['disabled', 'value']);
  const api = useTreeViewContext();
  const depth = useTreeViewDepthContext();
  const branchProps = mergeProps$1(itemProps, {
    depth
  });
  const mergedProps = mergeProps$1(() => api().getBranchProps(branchProps), localProps);
  return createComponent(TreeViewDepthProvider, {
    value: depth + 1,
    get children() {
      return createComponent(TreeViewBranchProvider, {
        value: branchProps,
        get children() {
          return createComponent(ark.li, mergedProps);
        }
      });
    }
  });
};

const TreeViewBranchContent = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = mergeProps$1(() => api().getBranchContentProps(branchProps), props);
  return createComponent(ark.ul, mergedProps);
};

const TreeViewBranchControl = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = mergeProps$1(() => api().getBranchControlProps(branchProps), props);
  return createComponent(ark.div, mergedProps);
};

const TreeViewBranchIndicator = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = mergeProps$1(() => api().getBranchIndicatorProps(branchProps), props);
  return createComponent(ark.div, mergedProps);
};

const TreeViewBranchText = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = mergeProps$1(() => api().getBranchTextProps(branchProps), props);
  return createComponent(ark.span, mergedProps);
};

const TreeViewBranchTrigger = props => {
  const api = useTreeViewContext();
  const branchProps = useTreeViewBranchContext();
  const mergedProps = mergeProps$1(() => api().getBranchTriggerProps(branchProps), props);
  return createComponent(ark.div, mergedProps);
};

const TreeViewContext = props => props.children(useTreeViewContext());

const [TreeViewItemProvider, useTreeViewItemContext] = createContext({
  hookName: 'useTreeViewItemContext',
  providerName: '<TreeViewItemProvider />'
});

const [TreeViewItemPropsProvider, useTreeViewItemPropsContext] = createContext({
  hookName: 'useTreeViewItemPropsContext',
  providerName: '<TreeViewItemProvider />'
});

const TreeViewItem = props => {
  const [_itemProps, localProps] = createSplitProps()(props, ['disabled', 'value']);
  const api = useTreeViewContext();
  const depth = useTreeViewDepthContext();
  const itemProps = mergeProps$1(_itemProps, {
    depth
  });
  const itemState = createMemo(() => api().getItemState(itemProps));
  const mergedProps = mergeProps$1(() => api().getItemProps(itemProps), localProps);
  return createComponent(TreeViewItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(TreeViewItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.li, mergedProps);
        }
      });
    }
  });
};

const TreeViewItemContext = props => props.children(useTreeViewItemContext());

const TreeViewItemIndicator = props => {
  const api = useTreeViewContext();
  const itemProps = useTreeViewItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemIndicatorProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const TreeViewItemText = props => {
  const api = useTreeViewContext();
  const itemProps = useTreeViewItemPropsContext();
  const mergedProps = mergeProps$1(() => api().getItemTextProps(itemProps), props);
  return createComponent(ark.span, mergedProps);
};

const TreeViewLabel = props => {
  const api = useTreeViewContext();
  const mergedProps = mergeProps$1(() => api().getLabelProps(), props);
  return createComponent(ark.label, mergedProps);
};

const useTreeView = props => {
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    selectedValue: props.defaultSelectedValue,
    expandedValue: props.defaultExpandedValue,
    ...props
  }));
  const [state, send] = useMachine(treeView$1.machine(context()), {
    context
  });
  return createMemo(() => treeView$1.connect(state, send, normalizeProps));
};

const TreeViewRoot = props => {
  const [useTreeViewProps, localProps] = createSplitProps()(props, ['defaultExpandedValue', 'defaultSelectedValue', 'expandedValue', 'expandOnClick', 'focusedValue', 'id', 'ids', 'onExpandedChange', 'onFocusChange', 'onSelectionChange', 'selectedValue', 'selectionMode', 'typeahead']);
  const api = useTreeView(useTreeViewProps);
  const mergedProps = mergeProps$1(() => api().getRootProps(), localProps);
  return createComponent(TreeViewProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TreeViewRootProvider = props => {
  const [{
    value: treeView
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => treeView().getRootProps(), localProps);
  return createComponent(TreeViewProvider, {
    value: treeView,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TreeViewTree = props => {
  const api = useTreeViewContext();
  const mergedProps = mergeProps$1(() => api().getTreeProps(), props);
  return createComponent(TreeViewDepthProvider, {
    value: 1,
    get children() {
      return createComponent(ark.ul, mergedProps);
    }
  });
};

var treeView = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Branch: TreeViewBranch,
  BranchContent: TreeViewBranchContent,
  BranchControl: TreeViewBranchControl,
  BranchIndicator: TreeViewBranchIndicator,
  BranchText: TreeViewBranchText,
  BranchTrigger: TreeViewBranchTrigger,
  Context: TreeViewContext,
  Item: TreeViewItem,
  ItemContext: TreeViewItemContext,
  ItemIndicator: TreeViewItemIndicator,
  ItemText: TreeViewItemText,
  Label: TreeViewLabel,
  Root: TreeViewRoot,
  RootProvider: TreeViewRootProvider,
  Tree: TreeViewTree
});

const [TimerProvider, useTimerContext] = createContext({
  hookName: 'useTimerContext',
  providerName: '<TimerProvider />'
});

const TimerContext = props => props.children(useTimerContext());

const TimerActionTrigger = props => {
  const timer = useTimerContext();
  const mergedProps = mergeProps$1(() => timer().getActionTriggerProps(props), props);
  return createComponent(ark.button, mergedProps);
};

const TimerItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['type']);
  const timer = useTimerContext();
  const mergedProps = mergeProps$1(() => timer().getItemProps(itemProps), localProps);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return timer().formattedTime[itemProps.type];
    }
  }));
};

const TimerSeparator = props => {
  const timer = useTimerContext();
  const mergedProps = mergeProps$1(() => timer().getSeparatorProps(), props);
  return createComponent(ark.div, mergedProps);
};

const useTimer = props => {
  const env = useEnvironmentContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    getRootNode: env().getRootNode,
    ...props
  }));
  const [state, send] = useMachine(timer$1.machine(context()), {
    context
  });
  return createMemo(() => timer$1.connect(state, send, normalizeProps));
};

const TimerRoot = props => {
  const [useTimerProps, localProps] = createSplitProps()(props, ['id', 'autoStart', 'interval', 'countdown', 'startMs', 'targetMs', 'onComplete', 'onTick']);
  const timer = useTimer(useTimerProps);
  const mergedProps = mergeProps$1(() => timer().getRootProps(), localProps);
  return createComponent(TimerProvider, {
    value: timer,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const TimerRootProvider = props => {
  const [{
    value: timer
  }, localProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => timer().getRootProps(), localProps);
  return createComponent(TimerProvider, {
    value: timer,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

var timer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ActionTrigger: TimerActionTrigger,
  Context: TimerContext,
  Item: TimerItem,
  Root: TimerRoot,
  RootProvider: TimerRootProvider,
  Separator: TimerSeparator
});

const [StepsProvider, useStepsContext] = createContext({
  hookName: 'useStepsContext',
  providerName: '<StepsProvider />'
});

const StepsCompletedContent = props => {
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getContentProps({
    index: steps().count
  }), props);
  return createComponent(ark.div, mergedProps);
};

const StepsContent = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getContentProps(itemProps), localProps);
  return createComponent(ark.div, mergedProps);
};

const StepsContext = props => {
  const context = useStepsContext();
  return props.children(context);
};

const [StepsItemPropsProvider, useStepsItemPropsContext] = createContext({
  hookName: 'useStepsItemPropsContext',
  providerName: '<StepsItemPropsProvider />'
});

const StepsIndicator = props => {
  const steps = useStepsContext();
  const itemProps = useStepsItemPropsContext();
  const mergedProps = mergeProps$1(() => steps().getIndicatorProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const [StepsItemProvider, useStepsItemContext] = createContext({
  hookName: 'useStepsItemContext',
  providerName: '<StepsItem />'
});

const StepsItem = props => {
  const [itemProps, localProps] = createSplitProps()(props, ['index']);
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getItemProps(itemProps), localProps);
  const itemState = createMemo(() => steps().getItemState(itemProps));
  return createComponent(StepsItemPropsProvider, {
    value: itemProps,
    get children() {
      return createComponent(StepsItemProvider, {
        value: itemState,
        get children() {
          return createComponent(ark.li, mergedProps);
        }
      });
    }
  });
};

const StepsItemContext = props => {
  return props.children(useStepsItemContext());
};
StepsItemContext.displayName = 'StepsItemContext';

const StepsList = props => {
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getListProps(), props);
  return createComponent(ark.ol, mergedProps);
};

const StepsNextTrigger = props => {
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getNextTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const StepsPrevTrigger = props => {
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getPrevTriggerProps(), props);
  return createComponent(ark.button, mergedProps);
};

const StepsProgress = props => {
  const steps = useStepsContext();
  const mergedProps = mergeProps$1(() => steps().getProgressProps(), props);
  return createComponent(ark.div, mergedProps);
};

function useSteps(props = {}) {
  const environment = useEnvironmentContext();
  const locale = useLocaleContext();
  const id = createUniqueId();
  const context = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    step: props.defaultStep,
    ...props
  }));
  const [state, send] = useMachine(steps$1.machine(context()), {
    context
  });
  return createMemo(() => steps$1.connect(state, send, normalizeProps));
}

const StepsRoot = props => {
  const [useStepsProps, localProps] = createSplitProps()(props, ['defaultStep', 'id', 'ids', 'count', 'linear', 'onStepChange', 'onStepComplete', 'orientation', 'step']);
  const steps = useSteps(useStepsProps);
  const mergedProps = mergeProps$1(() => steps().getRootProps(), localProps);
  return createComponent(StepsProvider, {
    value: steps,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};

const StepsRootProvider = props => {
  const [{
    value: steps
  }, rootProps] = createSplitProps()(props, ['value']);
  const mergedProps = mergeProps$1(() => steps().getRootProps(), rootProps);
  return createComponent(StepsProvider, {
    value: steps,
    get children() {
      return createComponent(ark.div, mergeProps(mergedProps, {
        get children() {
          return props.children;
        }
      }));
    }
  });
};

const StepsSeparator = props => {
  const steps = useStepsContext();
  const itemProps = useStepsItemPropsContext();
  const mergedProps = mergeProps$1(() => steps().getSeparatorProps(itemProps), props);
  return createComponent(ark.div, mergedProps);
};

const StepsTrigger = props => {
  const steps = useStepsContext();
  const itemProps = useStepsItemPropsContext();
  const mergedProps = mergeProps$1(() => steps().getTriggerProps(itemProps), props);
  return createComponent(ark.button, mergedProps);
};

var steps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CompletedContent: StepsCompletedContent,
  Content: StepsContent,
  Context: StepsContext,
  Indicator: StepsIndicator,
  Item: StepsItem,
  ItemContext: StepsItemContext,
  List: StepsList,
  NextTrigger: StepsNextTrigger,
  PrevTrigger: StepsPrevTrigger,
  Progress: StepsProgress,
  Root: StepsRoot,
  RootProvider: StepsRootProvider,
  Separator: StepsSeparator,
  Trigger: StepsTrigger
});

export { accordion as Accordion, AccordionContext, AccordionItem, AccordionItemContent, AccordionItemContext, AccordionItemIndicator, AccordionItemTrigger, AccordionRoot, AccordionRootProvider, avatar as Avatar, AvatarContext, AvatarFallback, AvatarImage, AvatarRoot, AvatarRootProvider, carousel as Carousel, CarouselContext, CarouselControl, CarouselIndicator, CarouselIndicatorGroup, CarouselItem, CarouselItemGroup, CarouselNextTrigger, CarouselPrevTrigger, CarouselRoot, CarouselRootProvider, CarouselViewport, checkbox as Checkbox, CheckboxContext, CheckboxControl, CheckboxGroup, CheckboxHiddenInput, CheckboxIndicator, CheckboxLabel, CheckboxRoot, CheckboxRootProvider, clipboard as Clipboard, ClipboardContext, ClipboardControl, ClipboardIndicator, ClipboardInput, ClipboardLabel, ClipboardRoot, ClipboardRootProvider, ClipboardTrigger, collapsible as Collapsible, CollapsibleContent, CollapsibleContext, CollapsibleRoot, CollapsibleRootProvider, CollapsibleTrigger, colorPicker as ColorPicker, ColorPickerArea, ColorPickerAreaBackground, ColorPickerAreaThumb, ColorPickerChannelInput, ColorPickerChannelSlider, ColorPickerChannelSliderLabel, ColorPickerChannelSliderThumb, ColorPickerChannelSliderTrack, ColorPickerChannelSliderValueText, ColorPickerContent, ColorPickerContext, ColorPickerControl, ColorPickerEyeDropperTrigger, ColorPickerFormatSelect, ColorPickerFormatTrigger, ColorPickerHiddenInput, ColorPickerLabel, ColorPickerPositioner, ColorPickerRoot, ColorPickerRootProvider, ColorPickerSwatch, ColorPickerSwatchGroup, ColorPickerSwatchIndicator, ColorPickerSwatchTrigger, ColorPickerTransparencyGrid, ColorPickerTrigger, ColorPickerValueSwatch, ColorPickerValueText, ColorPickerView, combobox as Combobox, ComboboxClearTrigger, ComboboxContent, ComboboxContext, ComboboxControl, ComboboxInput, ComboboxItem, ComboboxItemContext, ComboboxItemGroup, ComboboxItemGroupLabel, ComboboxItemIndicator, ComboboxItemText, ComboboxLabel, ComboboxList, ComboboxPositioner, ComboboxRoot, ComboboxRootProvider, ComboboxTrigger, datePicker as DatePicker, DatePickerClearTrigger, DatePickerContent, DatePickerContext, DatePickerControl, DatePickerInput, DatePickerLabel, DatePickerMonthSelect, DatePickerNextTrigger, DatePickerPositioner, DatePickerPresetTrigger, DatePickerPrevTrigger, DatePickerRangeText, DatePickerRoot, DatePickerRootProvider, DatePickerTable, DatePickerTableBody, DatePickerTableCell, DatePickerTableCellTrigger, DatePickerTableHead, DatePickerTableHeader, DatePickerTableRow, DatePickerTrigger, DatePickerView, DatePickerViewControl, DatePickerViewTrigger, DatePickerYearSelect, dialog as Dialog, DialogBackdrop, DialogCloseTrigger, DialogContent, DialogContext, DialogDescription, DialogPositioner, DialogRoot, DialogRootProvider, DialogTitle, DialogTrigger, editable as Editable, EditableArea, EditableCancelTrigger, EditableContext, EditableControl, EditableEditTrigger, EditableInput, EditableLabel, EditablePreview, EditableRoot, EditableRootProvider, EditableSubmitTrigger, EnvironmentProvider, field as Field, FieldContext, FieldErrorText, FieldHelperText, FieldInput, FieldLabel, FieldRoot, FieldRootProvider, FieldSelect, FieldTextarea, fieldset as Fieldset, FieldsetContext, FieldsetErrorText, FieldsetHelperText, FieldsetLegend, FieldsetRoot, FieldsetRootProvider, fileUpload as FileUpload, FileUploadContext, FileUploadDropzone, FileUploadHiddenInput, FileUploadItem, FileUploadItemDeleteTrigger, FileUploadItemGroup, FileUploadItemName, FileUploadItemPreview, FileUploadItemPreviewImage, FileUploadItemSizeText, FileUploadLabel, FileUploadRoot, FileUploadRootProvider, FileUploadTrigger, format as Format, FormatByte, FormatNumber, Highlight, hoverCard as HoverCard, HoverCardArrow, HoverCardArrowTip, HoverCardContent, HoverCardContext, HoverCardPositioner, HoverCardRoot, HoverCardRootProvider, HoverCardTrigger, LocaleProvider, menu as Menu, MenuArrow, MenuArrowTip, MenuCheckboxItem, MenuContent, MenuContext, MenuContextTrigger, MenuIndicator, MenuItem, MenuItemContext, MenuItemGroup, MenuItemGroupLabel, MenuItemIndicator, MenuItemText, MenuPositioner, MenuRadioItem, MenuRadioItemGroup, MenuRoot, MenuRootProvider, MenuSeparator, MenuTrigger, MenuTriggerItem, numberInput as NumberInput, NumberInputContext, NumberInputControl, NumberInputDecrementTrigger, NumberInputIncrementTrigger, NumberInputInput, NumberInputLabel, NumberInputRoot, NumberInputRootProvider, NumberInputScrubber, NumberInputValueText, pagination as Pagination, PaginationContext, PaginationEllipsis, PaginationItem, PaginationNextTrigger, PaginationPrevTrigger, PaginationRoot, PaginationRootProvider, pinInput as PinInput, PinInputContext, PinInputControl, PinInputHiddenInput, PinInputInput, PinInputLabel, PinInputRoot, PinInputRootProvider, popover as Popover, PopoverAnchor, PopoverArrow, PopoverArrowTip, PopoverCloseTrigger, PopoverContent, PopoverContext, PopoverDescription, PopoverIndicator, PopoverPositioner, PopoverRoot, PopoverRootProvider, PopoverTitle, PopoverTrigger, Presence, PresenceProvider, progress as Progress, ProgressCircle, ProgressCircleRange, ProgressCircleTrack, ProgressContext, ProgressLabel, ProgressRange, ProgressRoot, ProgressRootProvider, ProgressTrack, ProgressValueText, ProgressView, qrCode as QrCode, QrCodeContext, QrCodeFrame, QrCodeOverlay, QrCodePattern, QrCodeRoot, QrCodeRootProvider, radioGroup as RadioGroup, RadioGroupContext, RadioGroupIndicator, RadioGroupItem, RadioGroupItemContext, RadioGroupItemControl, RadioGroupItemHiddenInput, RadioGroupItemText, RadioGroupLabel, RadioGroupRoot, RadioGroupRootProvider, ratingGroup as RatingGroup, RatingGroupContext, RatingGroupControl, RatingGroupHiddenInput, RatingGroupItem, RatingGroupItemContext, RatingGroupLabel, RatingGroupRoot, RatingGroupRootProvider, segmentGroup as SegmentGroup, SegmentGroupContext, SegmentGroupIndicator, SegmentGroupItem, SegmentGroupItemContext, SegmentGroupItemControl, SegmentGroupItemHiddenInput, SegmentGroupItemText, SegmentGroupLabel, SegmentGroupRoot, SegmentGroupRootProvider, select as Select, SelectClearTrigger, SelectContent, SelectContext, SelectControl, SelectHiddenSelect, SelectIndicator, SelectItem, SelectItemContext, SelectItemGroup, SelectItemGroupLabel, SelectItemIndicator, SelectItemText, SelectLabel, SelectList, SelectPositioner, SelectRoot, SelectRootProvider, SelectTrigger, SelectValueText, signaturePad as SignaturePad, SignaturePadClearTrigger, SignaturePadContext, SignaturePadControl, SignaturePadGuide, SignaturePadHiddenInput, SignaturePadLabel, SignaturePadRoot, SignaturePadRootProvider, SignaturePadSegment, slider as Slider, SliderContext, SliderControl, SliderHiddenInput, SliderLabel, SliderMarker, SliderMarkerGroup, SliderRange, SliderRoot, SliderRootProvider, SliderThumb, SliderTrack, SliderValueText, splitter as Splitter, SplitterContext, SplitterPanel, SplitterResizeTrigger, SplitterRoot, SplitterRootProvider, steps as Steps, StepsCompletedContent, StepsContent, StepsContext, StepsIndicator, StepsItem, StepsItemContext, StepsList, StepsNextTrigger, StepsPrevTrigger, StepsProgress, StepsRoot, StepsRootProvider, StepsSeparator, StepsTrigger, _switch as Switch, SwitchContext, SwitchControl, SwitchHiddenInput, SwitchLabel, SwitchRoot, SwitchRootProvider, SwitchThumb, TabContent, TabIndicator, TabList, TabTrigger, tabs as Tabs, TabsContext, TabsRoot, TabsRootProvider, tagsInput as TagsInput, TagsInputClearTrigger, TagsInputContext, TagsInputControl, TagsInputHiddenInput, TagsInputInput, TagsInputItem, TagsInputItemContext, TagsInputItemDeleteTrigger, TagsInputItemInput, TagsInputItemPreview, TagsInputItemText, TagsInputLabel, TagsInputRoot, TagsInputRootProvider, timePicker as TimePicker, TimePickerCell, TimePickerClearTrigger, TimePickerColumn, TimePickerContent, TimePickerContext, TimePickerControl, TimePickerInput, TimePickerLabel, TimePickerPositioner, TimePickerRoot, TimePickerRootProvider, TimePickerSpacer, TimePickerTrigger, timer as Timer, TimerActionTrigger, TimerContext, TimerItem, TimerRoot, TimerRootProvider, TimerSeparator, toast as Toast, ToastActionTrigger, ToastCloseTrigger, ToastContext, ToastDescription, ToastRoot, ToastTitle, Toaster, toggleGroup as ToggleGroup, ToggleGroupContext, ToggleGroupItem, ToggleGroupRoot, ToggleGroupRootProvider, tooltip as Tooltip, TooltipArrow, TooltipArrowTip, TooltipContent, TooltipContext, TooltipPositioner, TooltipRoot, TooltipRootProvider, TooltipTrigger, treeView as TreeView, TreeViewBranch, TreeViewBranchContent, TreeViewBranchControl, TreeViewBranchIndicator, TreeViewBranchText, TreeViewBranchTrigger, TreeViewContext, TreeViewItem, TreeViewItemContext, TreeViewItemIndicator, TreeViewItemText, TreeViewLabel, TreeViewRoot, TreeViewRootProvider, TreeViewTree, ark, carouselAnatomy, checkboxAnatomy, colorPickerAnatomy, createToaster, datePickerAnatomy, fieldAnatomy, fieldsetAnatomy, segmentGroupAnatomy, splitPresenceProps, useAccordion, useAccordionContext, useAccordionItemContext, useAvatar, useAvatarContext, useCarousel, useCarouselContext, useCheckbox, useCheckboxContext, useCheckboxGroup, useCheckboxGroupContext, useClipboard, useClipboardContext, useCollapsible, useCollapsibleContext, useColorPicker, useColorPickerContext, useCombobox, useComboboxContext, useComboboxItemContext, useDatePicker, useDatePickerContext, useDialog, useDialogContext, useEditable, useEditableContext, useEnvironmentContext, useFieldContext, useFieldsetContext, useFileUpload, useFileUploadContext, useHighlight, useHoverCard, useHoverCardContext, useLocaleContext, useMenu, useMenuContext, useMenuItemContext, useNumberInput, useNumberInputContext, usePagination, usePaginationContext, usePinInput, usePinInputContext, usePopover, usePopoverContext, usePresence, usePresenceContext, useProgress, useProgressContext, useQrCode, useQrCodeContext, useRadioGroup, useRadioGroupContext, useRadioGroupItemContext, useRatingGroup, useRatingGroupContext, useRatingGroupItemContext, useSegmentGroup, useSegmentGroupContext, useSegmentGroupItemContext, useSelect, useSelectContext, useSelectItemContext, useSignaturePad, useSignaturePadContext, useSlider, useSliderContext, useSplitter, useSplitterContext, useSteps, useStepsContext, useStepsItemContext, useSwitch, useSwitchContext, useTabs, useTabsContext, useTagsInput, useTagsInputContext, useTagsInputItemContext, useTimePicker, useTimePickerContext, useTimer, useTimerContext, useToastContext, useToggleGroup, useToggleGroupContext, useTooltip, useTooltipContext, useTreeView, useTreeViewContext, useTreeViewItemContext };
//# sourceMappingURL=index.js.map
